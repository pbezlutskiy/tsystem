---
queries:
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/CallsToInitDel/MissingCallToDel.ql
  relativeBqrsPath: codeql/python-queries/Classes/CallsToInitDel/MissingCallToDel.bqrs
  metadata:
    name: Missing call to superclass `__del__` during object destruction
    description: An omitted call to a superclass `__del__` method may lead to class
      instances not being cleaned up properly.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             performance
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/missing-call-to-delete
  queryHelp: "# Missing call to superclass `__del__` during object destruction\nPython,\
    \ unlike some other object-oriented languages such as Java, allows the developer\
    \ complete freedom in when and how superclass finalizers are called during object\
    \ finalization. However, the developer has responsibility for ensuring that objects\
    \ are properly cleaned up, and that all superclass `__del__` methods are called.\n\
    \nClasses with a `__del__` method (a finalizer) typically hold some resource such\
    \ as a file handle that needs to be cleaned up. If the `__del__` method of a superclass\
    \ is not called during object finalization, it is likely that resources may be\
    \ leaked.\n\nA call to the `__del__` method of a superclass during object initialization\
    \ may be unintentionally skipped:\n\n* If a subclass calls the `__del__` method\
    \ of the wrong class.\n* If a call to the `__del__` method of one its base classes\
    \ is omitted.\n* If a call to `super().__del__` is used, but not all `__del__`\
    \ methods in the Method Resolution Order (MRO) chain themselves call `super()`.\
    \ This in particular arises more often in cases of multiple inheritance.\n\n##\
    \ Recommendation\nEnsure that all superclass `__del__` methods are properly called.\
    \ Either each base class's finalize method should be explicitly called, or `super()`\
    \ calls should be consistently used throughout the inheritance hierarchy.\n\n\n\
    ## Example\nIn the following example, explicit calls to `__del__` are used, but\
    \ `SportsCar` erroneously calls `Vehicle.__del__`. This is fixed in `FixedSportsCar`\
    \ by calling `Car.__del__`.\n\n\n```python\n\nclass Vehicle(object):\n    \n \
    \   def __del__(self):\n        recycle(self.base_parts)\n        \nclass Car(Vehicle):\n\
    \    \n    def __del__(self):\n        recycle(self.car_parts)\n        Vehicle.__del__(self)\n\
    \        \n#BAD: Car.__del__ is not called.\nclass SportsCar(Car, Vehicle):\n\
    \    \n    def __del__(self):\n        recycle(self.sports_car_parts)\n      \
    \  Vehicle.__del__(self)\n        \n#GOOD: Car.__del__ is called correctly.\n\
    class FixedSportsCar(Car, Vehicle):\n    \n    def __del__(self):\n        recycle(self.sports_car_parts)\n\
    \        Car.__del__(self)\n        \n\n```\n\n## References\n* Python Reference:\
    \ [__del__](https://docs.python.org/3/reference/datamodel.html#object.__del__).\n\
    * Python Standard Library: [super](https://docs.python.org/3/library/functions.html#super).\n\
    * Python Glossary: [Method resolution order](https://docs.python.org/3/glossary.html#term-method-resolution-order).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/CallsToInitDel/MissingCallToInit.ql
  relativeBqrsPath: codeql/python-queries/Classes/CallsToInitDel/MissingCallToInit.bqrs
  metadata:
    name: Missing call to superclass `__init__` during object initialization
    description: An omitted call to a superclass `__init__` method may lead to objects
      of this class not being fully initialized.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/missing-call-to-init
  queryHelp: "# Missing call to superclass `__init__` during object initialization\n\
    Python, unlike some other object-oriented languages such as Java, allows the developer\
    \ complete freedom in when and how superclass initializers are called during object\
    \ initialization. However, the developer has responsibility for ensuring that\
    \ objects are properly initialized, and that all superclass `__init__` methods\
    \ are called.\n\nIf the `__init__` method of a superclass is not called during\
    \ object initialization, this can lead to errors due to the object not being fully\
    \ initialized, such as having missing attributes.\n\nA call to the `__init__`\
    \ method of a superclass during object initialization may be unintentionally skipped:\n\
    \n* If a subclass calls the `__init__` method of the wrong class.\n* If a call\
    \ to the `__init__` method of one its base classes is omitted.\n* If a call to\
    \ `super().__init__` is used, but not all `__init__` methods in the Method Resolution\
    \ Order (MRO) chain themselves call `super()`. This in particular arises more\
    \ often in cases of multiple inheritance.\n\n## Recommendation\nEnsure that all\
    \ superclass `__init__` methods are properly called. Either each base class's\
    \ initialize method should be explicitly called, or `super()` calls should be\
    \ consistently used throughout the inheritance hierarchy.\n\n\n## Example\nIn\
    \ the following example, explicit calls to `__init__` are used, but `SportsCar`\
    \ erroneously calls `Vehicle.__init__`. This is fixed in `FixedSportsCar` by calling\
    \ `Car.__init__`.\n\n\n```python\n\nclass Vehicle(object):\n    \n    def __init__(self):\n\
    \        self.mobile = True\n        \nclass Car(Vehicle):\n    \n    def __init__(self):\n\
    \        Vehicle.__init__(self)\n        self.car_init()\n        \n# BAD: Car.__init__\
    \ is not called.\nclass SportsCar(Car, Vehicle):\n    \n    def __init__(self):\n\
    \        Vehicle.__init__(self)\n        self.sports_car_init()\n        \n# GOOD:\
    \ Car.__init__ is called correctly.\nclass FixedSportsCar(Car, Vehicle):\n   \
    \ \n    def __init__(self):\n        Car.__init__(self)\n        self.sports_car_init()\n\
    \        \n\n```\n\n## References\n* Python Reference: [__init__](https://docs.python.org/3/reference/datamodel.html#object.__init__).\n\
    * Python Standard Library: [super](https://docs.python.org/3/library/functions.html#super).\n\
    * Python Glossary: [Method resolution order](https://docs.python.org/3/glossary.html#term-method-resolution-order).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/CallsToInitDel/SuperclassDelCalledMultipleTimes.ql
  relativeBqrsPath: codeql/python-queries/Classes/CallsToInitDel/SuperclassDelCalledMultipleTimes.bqrs
  metadata:
    name: Multiple calls to `__del__` during object destruction
    description: A duplicated call to a superclass `__del__` method may lead to class
      instances not be cleaned up properly.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/multiple-calls-to-delete
  queryHelp: "# Multiple calls to `__del__` during object destruction\nPython, unlike\
    \ some other object-oriented languages such as Java, allows the developer complete\
    \ freedom in when and how superclass finalizers are called during object finalization.\
    \ However, the developer has responsibility for ensuring that objects are properly\
    \ cleaned up.\n\nObjects with a `__del__` method (a finalizer) often hold resources\
    \ such as file handles that need to be cleaned up. If a superclass finalizer is\
    \ called multiple times, this may lead to errors such as closing an already closed\
    \ file, and lead to objects not being cleaned up properly as expected.\n\nThere\
    \ are a number of ways that a `__del__` method may be called more than once.\n\
    \n* There may be more than one explicit call to the method in the hierarchy of\
    \ `__del__` methods.\n* In situations involving multiple inheritance, an finalization\
    \ method may call the finalizers of each of its base types, which themselves both\
    \ call the finalizer of a shared base type. (This is an example of the Diamond\
    \ Inheritance problem)\n* Another situation involving multiple inheritance arises\
    \ when a subclass calls the `__del__` methods of each of its base classes, one\
    \ of which calls `super().__del__`. This super call resolves to the next class\
    \ in the Method Resolution Order (MRO) of the subclass, which may be another base\
    \ class that already has its initializer explicitly called.\n\n## Recommendation\n\
    Ensure that each finalizer method is called exactly once during finalization.\
    \ This can be ensured by calling `super().__del__` for each finalizer method in\
    \ the inheritance chain.\n\n\n## Example\nIn the following example, there is a\
    \ mixture of explicit calls to `__del__` and calls using `super()`, resulting\
    \ in `Vehicle.__del__` being called twice. `FixedSportsCar.__del__` fixes this\
    \ by using `super()` consistently with the other delete methods.\n\n\n```python\n\
    \n#Calling a method multiple times by using explicit calls when a base uses super()\n\
    class Vehicle(object):\n     \n    def __del__(self):\n        recycle(self.base_parts)\n\
    \        super(Vehicle, self).__del__()\n        \nclass Car(Vehicle):\n    \n\
    \    def __del__(self):\n        recycle(self.car_parts)\n        super(Car, self).__del__()\n\
    \        \n        \nclass SportsCar(Car, Vehicle):\n    \n    # BAD: Vehicle.__del__\
    \ will get called twice\n    def __del__(self):\n        recycle(self.sports_car_parts)\n\
    \        Car.__del__(self)\n        Vehicle.__del__(self)\n        \n        \n\
    # GOOD: super() is used ensuring each del method is called once.\nclass FixedSportsCar(Car,\
    \ Vehicle):\n    \n    def __del__(self):\n        recycle(self.sports_car_parts)\n\
    \        super(SportsCar, self).__del__()\n     \n\n\n```\n\n## References\n*\
    \ Python Reference: [__del__](https://docs.python.org/3/reference/datamodel.html#object.__del__).\n\
    * Python Standard Library: [super](https://docs.python.org/3/library/functions.html#super).\n\
    * Python Glossary: [Method resolution order](https://docs.python.org/3/glossary.html#term-method-resolution-order).\n\
    * Wikipedia: [The Diamond Problem](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/CallsToInitDel/SuperclassInitCalledMultipleTimes.ql
  relativeBqrsPath: codeql/python-queries/Classes/CallsToInitDel/SuperclassInitCalledMultipleTimes.bqrs
  metadata:
    name: Multiple calls to `__init__` during object initialization
    description: A duplicated call to a superclass `__init__` method may lead to objects
      of this class not being properly initialized.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/multiple-calls-to-init
  queryHelp: "# Multiple calls to `__init__` during object initialization\nPython,\
    \ unlike some other object-oriented languages such as Java, allows the developer\
    \ complete freedom in when and how superclass initializers are called during object\
    \ initialization. However, the developer has responsibility for ensuring that\
    \ objects are properly initialized.\n\nCalling an `__init__` method more than\
    \ once during object initialization risks the object being incorrectly initialized,\
    \ as the method and the rest of the inheritance chain may not have been written\
    \ with the expectation that it could be called multiple times. For example, it\
    \ may set attributes to a default value in a way that unexpectedly overwrites\
    \ values setting those attributes in a subclass.\n\nThere are a number of ways\
    \ that an `__init__` method may be called more than once.\n\n* There may be more\
    \ than one explicit call to the method in the hierarchy of `__init__` methods.\n\
    * In situations involving multiple inheritance, an initialization method may call\
    \ the initializers of each of its base types, which themselves both call the initializer\
    \ of a shared base type. (This is an example of the Diamond Inheritance problem)\n\
    * Another situation involving multiple inheritance arises when a subclass calls\
    \ the `__init__` methods of each of its base classes, one of which calls `super().__init__`.\
    \ This super call resolves to the next class in the Method Resolution Order (MRO)\
    \ of the subclass, which may be another base class that already has its initializer\
    \ explicitly called.\n\n## Recommendation\nTake care whenever possible not to\
    \ call an an initializer multiple times. If each `__init__` method in the hierarchy\
    \ calls `super().__init__()`, then each initializer will be called exactly once\
    \ according to the MRO of the subclass. When explicitly calling base class initializers\
    \ (such as to pass different arguments to different initializers), ensure this\
    \ is done consistently throughout, rather than using `super()` calls in the base\
    \ classes.\n\nIn some cases, it may not be possible to avoid calling a base initializer\
    \ multiple times without significant refactoring. In this case, carefully check\
    \ that the initializer does not interfere with subclass initializers when called\
    \ multiple times (such as by overwriting attributes), and ensure this behavior\
    \ is documented.\n\n\n## Example\nIn the following (BAD) example, the class `D`\
    \ calls `B.__init__` and `C.__init__`, which each call `A.__init__`. This results\
    \ in `self.state` being set to `None` as `A.__init__` is called again after `B.__init__`\
    \ had finished. This may lead to unexpected results.\n\n\n```python\nclass A:\n\
    \    def __init__(self):\n        self.state = None \n\nclass B(A):\n    def __init__(self):\n\
    \        A.__init__(self)\n        self.state = \"B\"\n        self.b = 3 \n\n\
    class C(A):\n    def __init__(self):\n        A.__init__(self)\n        self.c\
    \ = 2 \n\nclass D(B,C):\n    def __init__(self):\n        B.__init__(self)\n \
    \       C.__init__(self) # BAD: This calls A.__init__ a second time, setting self.state\
    \ to None.\n        \n\n```\nIn the following (GOOD) example, a call to `super().__init__`\
    \ is made in each class in the inheritance hierarchy, ensuring each initializer\
    \ is called exactly once.\n\n\n```python\nclass A:\n    def __init__(self):\n\
    \        self.state = None \n\nclass B(A):\n    def __init__(self):\n        super().__init__()\n\
    \        self.state = \"B\"\n        self.b = 3 \n\nclass C(A):\n    def __init__(self):\n\
    \        super().__init__()\n        self.c = 2 \n\nclass D(B,C):\n    def __init__(self):\
    \ # GOOD: Each method calls super, so each init method runs once. self.state will\
    \ be set to \"B\".\n        super().__init__()\n        self.d = 1\n        \n\
    \n\n\n```\nIn the following (BAD) example, explicit base class calls are mixed\
    \ with `super()` calls, and `C.__init__` is called twice.\n\n\n```python\nclass\
    \ A:\n    def __init__(self):\n        print(\"A\")\n        self.state = None\
    \ \n\nclass B(A):\n    def __init__(self):\n        print(\"B\")\n        super().__init__()\
    \ # When called from D, this calls C.__init__\n        self.state = \"B\"\n  \
    \      self.b = 3 \n\nclass C(A):\n    def __init__(self):\n        print(\"C\"\
    )\n        super().__init__()\n        self.c = 2 \n\nclass D(B,C):\n    def __init__(self):\
    \ \n        B.__init__(self)\n        C.__init__(self) # BAD: C.__init__ is called\
    \ a second time\n```\n\n## References\n* Python Reference: [__init__](https://docs.python.org/3/reference/datamodel.html#object.__init__).\n\
    * Python Standard Library: [super](https://docs.python.org/3/library/functions.html#super).\n\
    * Python Glossary: [Method resolution order](https://docs.python.org/3/glossary.html#term-method-resolution-order).\n\
    * Wikipedia: [The Diamond Problem](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/Comparisons/EqualsOrHash.ql
  relativeBqrsPath: codeql/python-queries/Classes/Comparisons/EqualsOrHash.bqrs
  metadata:
    name: Inconsistent equality and hashing
    description: Defining a hash operation without defining equality may be a mistake.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-581
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/equals-hash-mismatch
  queryHelp: "# Inconsistent equality and hashing\nA hashable class has an `__eq__`\
    \ method, and a `__hash__` method that agrees with equality. When a hash method\
    \ is defined, an equality method should also be defined; otherwise object identity\
    \ is used for equality comparisons which may not be intended.\n\nNote that defining\
    \ an `__eq__` method without defining a `__hash__` method automatically makes\
    \ the class unhashable in Python 3. (even if a superclass defines a hash method).\n\
    \n\n## Recommendation\nIf a `__hash__` method is defined, ensure a compatible\
    \ `__eq__` method is also defined.\n\nTo explicitly declare a class as unhashable,\
    \ set `__hash__ = None`, rather than defining a `__hash__` method that always\
    \ raises an exception. Otherwise, the class would be incorrectly identified as\
    \ hashable by an `isinstance(obj, collections.abc.Hashable)` call.\n\n\n## Example\n\
    In the following example, the `A` class defines an hash method but no equality\
    \ method. Equality will be determined by object identity, which may not be the\
    \ expected behaviour.\n\n\n```python\nclass A:\n    def __init__(self, a, b):\n\
    \        self.a = a \n        self.b = b\n\n    # No equality method is defined\n\
    \    def __hash__(self):\n        return hash((self.a, self.b))\n\n```\n\n## References\n\
    * Python Language Reference: [object.__hash__](http://docs.python.org/reference/datamodel.html#object.__hash__).\n\
    * Python Glossary: [hashable](http://docs.python.org/3/glossary.html#term-hashable).\n\
    * Common Weakness Enumeration: [CWE-581](https://cwe.mitre.org/data/definitions/581.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/Comparisons/EqualsOrNotEquals.ql
  relativeBqrsPath: codeql/python-queries/Classes/Comparisons/EqualsOrNotEquals.bqrs
  metadata:
    name: Inconsistent equality and inequality
    description: Class definitions of equality and inequality operators may be inconsistent.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/inconsistent-equality
  queryHelp: "# Inconsistent equality and inequality\nIn order to ensure the `==`\
    \ and `!=` operators behave consistently as expected (i.e. they should be negations\
    \ of each other), care should be taken when implementing the `__eq__` and `__ne__`\
    \ special methods.\n\nIn Python 3, if the `__eq__` method is defined in a class\
    \ while the `__ne__` is not, then the `!=` operator will automatically delegate\
    \ to the `__eq__` method in the expected way.\n\nHowever, if the `__ne__` method\
    \ is defined without a corresponding `__eq__` method, the `==` operator will still\
    \ default to object identity (equivalent to the `is` operator), while the `!=`\
    \ operator will use the `__ne__` method, which may be inconsistent.\n\nAdditionally,\
    \ if the `__ne__` method is defined on a superclass, and the subclass defines\
    \ its own `__eq__` method without overriding the superclass `__ne__` method, the\
    \ `!=` operator will use this superclass `__ne__` method, rather than automatically\
    \ delegating to `__eq__`, which may be incorrect.\n\n\n## Recommendation\nEnsure\
    \ that when an `__ne__` method is defined, the `__eq__` method is also defined,\
    \ and their results are consistent. In most cases, the `__ne__` method does not\
    \ need to be defined at all, as the default behavior is to delegate to `__eq__`\
    \ and negate the result.\n\n\n## Example\nIn the following example, `A` defines\
    \ a `__ne__` method, but not an `__eq__` method. This leads to inconsistent results\
    \ between equality and inequality operators.\n\n\n```python\nclass A:\n    def\
    \ __init__(self, a):\n        self.a = a \n\n    # BAD: ne is defined, but not\
    \ eq.\n    def __ne__(self, other):\n        if not isinstance(other, A):\n  \
    \          return NotImplemented \n        return self.a != other.a\n\nx = A(1)\n\
    y = A(1)\n\nprint(x == y) # Prints False (potentially unexpected - object identity\
    \ is used)\nprint(x != y) # Prints False\n\n```\nIn the following example, `C`\
    \ defines an `__eq__` method, but its `__ne__` implementation is inherited from\
    \ `B`, which is not consistent with the equality operation.\n\n\n```python\nclass\
    \ B:\n    def __init__(self, b):\n        self.b = b \n    \n    def __eq__(self,\
    \ other):\n        return self.b == other.b \n    \n    def __ne__(self, other):\n\
    \        return self.b != other.b \n    \nclass C(B):\n    def __init__(self,\
    \ b, c):\n        super().__init__(b)\n        self.c = c \n\n    # BAD: eq is\
    \ defined, but != will use superclass ne method, which is not consistent\n   \
    \ def __eq__(self, other):\n        return self.b == other.b and self.c == other.c\
    \ \n    \nprint(C(1,2) == C(1,3)) # Prints False \nprint(C(1,2) != C(1,3)) # Prints\
    \ False (potentially unexpected)\n```\n\n## References\n* Python Language Reference:\
    \ [object.__ne__](http://docs.python.org/3/reference/datamodel.html#object.__ne__),\
    \ [Comparisons](http://docs.python.org/3/reference/expressions.html#comparisons).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/Comparisons/IncompleteOrdering.ql
  relativeBqrsPath: codeql/python-queries/Classes/Comparisons/IncompleteOrdering.bqrs
  metadata:
    name: Incomplete ordering
    description: "Class defines ordering comparison methods, but does not define both\
      \ strict and nonstrict ordering methods, to ensure all four comparison operators\
      \ behave as expected."
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/incomplete-ordering
  queryHelp: "# Incomplete ordering\nA class that implements the rich comparison operators\
    \ (`__lt__`, `__gt__`, `__le__`, or `__ge__`) should ensure that all four comparison\
    \ operations `<`, `<=`, `>`, and `>=` function as expected, consistent with expected\
    \ mathematical rules. In Python 3, this is ensured by implementing one of `__lt__`\
    \ or `__gt__`, and one of `__le__` or `__ge__`. If the ordering is not consistent\
    \ with default equality, then `__eq__` should also be implemented.\n\n\n## Recommendation\n\
    Ensure that at least one of `__lt__` or `__gt__` and at least one of `__le__`\
    \ or `__ge__` is defined.\n\nThe `functools.total_ordering` class decorator can\
    \ be used to automatically implement all four comparison methods from a single\
    \ one, which is typically the cleanest way to ensure all necessary comparison\
    \ methods are implemented consistently.\n\n\n## Example\nIn the following example,\
    \ only the `__lt__` operator has been implemented, which would lead to unexpected\
    \ errors if the `<=` or `>=` operators are used on `A` instances. The `__le__`\
    \ method should also be defined, as well as `__eq__` in this case.\n\n\n```python\n\
    class A:\n    def __init__(self, i):\n        self.i = i\n\n    # BAD: le is not\
    \ defined, so `A(1) <= A(2)` would result in an error.\n    def __lt__(self, other):\n\
    \        return self.i < other.i\n    \n```\n\n## References\n* Python Language\
    \ Reference: [Rich comparisons in Python](http://docs.python.org/3/reference/datamodel.html#object.__lt__).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/ConflictingAttributesInBaseClasses.ql
  relativeBqrsPath: codeql/python-queries/Classes/ConflictingAttributesInBaseClasses.bqrs
  metadata:
    name: Conflicting attributes in base classes
    description: "When a class subclasses multiple base classes and more than one\
      \ base class defines the same attribute, attribute overriding may result in\
      \ unexpected behavior by instances of this class."
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: low
    precision: high
    id: py/conflicting-attributes
  queryHelp: "# Conflicting attributes in base classes\nWhen a class subclasses multiple\
    \ base classes, attribute lookup is performed from left to right amongst the base\
    \ classes. This form of attribute lookup is called \"method resolution order\"\
    \ and is a solution to the [diamond inheritance problem](http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem)\
    \ where several base classes override a method in a shared superclass.\n\nUnfortunately,\
    \ this means that if more than one base class defines the same attribute, the\
    \ leftmost base class will effectively override the attribute of the rightmost\
    \ base class, even though the leftmost base class is not a subclass of the rightmost\
    \ base class. Unless the methods in question are designed for inheritance, using\
    \ `super`, then this implicit overriding may not be the desired behavior. Even\
    \ if it is the desired behavior it makes the code hard to understand and maintain.\n\
    \n\n## Recommendation\nThere are a number of ways that might be used to address\
    \ this issue:\n\n* Override the attribute in the subclass to implement the correct\
    \ behavior.\n* Modify the class hierarchy and move equivalent or redundant methods\
    \ to a common super class.\n* Modify the method hierarchy, breaking up complex\
    \ methods into constituent parts.\n* Use delegation rather than inheritance.\n\
    \n## Example\nIn this example the class `ThreadingTCPServer` inherits from `ThreadingMixIn`\
    \ and from `TCPServer`. However, both these classes implement `process_request`\
    \ which means that `ThreadingTCPServer` will inherit `process_request` from `ThreadingMixIn`.\
    \ Consequently, the implementation of `process_request` in `TCPServer` will be\
    \ ignored, which may not be the correct behavior.\n\n\n```python\n\nclass TCPServer(object):\n\
    \    \n    def process_request(self, request, client_address):\n        self.do_work(request,\
    \ client_address)\n        self.shutdown_request(request)\n\n    \nclass ThreadingMixIn:\n\
    \    \"\"\"Mix-in class to handle each request in a new thread.\"\"\"\n\n    def\
    \ process_request(self, request, client_address):\n        \"\"\"Start a new thread\
    \ to process the request.\"\"\"\n        t = threading.Thread(target = self.do_work,\
    \ args = (request, client_address))\n        t.daemon = self.daemon_threads\n\
    \        t.start()\n\nclass ThreadingTCPServer(ThreadingMixIn, TCPServer): pass\n\
    \n```\nThis can be fixed either by overriding the method, as shown in class `ThreadingTCPServerOverriding`\
    \ or by ensuring that the functionality provided by the two base classes does\
    \ not overlap, as shown in class `ThreadingTCPServerChangedHierarchy`.\n\n\n```python\n\
    \   \n#Fixed by overriding. This does not change behavior, but makes it explicit\
    \ and comprehensible.\nclass ThreadingTCPServerOverriding(ThreadingMixIn, TCPServer):\n\
    \    \n    def process_request(self, request, client_address):\n        #process_request\
    \ forwards to do_work, so it is OK to call ThreadingMixIn.process_request directly\n\
    \        ThreadingMixIn.process_request(self, request, client_address)\n     \
    \   \n\n#Fixed by separating threading functionality from request handling.\n\
    class ThreadingMixIn:\n    \"\"\"Mix-in class to help with threads.\"\"\"\n\n\
    \    def do_job_in_thread(self, job, args):\n        \"\"\"Start a new thread\
    \ to do the job\"\"\"\n        t = threading.Thread(target = job, args = args)\n\
    \        t.start()\n\nclass ThreadingTCPServerChangedHierarchy(ThreadingMixIn,\
    \ TCPServer):\n    \n    def process_request(self, request, client_address):\n\
    \        \"\"\"Start a new thread to process the request.\"\"\"\n        self.do_job_in_thread(self.do_work,\
    \  (request, client_address))\n    \n\n```\n\n## References\n* Python Language\
    \ Reference: [Data model](https://docs.python.org/2/reference/datamodel.html).\n\
    * Python releases: [The Python 2.3 Method Resolution Order](https://www.python.org/download/releases/2.3/mro/).\n\
    * Wikipedia: [C3 linearization](https://en.wikipedia.org/wiki/C3_linearization).\n\
    * Wikipedia: [Composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/DefineEqualsWhenAddingAttributes.ql
  relativeBqrsPath: codeql/python-queries/Classes/DefineEqualsWhenAddingAttributes.bqrs
  metadata:
    name: '`__eq__` not overridden when adding attributes'
    description: "When adding new attributes to instances of a class, equality for\
      \ that class needs to be defined."
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: high
    precision: high
    id: py/missing-equals
  queryHelp: |
    # `__eq__` not overridden when adding attributes
    A class that defines attributes that are not present in its superclasses may need to override the `__eq__()` method (`__ne__()` should also be defined).

    Adding additional attributes without overriding `__eq__()` means that the additional attributes will not be accounted for in equality tests.


    ## Recommendation
    Override the `__eq__` method.


    ## Example
    In the following example the `ColorPoint` class subclasses the `Point` class and adds a new attribute, but does not override the `__eq__` method.


    ```python
    class Point(object):

        def __init__(self, x, y):
            self._x = x
            self._y = y

        def __repr__(self):
            return 'Point(%r, %r)' % (self._x, self._y)

        def __eq__(self, other):
            if not isinstance(other, Point):
                return False
            return self._x == other._x and self._y == other._y

    class ColorPoint(Point):

        def __init__(self, x, y, color):
            Point.__init__(self, x, y)
            self._color = color

        def __repr__(self):
            return 'ColorPoint(%r, %r)' % (self._x, self._y, self._color)

    #ColorPoint(0, 0, Red) == ColorPoint(0, 0, Green) should be False, but is True.

    #Fixed version
    class ColorPoint(Point):

        def __init__(self, x, y, color):
            Point.__init__(self, x, y)
            self._color = color

        def __repr__(self):
            return 'ColorPoint(%r, %r)' % (self._x, self._y, self._color)

        def __eq__(self, other):
            if not isinstance(other, ColorPoint):
                return False
            return Point.__eq__(self, other) and self._color = other._color


    ```

    ## References
    * Peter Grogono, Philip Santas: [Equality in Object Oriented Languages](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.48.5109&rep=rep1&type=pdf)
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/InconsistentMRO.ql
  relativeBqrsPath: codeql/python-queries/Classes/InconsistentMRO.bqrs
  metadata:
    name: Inconsistent method resolution order
    description: Class definition will raise a type error at runtime due to inconsistent
      method resolution order(MRO)
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: high
    precision: very-high
    id: py/inconsistent-mro
  queryHelp: |
    # Inconsistent method resolution order
    Python 2.3 introduced new-style classes (classes inheriting from object). New-style classes use the C3 linearization method to determine a method resolution ordering (MRO) for each class. The C3 linearization method ensures that for a class C, if a class C1 precedes a class C2 in the MRO of C then C1 should also precede C2 in the MRO of all subclasses of C. It is possible to create a situation where it is impossible to achieve this consistency and this will guarantee that a ` TypeError` will be raised at runtime.


    ## Recommendation
    Use a class hierarchy that is not ambiguous.


    ## Example
    The MRO of class `X` is just `X, object`. The program will fail when the MRO of class `Y` needs to be calculated because `object` precedes `X` in the definition of `Y` but the opposite is true in the MRO of `X`.


    ```python
    class X(object):
        def __init__(self):
            print("X")
    class Y(object,X):
        def __init__(self):
            print("Y")
    ```

    ## References
    * Python: [The Python 2.3 Method Resolution Order](http://www.python.org/download/releases/2.3/mro/).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/InitCallsSubclass/InitCallsSubclassMethod.ql
  relativeBqrsPath: codeql/python-queries/Classes/InitCallsSubclass/InitCallsSubclassMethod.bqrs
  metadata:
    name: '`__init__` method calls overridden method'
    description: |-
      Calling a method from `__init__` that is overridden by a subclass may result in a partially
                    initialized instance being observed.
    kind: problem
    tags: |-
      reliability
             correctness
             quality
    problem.severity: warning
    sub-severity: low
    precision: high
    id: py/init-calls-subclass
  queryHelp: |
    # `__init__` method calls overridden method
    When initializing an instance of the class in the class' `__init__` method, calls tha are made using the instance may receive an instance of the class that is not yet fully initialized. When a method called in an initializer is overridden in a subclass, the subclass method receives the instance in a potentially unexpected state. Fields that would be initialized after the call, including potentially in the subclass' `__init__` method, will not be initialized. This may lead to runtime errors, as well as make the code more difficult to maintain, as future changes may not be aware of which fields would not be initialized.


    ## Recommendation
    If possible, refactor the initializer method such that initialization is complete before calling any overridden methods. For helper methods used as part of initialization, avoid overriding them, and instead call any additional logic required in the subclass' `__init__` method.

    If the overridden method does not depend on the instance `self`, and only on its class, consider making it a `@classmethod` or `@staticmethod` instead.

    If calling an overridden method is absolutely required, consider marking it as an internal method (by using an `_` prefix) to discourage external users of the library from overriding it and observing partially initialized state, and ensure that the fact it is called during initialization is mentioned in the documentation.


    ## Example
    In the following case, the `__init__` method of `Super` calls the `set_up` method that is overridden by `Sub`. This results in `Sub.set_up` being called with a partially initialized instance of `Super` which may be unexpected.


    ```python
    class Super(object):

        def __init__(self, arg):
            self._state = "Not OK"
            self.set_up(arg) # BAD: This method is overridden, so `Sub.set_up` receives a partially initialized instance.
            self._state = "OK"

        def set_up(self, arg):
            "Do some setup"
            self.a = 2

    class Sub(Super):

        def __init__(self, arg):
            super().__init__(arg)
            self.important_state = "OK"

        def set_up(self, arg):
            super().set_up(arg)
            "Do some more setup"
            # BAD: at this point `self._state` is set to `"Not OK"`, and `self.important_state` is not initialized.
            if self._state == "OK":
                self.b = self.a + 2

    ```
    In the following case, the initialization methods are separate between the superclass and the subclass.


    ```python
    class Super(object):

        def __init__(self, arg):
            self._state = "Not OK"
            self.super_set_up(arg) # GOOD: This isn't overriden. Instead, additional setup the subclass needs is called by the subclass' `__init__ method.`
            self._state = "OK"

        def super_set_up(self, arg):
            "Do some setup"
            self.a = 2


    class Sub(Super):

        def __init__(self, arg):
            super().__init__(arg)
            self.sub_set_up(self, arg)
            self.important_state = "OK"


        def sub_set_up(self, arg):
            "Do some more setup"
            if self._state == "OK":
                self.b = self.a + 2
    ```

    ## References
    * CERT Secure Coding: [ Rule MET05-J](https://www.securecoding.cert.org/confluence/display/java/MET05-J.+Ensure+that+constructors+do+not+call+overridable+methods). Reference discusses Java but is applicable to object oriented programming in many languages.
    * StackOverflow: [Overridable method calls in constructors](https://stackoverflow.com/questions/3404301/whats-wrong-with-overridable-method-calls-in-constructors).
    * Python documentation: [@classmethod](https://docs.python.org/3/library/functions.html#classmethod).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/MutatingDescriptor.ql
  relativeBqrsPath: codeql/python-queries/Classes/MutatingDescriptor.bqrs
  metadata:
    name: Mutation of descriptor in `__get__` or `__set__` method.
    description: Descriptor objects can be shared across many instances. Mutating
      them can cause strange side effects or race conditions.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/mutable-descriptor
  queryHelp: "# Mutation of descriptor in `__get__` or `__set__` method.\nThe descriptor\
    \ protocol allows user programmable attribute access. The descriptor protocol\
    \ is what enables class methods, static methods, properties and `super()`.\n\n\
    Descriptor objects are class attributes which control the behavior of instance\
    \ attributes. Consequently, a single descriptor is common to all instances of\
    \ a class and should not be mutated when instance attributes are accessed.\n\n\
    \n## Recommendation\nDo not mutate the descriptor object, rather create a new\
    \ object that contains the necessary state.\n\n\n## Example\nIn this example the\
    \ descriptor class `MutatingDescriptor` stores a reference to `obj` in an attribute.\n\
    \n\n```python\n\n#This is prone to strange side effects and race conditions.\n\
    class MutatingDescriptor(object):\n    \n    def __init__(self, func):\n     \
    \   self.my_func = func\n        \n    def __get__(self, obj, obj_type):\n   \
    \     #Modified state is visible to all instances of C that might call \"show\"\
    .\n        self.my_obj = obj\n        return self\n        \n    def __call__(self,\
    \ *args):\n        return self.my_func(self.my_obj, *args)\n    \ndef show(obj):\n\
    \    print (obj)\n    \nclass C(object):\n    \n    def __init__(self, value):\n\
    \        self.value = value\n        \n    def __str__(self):\n        return\
    \ (\"C: \" + str(self.value))\n    \n    show = MutatingDescriptor(show)\n   \
    \ \nc1 = C(1)\nc1.show()\nc2 = C(2)\nc2.show()\nc1_show = c1.show\nc2.show\nc1_show()\n\
    \n#Outputs:\n#C: 1\n#C: 2\n#C: 2\n```\nIn the following example, the descriptor\
    \ class `NonMutatingDescriptor` returns a new object every time `__get__` is called.\n\
    \n\n```python\nimport types\n\n#Immutable version, which is safe to share.\nclass\
    \ NonMutatingDescriptor(object):\n    \n    def __init__(self, func):\n      \
    \  self.my_func = func\n        \n    def __get__(self, obj, obj_type):\n    \
    \    #Return a new object to each access.\n        return types.MethodType(self.my_func,\
    \ obj)\n    \ndef show(obj):\n    print (obj)\n    \nclass C(object):\n    \n\
    \    def __init__(self, value):\n        self.value = value\n        \n    def\
    \ __str__(self):\n        return (\"C: \" + str(self.value))\n    \n    show =\
    \ NonMutatingDescriptor(show)\n    \nc1 = C(1)\nc1.show()\nc2 = C(2)\nc2.show()\n\
    c1_show = c1.show\nc2.show\nc1_show()\n\n#Outputs:\n#C: 1\n#C: 2\n#C: 1\n```\n\
    \n## References\n* Python Language Reference: [Implementing Descriptors.](https://docs.python.org/reference/datamodel.html#descriptors)\n\
    * Mark Lutz. *Learning Python*, Section 30.6: Methods Are Objects: Bound or Unbound.\
    \ O'Reilly 2013.\n* A real world example: [NumPy Issue 5247.](https://github.com/numpy/numpy/issues/5247)\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/OverwritingAttributeInSuperClass.ql
  relativeBqrsPath: codeql/python-queries/Classes/OverwritingAttributeInSuperClass.bqrs
  metadata:
    name: Overwriting attribute in super-class or sub-class
    description: Assignment to self attribute overwrites attribute previously defined
      in subclass or superclass `__init__` method.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: low
    precision: medium
    id: py/overwritten-inherited-attribute
  queryHelp: |
    # Overwriting attribute in super-class or sub-class
    Subclasses should not set attributes that are set in the superclass. Doing so may violate invariants in the superclass.


    ## Recommendation
    If you did not intend to override the attribute value set in the superclass, then rename the subclass attribute. If you do want to be able to set a new value for the attribute of the superclass, then convert the superclass attribute to a property. Otherwise the value should be passed as a parameter to the superclass `__init__` method.


    ## Example

    ```python

    #Attribute set in both superclass and subclass
    class C(object):

        def __init__(self):
            self.var = 0

    class D(C):

        def __init__(self):
            self.var = 1 # self.var will be overwritten
            C.__init__(self)

    class E(object):

        def __init__(self):
            self.var = 0 # self.var will be overwritten

    class F(E):

        def __init__(self):
            E.__init__(self)
            self.var = 1

    #Fixed version -- Pass explicitly as a parameter
    class G(object):

        def __init__(self, var = 0):
            self.var = var

    class H(G):

        def __init__(self):
            G.__init__(self, 1)


    ```
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/PropertyInOldStyleClass.ql
  relativeBqrsPath: codeql/python-queries/Classes/PropertyInOldStyleClass.bqrs
  metadata:
    name: Property in old-style class
    description: Using property descriptors in old-style classes does not work from
      Python 2.1 onward.
    kind: problem
    tags: |-
      portability
             correctness
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/property-in-old-style-class
  queryHelp: |
    # Property in old-style class
    Property descriptors are only supported for the new-style classes that were introduced in Python 2.1. Property descriptors should only be used in new-style classes.


    ## Recommendation
    If you want to define properties in a class, then ensure that the class is a new-style class. You can convert an old-style class to a new-style class by inheriting from `object`.


    ## Example
    In the following example all the classes attempt to set a property for `x`. However, only the third and fourth classes are new-style classes. Consequently, the `x` property is only available for the `NewStyle` and `InheritNewStyle` classes.

    If you define the `OldStyle` class as inheriting from a new-style class, then the `x ` property would be available for both the `OldStyle` and `InheritOldStyle` classes.


    ```python

    class OldStyle:

        def __init__(self, x):
            self._x = x

        # Incorrect: 'OldStyle' is not a new-style class and '@property' is not supported
        @property
        def x(self):
            return self._x


    class InheritOldStyle(OldStyle):

        def __init__(self, x):
            self._x = x

        # Incorrect: 'InheritOldStyle' is not a new-style class and '@property' is not supported
        @property
        def x(self):
            return self._x


    class NewStyle(object):

        def __init__(self, x):
            self._x = x

        # Correct: 'NewStyle' is a new-style class and '@property' is supported
        @property
        def x(self):
            return self._x

    class InheritNewStyle(NewStyle):

        def __init__(self, x):
            self._x = x

        # Correct: 'InheritNewStyle' inherits from a new-style class and '@property' is supported
        @property
        def x(self):
            return self._x

    ```

    ## References
    * Python Glossary: [New-style class](http://docs.python.org/glossary.html#term-new-style-class).
    * Python Language Reference: [New-style and classic classes](http://docs.python.org/2/reference/datamodel.html#newstyle), [ Descriptors](http://docs.python.org/2/reference/datamodel.html#implementing-descriptors).
    * Python Standard Library: [Property](http://docs.python.org/library/functions.html#property).
    * The History of Python: [ Inside story on new-style classes](http://python-history.blogspot.co.uk/2010/06/inside-story-on-new-style-classes.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/SlotsInOldStyleClass.ql
  relativeBqrsPath: codeql/python-queries/Classes/SlotsInOldStyleClass.bqrs
  metadata:
    name: '`__slots__` in old-style class'
    description: |-
      Overriding the class dictionary by declaring `__slots__` is not supported by old-style
                    classes.
    kind: problem
    problem.severity: error
    tags: |-
      portability
             correctness
    sub-severity: low
    precision: very-high
    id: py/slots-in-old-style-class
  queryHelp: |
    # `__slots__` in old-style class
    The ability to override the class dictionary using a `__slots__` declaration is supported only by new-style classes. When you add a `__slots__` declaration to an old-style class it just creates a class attribute called `__slots__`.


    ## Recommendation
    If you want to override the dictionary for a class, then ensure that the class is a new-style class. You can convert an old-style class to a new-style class by inheriting from `object`.


    ## Example
    In the following Python 2 example the `Point` class is an old-style class (no inheritance). The `__slots__` declaration in this class creates a class attribute called `__slots__`, the class dictionary is unaffected. The `Point2` class is a new-style class so the `__slots__` declaration causes special compact attributes to be created for each name in the slots list and saves space by not creating attribute dictionaries.


    ```python
    class Point:

        __slots__ = [ '_x', '_y' ] # Incorrect: 'Point' is an old-style class.
                                   # No slots are created.
                                   # Instances of Point have an attribute dictionary.

        def __init__(self, x, y):
            self._x = x
            self._y = y


    class Point2(object):

        __slots__ = [ '_x', '_y' ] # Correct: 'Point2' is an new-style class
                                   # Two slots '_x' and '_y' are created.
                                   # Instances of Point2 have no attribute dictionary.

        def __init__(self, x, y):
            self._x = x
            self._y = y

    ```

    ## References
    * Python Glossary: [New-style class](http://docs.python.org/glossary.html#term-new-style-class).
    * Python Language Reference: [New-style and classic classes](http://docs.python.org/2/reference/datamodel.html#newstyle), [__slots__](http://docs.python.org/reference/datamodel.html#__slots__).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/SubclassShadowing/SubclassShadowing.ql
  relativeBqrsPath: codeql/python-queries/Classes/SubclassShadowing/SubclassShadowing.bqrs
  metadata:
    name: Superclass attribute shadows subclass method
    description: |-
      Defining an attribute in a superclass method with a name that matches a subclass
                    method, hides the method in the subclass.
    kind: problem
    problem.severity: error
    tags: |-
      quality
             reliability
             correctness
    sub-severity: low
    precision: high
    id: py/attribute-shadows-method
  queryHelp: "# Superclass attribute shadows subclass method\nWhen an object has an\
    \ attribute that shares its name with a method on the object's class (or another\
    \ class attribute), the instance attribute is prioritized during attribute lookup,\
    \ shadowing the method. If a method on a subclass is shadowed by an attribute\
    \ on a superclass in this way, this may lead to unexpected results or errors,\
    \ as this shadowing behavior is nonlocal and may be unintended.\n\n\n## Recommendation\n\
    Ensure method names on subclasses don't conflict with attribute names on superclasses,\
    \ and rename one. If the shadowing behavior is intended, ensure this is explicit\
    \ in the superclass.\n\n\n## Example\nIn the following example, the `_foo` attribute\
    \ of class `A` shadows the method `_foo` of class `B`. Calls to `B()._foo()` will\
    \ result in a `TypeError`, as `3` will be called instead.\n\n\n```python\nclass\
    \ A:\n    def __init__(self):\n        self._foo = 3\n\nclass B(A):\n    # BAD:\
    \ _foo is shadowed by attribute A._foo\n    def _foo(self):\n        return 2\n\
    \n\n```\nIn the following example, the behavior of the `default` attribute being\
    \ shadowed to allow for customization during initialization is intended in within\
    \ the superclass `A`. Overriding `default` in the subclass `B` is then OK.\n\n\
    \n```python\nclass A:\n    def __init__(self, default_func=None):\n        if\
    \ default_func is not None:\n            self.default = default_func \n\n    #\
    \ GOOD: The shadowing behavior is explicitly intended in the superclass.\n   \
    \ def default(self):\n        return []\n    \nclass B(A):\n    \n    # Subclasses\
    \ may override the method `default`, which will still be shadowed by the attribute\
    \ `default` if it is set.\n    # As this is part of the expected behavior of the\
    \ superclass, this is fine. \n    def default(self):\n        return {}\n```\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/SuperInOldStyleClass.ql
  relativeBqrsPath: codeql/python-queries/Classes/SuperInOldStyleClass.bqrs
  metadata:
    name: '''super'' in old style class'
    description: Using super() to access inherited methods is not supported by old-style
      classes.
    kind: problem
    tags: |-
      portability
             correctness
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/super-in-old-style
  queryHelp: |
    # 'super' in old style class
    The ability to access inherited methods that have been overridden in a class using `super()` is supported only by new-style classes. When you use the `super()` function in an old-style class it fails.


    ## Recommendation
    If you want to access inherited methods using the `super()` built-in, then ensure that the class is a new-style class. You can convert an old-style class to a new-style class by inheriting from `object`. Alternatively, you can call the `__init__` method of the superclass directly from an old-style class using: `BaseClass.__init__(...)`.


    ## Example
    In the following example, `PythonModule` is an old-style class as it inherits from another old-style class. If the `_ModuleIteratorHelper` class cannot be converted into a new-style class, then the call to `super()` must be replaced. The `PythonModule2` class demonstrates the correct way to call a superclass from an old-style class.


    ```python
    class PythonModule(_ModuleIteratorHelper): # '_ModuleIteratorHelper' and 'PythonModule' are old-style classes

        # class definitions ....

        def walkModules(self, importPackages=False):
            if importPackages and self.isPackage():
                self.load()
            return super(PythonModule, self).walkModules(importPackages=importPackages) # super() will fail


    class PythonModule2(_ModuleIteratorHelper): # call to super replaced with direct call to class

        # class definitions ....

        def walkModules(self, importPackages=False):
            if importPackages and self.isPackage():
                self.load()
            return _ModuleIteratorHelper.__init__(PythonModule, self).walkModules(importPackages=importPackages)

    ```

    ## References
    * Python Glossary: [New-style class](http://docs.python.org/glossary.html#term-new-style-class).
    * Python Language Reference: [New-style and classic classes](http://docs.python.org/2/reference/datamodel.html#newstyle).
    * Python Standard Library: [super](http://docs.python.org/library/functions.html#super).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/WrongNameForArgumentInClassInstantiation.ql
  relativeBqrsPath: codeql/python-queries/Classes/WrongNameForArgumentInClassInstantiation.bqrs
  metadata:
    name: Wrong name for an argument in a class instantiation
    description: |-
      Using a named argument whose name does not correspond to a
                    parameter of the __init__ method of the class being
                    instantiated, will result in a TypeError at runtime.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-628
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/call/wrong-named-class-argument
  queryHelp: |
    # Wrong name for an argument in a class instantiation
    Using a named argument whose name does not correspond to a parameter of the `__init__` method of the class being instantiated, will result in a `TypeError` at runtime.


    ## Recommendation
    Check for typos in the name of the arguments and fix those. If the name is clearly different, then this suggests a logical error. The change required to correct the error will depend on whether the wrong argument has been specified or whether the wrong class has been specified.


    ## Example

    ```python
    class Point(object):
        def __init__(self, x, y):
            self.x = x
            self.y = y

    p = Point(x=1, yy=2) # TypeError: 'yy' is not a valid keyword argument

    ```

    ## References
    * Python Glossary: [Arguments](https://docs.python.org/2/glossary.html#term-argument).
    * Python Glossary: [Parameters](https://docs.python.org/glossary.html#term-parameter).
    * Python Programming FAQ: [ What is the difference between arguments and parameters?](https://docs.python.org/2/faq/programming.html#faq-argument-vs-parameter).
    * The Python Language Reference: [Data model: object.__init__](https://docs.python.org/3/reference/datamodel.html#object.__init__)
    * The Python Tutorial: [Classes](https://docs.python.org/3/tutorial/classes.html)
    * Common Weakness Enumeration: [CWE-628](https://cwe.mitre.org/data/definitions/628.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Classes/WrongNumberArgumentsInClassInstantiation.ql
  relativeBqrsPath: codeql/python-queries/Classes/WrongNumberArgumentsInClassInstantiation.bqrs
  metadata:
    name: Wrong number of arguments in a class instantiation
    description: |-
      Using too many or too few arguments in a call to the `__init__`
                    method of a class will result in a TypeError at runtime.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-685
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/call/wrong-number-class-arguments
  queryHelp: |
    # Wrong number of arguments in a class instantiation
    A call to the `__init__` method of a class must supply an argument for each parameter that does not have a default value defined, so:

    * The minimum number of arguments is the number of parameters without default values.
    * The maximum number of arguments is the total number of parameters, unless the class `__init__` method takes a varargs (starred) parameter in which case there is no limit.

    ## Recommendation
    If there are too few arguments then check to see which arguments have been omitted and supply values for those.

    If there are too many arguments then check to see if any have been added by mistake and remove those.

    Also check where a comma has been inserted instead of an operator or a dot. For example, the code is `obj,attr` when it should be `obj.attr`.

    If it is not clear which are the missing or surplus arguments, then this suggests a logical error. The fix will then depend on the nature of the error.


    ## Example

    ```python
    class Point(object):
        def __init__(self, x, y):
            self.x = x
            self.y = y

    p = Point(1)      # TypeError: too few arguments
    p = Point(1,2,3)  # TypeError: too many arguments

    ```

    ## References
    * Python Glossary: [Arguments](https://docs.python.org/2/glossary.html#term-argument).
    * Python Glossary: [Parameters](https://docs.python.org/glossary.html#term-parameter).
    * Python Programming FAQ: [ What is the difference between arguments and parameters?](https://docs.python.org/2/faq/programming.html#faq-argument-vs-parameter).
    * The Python Language Reference: [Data model: object.__init__](https://docs.python.org/3/reference/datamodel.html#object.__init__)
    * The Python Tutorial: [Classes](https://docs.python.org/3/tutorial/classes.html)
    * Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Diagnostics/ExtractedFiles.ql
  relativeBqrsPath: codeql/python-queries/Diagnostics/ExtractedFiles.bqrs
  metadata:
    name: Extracted Python files
    description: Lists all Python files in the source code directory that were extracted.
    kind: diagnostic
    id: py/diagnostics/successfully-extracted-files
    tags: successfully-extracted-files
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Diagnostics/ExtractionWarnings.ql
  relativeBqrsPath: codeql/python-queries/Diagnostics/ExtractionWarnings.bqrs
  metadata:
    name: Python extraction warnings
    description: List all extraction warnings for Python files in the source code
      directory.
    kind: diagnostic
    id: py/diagnostics/extraction-warnings
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Exceptions/CatchingBaseException.ql
  relativeBqrsPath: codeql/python-queries/Exceptions/CatchingBaseException.bqrs
  metadata:
    name: Except block handles 'BaseException'
    description: Handling 'BaseException' means that system exits and keyboard interrupts
      may be mis-handled.
    kind: problem
    tags: |-
      quality
             reliability
             error-handling
             external/cwe/cwe-396
    problem.severity: recommendation
    sub-severity: high
    precision: very-high
    id: py/catch-base-exception
  queryHelp: |
    # Except block handles 'BaseException'
    All exception classes in Python derive from `BaseException`. `BaseException` has three important subclasses, `Exception` from which all errors and normal exceptions derive, `KeyboardInterrupt` which is raised when the user interrupts the program from the keyboard and `SystemExit` which is raised by the `sys.exit()` function to terminate the program.

    Since `KeyboardInterrupt` and `SystemExit` are special they should not be grouped together with other `Exception` classes.

    Catching `BaseException`, rather than its subclasses may prevent proper handling of `KeyboardInterrupt` or `SystemExit`. It is easy to catch `BaseException` accidentally as it is caught implicitly by an empty `except:` statement.


    ## Recommendation
    Handle `Exception`, `KeyboardInterrupt` and `SystemExit` separately. Do not use the plain `except:` form.


    ## Example
    In these examples, a function `application.main()` is called that might raise `SystemExit`. In the first two functions, `BaseException` is caught, but this will discard `KeyboardInterrupt`. In the third function, `call_main_program_fixed` only `SystemExit` is caught, leaving `KeyboardInterrupt` to propagate.

    In these examples `KeyboardInterrupt` is accidentally ignored.


    ```python

    def call_main_program_implicit_handle_base_exception():
        try:
            #application.main calls sys.exit() when done.
            application.main()
        except Exception as ex:
            log(ex)
        except:
            pass

    def call_main_program_explicit_handle_base_exception():
        try:
            #application.main calls sys.exit() when done.
            application.main()
        except Exception as ex:
            log(ex)
        except BaseException:
            pass

    def call_main_program_fixed():
        try:
            #application.main calls sys.exit() when done.
            application.main()
        except Exception as ex:
            log(ex)
        except SystemExit:
            pass

    ```

    ## References
    * Python Language Reference: [The try statement](http://docs.python.org/3/reference/compound_stmts.html#try), [Exceptions](http://docs.python.org/3/reference/executionmodel.html#exceptions).
    * M. Lutz, Learning Python, Section 35.3: Exception Design Tips and Gotchas, O'Reilly Media, 2013.
    * Python Tutorial: [Errors and Exceptions](https://docs.python.org/3/tutorial/errors.html).
    * Common Weakness Enumeration: [CWE-396](https://cwe.mitre.org/data/definitions/396.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Exceptions/EmptyExcept.ql
  relativeBqrsPath: codeql/python-queries/Exceptions/EmptyExcept.bqrs
  metadata:
    name: Empty except
    description: Except doesn't do anything and has no comment
    kind: problem
    tags: |-
      quality
             reliability
             error-handling
             external/cwe/cwe-390
    problem.severity: recommendation
    sub-severity: high
    precision: high
    id: py/empty-except
  queryHelp: |
    # Empty except
    Ignoring exceptions that should be dealt with in some way is almost always a bad idea. The loss of information can lead to hard to debug errors and incomplete log files. It is even possible that ignoring an exception can cause a security vulnerability. An empty `except` block may be an indication that the programmer intended to handle the exception, but never wrote the code to do so.


    ## Recommendation
    Ensure all exceptions are handled correctly.


    ## Example
    In this example, the program keeps running with the same privileges if it fails to drop to lower privileges.


    ```python
    # ...
    try:
        security_manager.drop_privileges()
    except SecurityError:
        pass
    # ...
    ```

    ## References
    * Common Weakness Enumeration: [CWE-390](https://cwe.mitre.org/data/definitions/390.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Exceptions/IllegalExceptionHandlerType.ql
  relativeBqrsPath: codeql/python-queries/Exceptions/IllegalExceptionHandlerType.bqrs
  metadata:
    name: Non-exception in 'except' clause
    description: An exception handler specifying a non-exception type will never handle
      any exception.
    kind: problem
    tags: |-
      quality
             reliability
             error-handling
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/useless-except
  queryHelp: |
    # Non-exception in 'except' clause
    If the class specified in an `except` handler (within a `try` statement) is not a legal exception class, then it will never match a raised exception and never be executed

    Legal exception classes are:

    * Any old-style classes (Python 2 only)
    * Any subclass of the builtin class `BaseException`
    However, it recommended that you only use subclasses of the builtin class `Exception` (which is itself a subclass of `BaseException`).


    ## Recommendation
    Ensure that the specified class is the one intended. If it is not then replace it with the correct one. Otherwise the entire `except` block can be deleted.


    ## Example

    ```python
    def handle_int():
        try:
            raise_int()
        #This will not cause an exception, but it will be ignored
        except int:
            print("This will never be printed")


    ```

    ## References
    * Python Language Reference: [Exceptions](https://docs.python.org/reference/executionmodel.html#exceptions).
    * Python Tutorial: [Handling Exceptions](https://docs.python.org/tutorial/errors.html#handling-exceptions).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Exceptions/IllegalRaise.ql
  relativeBqrsPath: codeql/python-queries/Exceptions/IllegalRaise.bqrs
  metadata:
    name: Illegal raise
    description: Raising a non-exception object or type will result in a TypeError
      being raised instead.
    kind: problem
    tags: |-
      quality
             reliability
             error-handling
    problem.severity: error
    sub-severity: high
    precision: very-high
    id: py/illegal-raise
  queryHelp: |
    # Illegal raise
    If the object raised is not a legal Exception class or an instance of one, then a `TypeError` will be raised instead.

    Legal exception classes are:

    * Any old-style classes (Python 2 only)
    * Any subclass of the builtin class `BaseException`
    However, it recommended that you only use subclasses of the builtin class `Exception` (which is itself a subclass of `BaseException`).


    ## Recommendation
    Change the expression in the `raise` statement to be a legal exception.


    ## Example

    ```python
    #Cannot raise an int, even if we want to
    def raise_int():
        #Will raise a TypeError
        raise 4


    ```

    ## References
    * Python Language Reference: [Exceptions](https://docs.python.org/reference/executionmodel.html#exceptions).
    * Python Tutorial: [Handling Exceptions](https://docs.python.org/tutorial/errors.html#handling-exceptions).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Exceptions/IncorrectExceptOrder.ql
  relativeBqrsPath: codeql/python-queries/Exceptions/IncorrectExceptOrder.bqrs
  metadata:
    name: Unreachable `except` block
    description: |-
      Handling general exceptions before specific exceptions means that the specific
                    handlers are never executed.
    kind: problem
    tags: |-
      quality
             reliability
             error-handling
             external/cwe/cwe-561
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/unreachable-except
  queryHelp: "# Unreachable `except` block\nWhen handling an exception, Python searches\
    \ the except blocks in source code order until it finds a matching `except` block\
    \ for the exception. An except block, `except E:`, specifies a class `E` and will\
    \ match any exception that is an instance of `E`.\n\nIf a more general except\
    \ block precedes a more specific except block, then the more general block is\
    \ always executed and the more specific block is never executed. An except block,\
    \ `except A:`, is more general than another except block, `except B:`, if `A`\
    \ is a super class of `B`.\n\nFor example: `except Exception:` is more general\
    \ than `except Error:` as `Exception` is a super class of `Error`.\n\n\n## Recommendation\n\
    Reorganize the `except` blocks so that the more specific `except` is defined first.\
    \ Alternatively, if the more specific `except` block is no longer required, then\
    \ it should be deleted.\n\n\n## Example\nIn the following example, the `except\
    \ Exception:` will handle `AttributeError` preventing the subsequent handler from\
    \ ever executing.\n\n\n```python\n\n\ndef incorrect_except_order(val):\n    try:\n\
    \        val.attr\n    except Exception:\n        print (\"Exception\")\n    except\
    \ AttributeError:\n        print (\"AttributeError\")\n        \n\n```\n\n## References\n\
    * Python Language Reference: [The try statement](http://docs.python.org/3/reference/compound_stmts.html#try),\
    \ [Exceptions](http://docs.python.org/3/reference/executionmodel.html#exceptions).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Exceptions/NotImplementedIsNotAnException.ql
  relativeBqrsPath: codeql/python-queries/Exceptions/NotImplementedIsNotAnException.bqrs
  metadata:
    name: Raising `NotImplemented`
    description: Using `NotImplemented` as an exception will result in a type error.
    kind: problem
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/raise-not-implemented
    tags: |-
      quality
             reliability
             error-handling
  queryHelp: |
    # Raising `NotImplemented`
    The constant `NotImplemented` is not an `Exception`, but is often confused for `NotImplementedError`. If it is used as an exception, such as in `raise NotImplemented` or `raise NotImplemented("message")`, a `TypeError` will be raised rather than the expected `NotImplemented`. This may make debugging more difficult.

    `NotImplemented` should only be used as a special return value for implementing special methods such as `__lt__`. Code that is not intended to be called should raise `NotImplementedError`.


    ## Recommendation
    If a `NotImplementedError` is intended to be raised, replace the use of `NotImplemented` with that. If `NotImplemented` is intended to be returned rather than raised, replace the `raise` with `return NotImplemented`.


    ## Example
    In the following example, the method `wrong` will incorrectly raise a `TypeError` when called. The method `right` will raise a `NotImplementedError`.


    ```python

    class Abstract(object):

        def wrong(self):
            # Will raise a TypeError
            raise NotImplemented()

        def right(self):
            raise NotImplementedError()

    ```

    ## References
    * Python Language Reference: [The NotImplementedError exception](https://docs.python.org/library/exceptions.html#NotImplementedError).
    * Python Language Reference: [The NotImplemented constant](https://docs.python.org/3/library/constants.html#NotImplemented).
    * Python Language Reference: [Emulating numeric types](https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Exceptions/RaisingTuple.ql
  relativeBqrsPath: codeql/python-queries/Exceptions/RaisingTuple.bqrs
  metadata:
    name: Raising a tuple
    description: Raising a tuple will result in all but the first element being discarded
    kind: problem
    tags: maintainability
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/raises-tuple
  queryHelp: |
    # Raising a tuple
    In Python 2, if a tuple is raised then all elements but the first are ignored and only the first part is raised. If the first element is itself a tuple, then the first element of that is used and so on. This unlikely to be the intended effect and will most likely indicate some sort of error.

    It is important to note that the exception in `raise Exception, message` is *not* a tuple, whereas the exception in `ex = Exception, message; raise ex` *is* a tuple.

    In Python 3, raising a tuple is an error.


    ## Recommendation
    Given that all but the first element of the tuple is ignored, the tuple should be replaced with its first element in order to improve the clarity of the code. If the subsequent parts of the tuple were intended to form the message, then they should be passed as an argument when creating the exception.


    ## Example
    In the following example the intended error message is mistakenly used to form a tuple.


    ```python


    def raise_tuple():
        ex = Exception, "Important diagnostic information"
        raise ex

    ```
    This can be fixed, either by using the message to create the exception or using the message in the raise statement, as shown below.


    ```python


    def fixed_raise_tuple1():
        ex = Exception("Important diagnostic information")
        raise ex


    def fixed_raise_tuple2():
        raise Exception, "Important diagnostic information"

    ```

    ## References
    * Python Language Reference: [Exceptions](https://docs.python.org/reference/executionmodel.html#exceptions).
    * Python Tutorial: [Handling Exceptions](https://docs.python.org/tutorial/errors.html#handling-exceptions).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Exceptions/UnguardedNextInGenerator.ql
  relativeBqrsPath: codeql/python-queries/Exceptions/UnguardedNextInGenerator.bqrs
  metadata:
    name: Unguarded next in generator
    description: Calling next() in a generator may cause unintended early termination
      of an iteration.
    kind: problem
    tags: |-
      maintainability
             portability
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/unguarded-next-in-generator
  queryHelp: |
    # Unguarded next in generator
    The function `next()` will raise a `StopIteration` exception if the underlying iterator is exhausted. Normally this is fine, but in a generator may cause problems. Since the `StopIteration` is an exception it will be propagated out of the generator causing termination of the generator. This is unlikely to be the expected behavior and may mask errors.

    This problem is considered sufficiently serious that [PEP 479](https://www.python.org/dev/peps/pep-0479) has been accepted to modify the handling of `StopIteration` in generators. Consequently, code that does not handle `StopIteration` properly is likely to fail in future versions of Python.


    ## Recommendation
    Each call to `next()` should be wrapped in a `try-except` to explicitly handle `StopIteration` exceptions.


    ## Example
    In the following example, an empty file part way through iteration will silently truncate the output as the `StopIteration` exception propagates to the top level.


    ```python

    test_files = [
        ["header1", "text10", "text11", "text12"],
        ["header2", "text20", "text21", "text22"],
        [],
        ["header4", "text40", "text41", "text42"],
    ]

    def separate_headers(files):
        for file in files:
            lines = iter(file)
            header = next(lines) # Will raise StopIteration if lines is exhausted
            body = [ l for l in lines ]
            yield header, body

    def process_files(files):
        for header, body in separate_headers(files):
            print(format_page(header, body))


    ```
    In the following example `StopIteration` exception is explicitly handled, allowing all the files to be processed.


    ```python

    def separate_headers(files):
        for file in files:
            lines = iter(file)
            try:
                header = next(lines) # Will raise StopIteration if lines is exhausted
            except StopIteration:
                #Empty file -- Just ignore
                continue
            body = [ l for l in lines ]
            yield header, body

    ```

    ## References
    * Python PEP index: [PEP 479](https://www.python.org/dev/peps/pep-0479).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/CallToSuperWrongClass.ql
  relativeBqrsPath: codeql/python-queries/Expressions/CallToSuperWrongClass.bqrs
  metadata:
    name: First argument to super() is not enclosing class
    description: Calling super with something other than the enclosing class may cause
      incorrect object initialization.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-687
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/super-not-enclosing-class
  queryHelp: "# First argument to super() is not enclosing class\nThe `super` class\
    \ should be called with the enclosing class as its first argument and `self` as\
    \ its second argument.\n\nPassing a different class may work correctly, provided\
    \ the class passed is a super class of the enclosing class and the enclosing class\
    \ does not define an `__init__` method. However, this may result in incorrect\
    \ object initialization if the enclosing class is later subclassed using multiple\
    \ inheritance.\n\n\n## Recommendation\nEnsure that the first argument to `super()`\
    \ is the enclosing class.\n\n\n## Example\nIn this example, the call to `super(Vehicle,\
    \ self)` in `Car.__init__` is incorrect, as it passes `Vehicle` rather than `Car`\
    \ as the first argument to `super`. As a result, `super(SportsCar, self).__init__()`\
    \ in the `SportsCar.__init__` method will not call all `__init__()` methods because\
    \ the call to `super(Vehicle, self).__init__()` skips `StatusSymbol.__init__()`.\n\
    \n\n```python\n\n\nclass Vehicle(object):\n    pass\n        \nclass Car(Vehicle):\n\
    \    \n    def __init__(self):\n        #This is OK provided that Car is not subclassed.\n\
    \        super(Vehicle, self).__init__()\n        self.car_init()\n        \n\
    class StatusSymbol(object):\n    \n    def __init__(self):\n        super(StatusSymbol,\
    \ self).__init__()\n        self.show_off()\n        \nclass SportsCar(Car, StatusSymbol):\n\
    \    \n    def __init__(self):\n        #This will not call StatusSymbol.__init__()\n\
    \        super(SportsCar, self).__init__()\n        self.sports_car_init()\n\n\
    \        \n#Fix Car by passing Car to super().\n#SportsCar does not need to be\
    \ changed.\nclass Car(Car, Vehicle):\n    \n    def __init__(self):\n        super(Car,\
    \ self).__init__()\n        self.car_init()\n        \n\n```\n\n## References\n\
    * Python Standard Library: [super](https://docs.python.org/3/library/functions.html#super).\n\
    * Artima Developer: [Things to Know About Python Super](http://www.artima.com/weblogs/viewpost.jsp?thread=236275).\n\
    * Common Weakness Enumeration: [CWE-687](https://cwe.mitre.org/data/definitions/687.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/CompareConstants.ql
  relativeBqrsPath: codeql/python-queries/Expressions/CompareConstants.bqrs
  metadata:
    name: Comparison of constants
    description: "Comparison of constants is always constant, but is harder to read\
      \ than a simple constant."
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
             external/cwe/cwe-570
             external/cwe/cwe-571
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/comparison-of-constants
  queryHelp: |
    # Comparison of constants
    When two constants are compared it is typically an indication of a mistake, since the Boolean value of the comparison will always be the same. In very old code this may be used to initialize `True` and `False`.


    ## Recommendation
    It is never good practice to compare a value with itself. If the constant behavior is indeed required, use the Boolean literals `True` or `False`, rather than encoding them obscurely as `1 == 1` or similar. If there is a mistake, ascertain the desired behavior and correct it.


    ## Example
    In this example, old code uses `1==1` to initialize `__builtins__.True`. This code has been unnecessary on all versions of Python released since 2003 and can be deleted.


    ```python

    #Interoperate with very old versions of Python (pre 2.3)
    try:
        True
    except NameError:
        __builtins__.True = 1==1

    ```

    ## References
    * Python Language Reference: [Comparisons](http://docs.python.org/2/reference/expressions.html#not-in).
    * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).
    * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/CompareIdenticalValues.ql
  relativeBqrsPath: codeql/python-queries/Expressions/CompareIdenticalValues.bqrs
  metadata:
    name: Comparison of identical values
    description: "Comparison of identical values, the intent of which is unclear."
    kind: problem
    tags: |-
      quality
             maintainability
             readability
             external/cwe/cwe-570
             external/cwe/cwe-571
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/comparison-of-identical-expressions
  queryHelp: |
    # Comparison of identical values
    When two identical expressions are compared it is typically an indication of a mistake, since the Boolean value of the comparison will always be the same, unless the value is the floating point value `float('nan')`.


    ## Recommendation
    It is not good practice to compare a value with itself, as it makes the code hard to read and can hide errors with classes that do not correctly implement equality. If testing whether a floating-point value is not-a-number, then use `math.isnan()`. If the value may be a complex number, then use `cmath.isnan()` instead.


    ## Example
    In this example `f == f` is used to check for `float('nan')`. This makes the code difficult to understand as the reader may not be immediately familiar with this pattern.


    ```python

    #Using 'x == x' to check that 'x' is not a float('nan').
    def is_normal(f):
        return not cmath.isinf(f) and f == f

    #Improved version; intention is explicit.
    def is_normal(f):
        return not cmath.isinf(f) and not cmath.isnan(f)
    ```

    ## References
    * Python Language Reference: [Comparisons](http://docs.python.org/2/reference/expressions.html#not-in).
    * Python Library Reference: [math.isnan()](https://docs.python.org/2/library/math.html#math.isnan).
    * Python Library Reference: [cmath.isnan()](https://docs.python.org/2/library/cmath.html#cmath.isnan).
    * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).
    * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/CompareIdenticalValuesMissingSelf.ql
  relativeBqrsPath: codeql/python-queries/Expressions/CompareIdenticalValuesMissingSelf.bqrs
  metadata:
    name: Maybe missing 'self' in comparison
    description: "Comparison of identical values, the intent of which is unclear."
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-570
             external/cwe/cwe-571
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/comparison-missing-self
  queryHelp: |
    # Maybe missing 'self' in comparison
    When two identical expressions are compared it is typically an indication of a mistake, since the Boolean value of the comparison will always be the same. Often, it can indicate that `self` has been omitted.


    ## Recommendation
    It is never good practice to compare a value with itself. If `self` has been omitted, then insert it. If the constant behavior is indeed required, use the Boolean literals `True` or `False`, rather than encoding them obscurely as `x == x` or similar.


    ## Example

    ```python

    class Customer:

        def __init__(self, data):
            self.data = data

        def check_data(self, data):
            if data != data:  # Forgotten 'self'
                raise Exception("Invalid data!")

    #Fixed version

    class Customer:

        def __init__(self, data):
            self.data = data

        def check_data(self, data):
            if self.data != data:
                raise Exception("Invalid data!")

    ```

    ## References
    * Python Language Reference: [Comparisons](http://docs.python.org/2/reference/expressions.html#not-in).
    * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).
    * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/Comparisons/UselessComparisonTest.ql
  relativeBqrsPath: codeql/python-queries/Expressions/Comparisons/UselessComparisonTest.bqrs
  metadata:
    name: Redundant comparison
    description: The result of a comparison is implied by a previous comparison.
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
             external/cwe/cwe-561
             external/cwe/cwe-570
             external/cwe/cwe-571
    problem.severity: warning
    sub-severity: high
    precision: high
    id: py/redundant-comparison
  queryHelp: |
    # Redundant comparison
    The result of certain comparisons can sometimes be inferred from their context and the results of other comparisons. This can be an indication of faulty logic and may result in dead code or infinite loops if, for example, a loop condition never changes its value.


    ## Recommendation
    Inspect the code to check whether the logic is correct, and consider simplifying the logical expression.


    ## Example
    In the following (real world) example the test `obj1 < obj2` is repeated and thus the second test will always be false, and the function `_compare` will only ever return `0` or `-1`.


    ```python
      class KeySorter:

          def __init__(self, obj):
              self.obj = obj

          def __lt__(self, other):
              return self._compare(self.obj, other.obj) < 0

          def _compare(self, obj1, obj2):
              if obj1 < obj2:
                  return -1
              elif obj1 < obj2:
                  return 1
              else:
                  return 0

    ```

    ## References
    * Python Language Reference: [Comparisons](http://docs.python.org/2/reference/expressions.html#not-in).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
    * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).
    * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/ContainsNonContainer.ql
  relativeBqrsPath: codeql/python-queries/Expressions/ContainsNonContainer.bqrs
  metadata:
    name: Membership test with a non-container
    description: "A membership test, such as 'item in sequence', with a non-container\
      \ on the right hand side will raise a 'TypeError'."
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: high
    precision: high
    id: py/member-test-non-container
  queryHelp: |
    # Membership test with a non-container
    A membership test, that is a binary expression with `in` or `not in` as the operator, expects that the expression to the right of the operator will be a container.

    As well as standard containers such as `list`, `tuple`, `dict` or `set`, a container can be an instance of any class that has the `__contains__`, `__iter__` or `__getitem__` method.


    ## Recommendation
    Ensure that the right hand side of the expression is a container, or add a guard clause for other cases. For example, if the right side may be a container or `None` then change `if x in seq:` to `if seq is not None and x in seq:`


    ## Example
    In this example the `NotAContainer` class has no `__contains__`, `__iter__` or `__getitem__` method. Consequently, when the line `if 2 in cont:` is executed a TypeError will be raised. Adding a `__getitem__` method to the `NotAContainer` class would solve the problem.


    ```python
    class NotAContainer(object):

        def __init__(self, *items):
            self.items = items

    def main():
        cont = NotAContainer(1, 2, 3)
        if 2 in cont:
            print("2 in container")

    ```

    ## References
    * Python: [Membership test details](http://docs.python.org/reference/expressions.html#membership-test-details).
    * Python: [The __contains__ method](http://docs.python.org/reference/datamodel.html#object.__contains__).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/DuplicateKeyInDictionaryLiteral.ql
  relativeBqrsPath: codeql/python-queries/Expressions/DuplicateKeyInDictionaryLiteral.bqrs
  metadata:
    name: Duplicate key in dict literal
    description: Duplicate key in dict literal. All but the last will be lost.
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
             external/cwe/cwe-561
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/duplicate-key-dict-literal
  queryHelp: |
    # Duplicate key in dict literal
    Dictionary literals are constructed in the order given in the source. This means that if a key is duplicated, the second key-value pair will overwrite the first; as a dictionary can only have one value per key.


    ## Recommendation
    Check for typos to ensure that the keys are supposed to be the same. If they are then decide which value is wanted and delete the other one.


    ## Example
    The following example will output `"c"`, because the mapping between 2 and `"b"` is overwritten by the mapping from 2 to `"c"`. The programmer may have meant to map 3 to `"c"` instead.


    ```python
    dictionary = {1:"a", 2:"b", 2:"c"} # BAD: The `2` key is duplicated.
    print(dictionary[2])
    ```

    ## References
    * Python: [Dictionary literals](http://docs.python.org/3/reference/expressions.html#dictionary-displays).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/EqualsNone.ql
  relativeBqrsPath: codeql/python-queries/Expressions/EqualsNone.bqrs
  metadata:
    name: Testing equality to None
    description: Testing whether an object is 'None' using the == operator is inefficient
      and potentially incorrect.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             performance
    problem.severity: recommendation
    sub-severity: high
    precision: very-high
    id: py/test-equals-none
  queryHelp: |
    # Testing equality to None
    When you compare an object to `None`, use `is` rather than `==`. `None` is a singleton object, comparing using `==` invokes the `__eq__` method on the object in question, which may be slower than identity comparison. Comparing to `None` using the `is` operator is also easier for other programmers to read.


    ## Recommendation
    Replace `==` with `is`.


    ## Example
    The `filter2` function is likely to be more efficient than the `filter1` function because it uses an identity comparison.


    ```python

    def filter1(function, iterable=None)
        if iterable == None:    # Comparison using '__eq__'
            return [item for item in iterable if item]
        else:
            return [item for item in iterable if function(item)]

    def filter2(function, iterable=None)
        if iterable is None:    # Comparison using identity
            return [item for item in iterable if item]
        else:
            return [item for item in iterable if function(item)]

    ```

    ## References
    * Python Language Reference: [Comparisons](http://docs.python.org/reference/expressions.html#is), [object.__eq__](http://docs.python.org/reference/datamodel.html#object.__eq__).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/ExpectedMappingForFormatString.ql
  relativeBqrsPath: codeql/python-queries/Expressions/ExpectedMappingForFormatString.bqrs
  metadata:
    name: Formatted object is not a mapping
    description: The formatted object must be a mapping when the format includes a
      named specifier; otherwise a TypeError will be raised."
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/percent-format/not-mapping
  queryHelp: |
    # Formatted object is not a mapping
    If a format string includes conversion specifiers of the form `%(name)s` then the right hand side of the operation must be a mapping. A string is a format string if it appears on the left of a modulo (`%`) operator, the right hand side being the value to be formatted. If the right hand side is not a mapping then a `TypeError` will be raised. Mappings are usually `dict`s but can be any type that implements the mapping protocol.


    ## Recommendation
    Change the format to match the arguments and ensure that the right hand side is always a mapping.


    ## Example
    In the following example the right hand side of the formatting operation can be a `tuple`, which is not a mapping. To fix this example, ensure that `args` is a mapping when `unlike_condition` occurs.


    ```python

    def unsafe_format():
        if unlikely_condition():
            args = (1,2,3)
        else:
            args = {a:1,b:2,c:3}
        return "%(a)s %(b)s %(c)s" % args
    ```

    ## References
    * Python Library Reference: [String Formatting.](http://docs.python.org/library/stdtypes.html#string-formatting)
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/ExplicitCallToDel.ql
  relativeBqrsPath: codeql/python-queries/Expressions/ExplicitCallToDel.bqrs
  metadata:
    name: '`__del__` is called explicitly'
    description: The `__del__` special method is called by the virtual machine when
      an object is being finalized. It should not be called explicitly.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/explicit-call-to-delete
  queryHelp: |
    # `__del__` is called explicitly
    The `__del__` special method is designed to be called by the Python virtual machine when an object is no longer reachable, but before it is destroyed. Calling a `__del__` method explicitly may cause an object to enter an unsafe state.


    ## Recommendation
    If explicit clean up of an object is required, a `close()` method should be called or, better still, wrap the use of the object in a `with` statement.


    ## Example
    In the first example, rather than close the zip file in a conventional manner, the programmer has called `__del__`. A safer alternative is shown in the second example.


    ```python


    def extract_bad(zippath, dest):
        zipped = ZipFile(zippath)
        try:
            zipped.extractall(dest)
        finally:
            zipped.__del__()

    def extract_good(zippath, dest):
        zipped = ZipFile(zippath)
        try:
            zipped.extractall(dest)
        finally:
            zipped.close()


    ```

    ## References
    * Python Standard Library: [object.__del__](http://docs.python.org/reference/datamodel.html#object.__del__)
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/Formatting/MixedExplicitImplicitIn3101Format.ql
  relativeBqrsPath: codeql/python-queries/Expressions/Formatting/MixedExplicitImplicitIn3101Format.bqrs
  metadata:
    name: Formatting string mixes implicitly and explicitly numbered fields
    description: "Using implicit and explicit numbering in string formatting operations,\
      \ such as '\"{}: {1}\".format(a,b)', will raise a ValueError."
    kind: problem
    problem.severity: error
    tags: |-
      quality
             reliability
             correctness
    sub-severity: low
    precision: high
    id: py/str-format/mixed-fields
  queryHelp: |
    # Formatting string mixes implicitly and explicitly numbered fields
    A formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)`, can use explicitly numbered fields, like `{1}`, or implicitly numbered fields, such as `{}`, but it cannot use both. Doing so will raise a `ValueError`.


    ## Recommendation
    Use either explicitly numbered fields or implicitly numbered fields, but be consistent.


    ## Example
    In the following example the formatting uses both implicit, `{}`, and explicit, `{1}`, numbering for fields, which is illegal.


    ```python
    def illegal_format():
        "{} {1}".format("spam", "eggs")

    ```

    ## References
    * Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/Formatting/UnusedArgumentIn3101Format.ql
  relativeBqrsPath: codeql/python-queries/Expressions/Formatting/UnusedArgumentIn3101Format.bqrs
  metadata:
    name: Unused argument in a formatting call
    description: Including surplus arguments in a formatting call makes code more
      difficult to read and may indicate an error.
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
    problem.severity: warning
    sub-severity: high
    precision: high
    id: py/str-format/surplus-argument
  queryHelp: |
    # Unused argument in a formatting call
    A formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)`, can have any number of arguments, provided that there are enough to match the format. However, surplus arguments are redundant and clutter the code, making it harder to read.

    It is also possible that surplus arguments indicate a mistake in the format string.


    ## Recommendation
    Check that the format string is correct and then remove any surplus arguments.


    ## Example
    In the following example there are three arguments for the call to the `str.format()` method, but the format string only requires two. The third argument should be deleted.


    ```python
    def surplus_argument():
        the_format = "{} {}" # Used to be "{} {} {}"
        return the_format.format(1, 2, 3)

    ```

    ## References
    * Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/Formatting/UnusedNamedArgumentIn3101Format.ql
  relativeBqrsPath: codeql/python-queries/Expressions/Formatting/UnusedNamedArgumentIn3101Format.bqrs
  metadata:
    name: Unused named argument in formatting call
    description: Including surplus keyword arguments in a formatting call makes code
      more difficult to read and may indicate an error.
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/str-format/surplus-named-argument
  queryHelp: |
    # Unused named argument in formatting call
    A formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)` can have keyword arguments of any name, as long as all the required names are provided. However, surplus keyword arguments, those with names that are not in the format, are redundant. These surplus arguments clutter the code, making it harder to read.

    It is also possible that surplus keyword arguments indicate a mistake in the format string.


    ## Recommendation
    Check that the format string is correct and then remove any surplus keyword arguments.


    ## Example
    In the following example, the comment indicates that the `chips` keyword argument is no longer required and should be deleted.


    ```python
    def surplus_argument():
        the_format = "{spam} {eggs}" # Used to be "{spam} {eggs} {chips}"
        return the_format.format(spam = "spam", eggs="eggs", chips="chips")

    ```

    ## References
    * Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/Formatting/WrongNameInArgumentsFor3101Format.ql
  relativeBqrsPath: codeql/python-queries/Expressions/Formatting/WrongNameInArgumentsFor3101Format.bqrs
  metadata:
    name: Missing named arguments in formatting call
    description: |-
      A string formatting operation, such as '"{name}".format(key=b)',
                    where the names of format items in the format string differs from the names of the values to be formatted will raise a KeyError.
    kind: problem
    problem.severity: error
    tags: |-
      quality
             reliability
             correctness
    sub-severity: low
    precision: high
    id: py/str-format/missing-named-argument
  queryHelp: |
    # Missing named arguments in formatting call
    A formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)`, can use named fields. If it does, then keyword arguments must be supplied for all named fields. If any of the keyword arguments are missing then a `KeyError` will be raised.


    ## Recommendation
    Change the format to match the arguments and ensure that the arguments have the correct names.


    ## Example
    In the following example, if `unlikely_condition()` is true, then a `KeyError` will be raised as the keyword parameter `eggs` is missing. Adding a keyword parameter named `eggs` would fix this.


    ```python
    def unsafe_named_format():
        the_format = "{spam} {eggs}"
        if unlikely_condition():
            return the_format.format(spam="spam", completely_different="eggs")
        else:
            return the_format.format(spam="spam", eggs="eggs")

    ```

    ## References
    * Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/Formatting/WrongNumberArgumentsFor3101Format.ql
  relativeBqrsPath: codeql/python-queries/Expressions/Formatting/WrongNumberArgumentsFor3101Format.bqrs
  metadata:
    name: Too few arguments in formatting call
    description: |-
      A string formatting operation, such as '"{0}: {1}, {2}".format(a,b)',
                    where the number of values to be formatted is too few for the format string will raise an IndexError.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/str-format/missing-argument
  queryHelp: |
    # Too few arguments in formatting call
    A formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)`, must have sufficient arguments to match the format. Otherwise, an `IndexError` will be raised.


    ## Recommendation
    Either change the format to match the arguments, or ensure that there are sufficient arguments.


    ## Example
    In the following example, only 2 arguments may be provided for the call to the `str.format` method, which is insufficient for the format string used. To fix this a third parameter should be provided on line 4.


    ```python
    def unsafe_format():
        the_format = "{} {} {}"
        if unlikely_condition():
            return the_format.format(1, 2)
        else:
            return the_format.format(1, 2, 3)


    ```

    ## References
    * Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/HashedButNoHash.ql
  relativeBqrsPath: codeql/python-queries/Expressions/HashedButNoHash.bqrs
  metadata:
    name: Unhashable object hashed
    description: Hashing an object which is not hashable will result in a TypeError
      at runtime.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/hash-unhashable-value
  queryHelp: |
    # Unhashable object hashed
    If an object is used as a key in a dictionary or as a member of a set then it must be hashable, that is it must define a `__hash__` method. All built-in immutable types are hashable, but mutable ones are not. Common hashable types include all numbers, strings (both `unicode` and `bytes`) and `tuple`. Common unhashable types include `list`, `dict` and `set`.

    In order to store a key in a `dict` or `set` a hash value is needed. To determine this value the built-in function `hash()` is called which in turn calls the `__hash__` method on the object. If the object's class does not have the `__hash__` method, then a `TypeError` will be raised.


    ## Recommendation
    Since this problem usually indicates a logical error, it is not possible to give a general recipe for fixing it. Mutable collections can be converted into immutable equivalents where appropriate. For example sets can be hashed by converting any instances of `set` into `frozenset` instances.


    ## Example
    `list`s are not hashable. In this example, an attempt is made to use a `list` as a key in a mapping which will fail with a `TypeError`.


    ```python

    def lookup_with_default_key(mapping, key=None):
        if key is None:
            key = [] # Should be key = ()
        return mapping[key]

    ```

    ## References
    * Python Standard Library: [hash](http://docs.python.org/library/functions.html#hash).
    * Python Language Reference: [object.__hash__](http://docs.python.org/reference/datamodel.html#object.__hash__).
    * Python Standard Library: [Mapping Types &mdash; dict](http://docs.python.org/library/stdtypes.html#mapping-types-dict).
    * Python Standard Library: [Set Types &mdash; set, frozenset](http://docs.python.org/2/library/stdtypes.html#set-types-set-frozenset).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/IncorrectComparisonUsingIs.ql
  relativeBqrsPath: codeql/python-queries/Expressions/IncorrectComparisonUsingIs.bqrs
  metadata:
    name: Comparison using is when operands support `__eq__`
    description: Comparison using `is` when equivalence is not the same as identity
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: low
    precision: high
    id: py/comparison-using-is
  queryHelp: |
    # Comparison using is when operands support `__eq__`
    When you compare two values using the `is` or `is not` operator, it is the object identities of the two values that is tested rather than their equality. If the class of either of the values in the comparison redefines equality then the `is` operator may return `False` even though the objects compare as equal. Equality is defined by the `__eq__` or, in Python2, `__cmp__` method. To compare two objects for equality, use the `==` or `!=` operator instead.


    ## Recommendation
    When you want to compare the value of two literals, use the comparison operator `==` or `!=` in place of `is` or `is not`.

    If the uniqueness property or performance are important then use an object that does not redefine equality.


    ## Example
    In the first line of the following example the programmer tests the value of `value` against `DEFAULT` using the `is` operator. Unfortunately, this may fail when the function is called with the string `"default"`.

    To function correctly, change the expression `value is DEFAULT` to `value == DEFAULT`. Alternatively, if the uniqueness property is desirable, then change the definition of `DEFAULT` to either of the alternatives below.


    ```python

    DEFAULT = "default"

    def get_color(name, fallback):
        if name in COLORS:
            return COLORS[name]
        elif fallback is DEFAULT:
            return DEFAULT_COLOR
        else:
            return fallback

    #This works
    print (get_color("spam", "def" + "ault"))

    #But this does not
    print (get_color("spam", "default-spam"[:7]))

    #To fix the above code change to object
    DEFAULT = object()

    #Or if you want better repr() output:
    class Default(object):

        def __repr__(self):
            return "DEFAULT"

    DEFAULT = Default()

    ```

    ## References
    * Python Standard Library: [Comparisons](http://docs.python.org/3/library/stdtypes.html#comparisons).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/NonCallableCalled.ql
  relativeBqrsPath: codeql/python-queries/Expressions/NonCallableCalled.bqrs
  metadata:
    name: Non-callable called
    description: A call to an object which is not a callable will raise a TypeError
      at runtime.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: high
    precision: high
    id: py/call-to-non-callable
  queryHelp: |
    # Non-callable called
    If an object is called, `obj()`, then that object must be a callable or a `TypeError` will be raised. A callable object is any object whose class defines the `__call__` special method. Callable objects include functions, methods, classes.

    The `callable(object)` builtin function determines if an object is callable or not.

    When the Python interpreter attempts to evaluate a call such as `func(arg)` it will invoke the `__call__` special method on `func`. Thus, `func(arg)` is roughly equivalent to `type(func).__call__(func, arg)` which means that the *class* must define the attribute `__call__`, merely adding it to the instance is not sufficient.


    ## Recommendation
    Since this problem usually indicates a logical error, it is not possible to give a general recipe for fixing it.


    ## Example
    `list`s are not callable. In this example, an attempt is made to call a `list` which will fail with a `TypeError`.


    ```python
    a_list = []
    a_list()

    ```

    ## References
    * Python Standard Library: [callable](http://docs.python.org/2/library/functions.html#callable).
    * Python Language Reference: [object.__call__](http://docs.python.org/2/reference/datamodel.html#object.__call__).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/Regex/BackspaceEscape.ql
  relativeBqrsPath: codeql/python-queries/Expressions/Regex/BackspaceEscape.bqrs
  metadata:
    name: Backspace escape in regular expression
    description: |-
      Using '\b' to escape the backspace character in a regular expression is confusing
                    since it could be mistaken for a word boundary assertion.
    kind: problem
    tags: |-
      quality
             maintainability
             readability
    problem.severity: recommendation
    sub-severity: high
    precision: very-high
    id: py/regex/backspace-escape
  queryHelp: |
    # Backspace escape in regular expression
    The meaning of the `\b` escape sequence inside a regular expression depends on its syntactic context: inside a character class, it matches the backspace character; outside of a character class, it matches a word boundary. This context dependency makes regular expressions hard to read, so the `\b` escape sequence should not be used inside character classes.


    ## Recommendation
    Replace `\b` in character classes with the semantically identical escape sequence `\x08`.


    ## Example
    In the following example, the regular expression contains two uses of `\b`: in the first case, it matches a word boundary, in the second case it matches a backspace character.


    ```python
    import re
    matcher = re.compile(r"\b[\t\b]")

    def match_data(data):
        return bool(matcher.match(data))

    ```
    You can make the regular expression easier for other developers to interpret, by rewriting it as `r"\b[\t\x08]"`.


    ## References
    * Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/Regex/DuplicateCharacterInSet.ql
  relativeBqrsPath: codeql/python-queries/Expressions/Regex/DuplicateCharacterInSet.bqrs
  metadata:
    name: Duplication in regular expression character class
    description: Duplicate characters in a class have no effect and may indicate an
      error in the regular expression.
    kind: problem
    tags: |-
      quality
             maintainability
             readability
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/regex/duplicate-in-character-class
  queryHelp: |
    # Duplication in regular expression character class
    Character classes in regular expressions represent sets of characters, so there is no need to specify the same character twice in one character class. Duplicate characters in character classes are at best useless, and may even indicate a latent bug.


    ## Recommendation
    Determine whether a character is simply duplicated or whether the character class was in fact meant as a group. If it is just a duplicate, then remove the duplicate character. If was supposed to be a group, then replace the square brackets with parentheses.


    ## Example
    In the following example, the character class `[password|pwd]` contains two instances each of the characters `d`, `p`, `s`, and `w`. The programmer most likely meant to write `(password|pwd)` (a pattern that matches either the string `"password"` or the string `"pwd"`), and accidentally mistyped the enclosing brackets.


    ```python
    import re
    matcher = re.compile(r"[password|pwd]")

    def find_password(data):
        if matcher.match(data):
            print("Found password!")

    ```
    To fix this problem, the regular expression should be rewritten to `r"(password|pwd)"`.


    ## References
    * Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).
    * Regular-Expressions.info: [Character Classes or Character Sets](http://www.regular-expressions.info/charclass.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/Regex/MissingPartSpecialGroup.ql
  relativeBqrsPath: codeql/python-queries/Expressions/Regex/MissingPartSpecialGroup.bqrs
  metadata:
    name: Missing part of special group in regular expression
    description: Incomplete special groups are parsed as normal groups and are unlikely
      to match the intended strings.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: high
    precision: high
    id: py/regex/incomplete-special-group
  queryHelp: |
    # Missing part of special group in regular expression
    One of the problems with using regular expressions is that almost any sequence of characters is a valid pattern. This means that it is easy to omit a necessary character and still have a valid regular expression. Omitting a character in a named capturing group is a specific case which can dramatically change the meaning of a regular expression.


    ## Recommendation
    Examine the regular expression to find and correct any typos.


    ## Example
    In the following example, the regular expression for `matcher`, `r"(P<name>[\w]+)"`, is missing a "?" and will match only strings of letters that start with "P&lt;name&gt;", instead of matching any sequence of letters and placing the result in a named group. The fixed version, `fixed_matcher`, includes the "?" and will work as expected.


    ```python
    import re
    matcher = re.compile(r'(P<name>[\w]+)')

    def only_letters(text):
        m = matcher.match(text)
        if m:
            print("Letters are: " + m.group('name'))

    #Fix the pattern by adding the missing '?'
    fixed_matcher = re.compile(r'(?P<name>[\w]+)')
    ```

    ## References
    * Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).
    * Regular-Expressions.info: [Named Capturing Groups](http://www.regular-expressions.info/named.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/Regex/UnmatchableCaret.ql
  relativeBqrsPath: codeql/python-queries/Expressions/Regex/UnmatchableCaret.bqrs
  metadata:
    name: Unmatchable caret in regular expression
    description: "Regular expressions containing a caret '^' in the middle cannot\
      \ be matched, whatever the input."
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/regex/unmatchable-caret
  queryHelp: "# Unmatchable caret in regular expression\nThe caret character `^` anchors\
    \ a regular expression to the beginning of the input, or (for multi-line regular\
    \ expressions) to the beginning of a line. If it is preceded by a pattern that\
    \ must match a non-empty sequence of (non-newline) input characters, then the\
    \ entire regular expression cannot match anything.\n\n\n## Recommendation\nExamine\
    \ the regular expression to find and correct any typos.\n\n\n## Example\nIn the\
    \ following example, the regular expression `r\"\\[^.]*\\.css\"` cannot match\
    \ any string, since it contains a caret assertion preceded by an escape sequence\
    \ that matches an opening bracket.\n\nIn the second regular expression, `r\"[^.]*\\\
    .css\"`, the caret is part of a character class, and will not match the start\
    \ of the string.\n\n\n```python\nimport re\n#Regular expression includes a caret,\
    \ but not at the start.\nmatcher = re.compile(r\"\\[^.]*\\.css\")\n\ndef find_css(filename):\n\
    \    if matcher.match(filename):\n        print(\"Found it!\")\n        \n#Regular\
    \ expression for a css file name\nfixed_matcher_css = re.compile(r\"[^.]*\\.css\"\
    )\n\n\n```\n\n## References\n* Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).\n\
    * Regular-Expressions.info: [Start of String and End of String Anchors](http://www.regular-expressions.info/anchors.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/Regex/UnmatchableDollar.ql
  relativeBqrsPath: codeql/python-queries/Expressions/Regex/UnmatchableDollar.bqrs
  metadata:
    name: Unmatchable dollar in regular expression
    description: "Regular expressions containing a dollar '$' in the middle cannot\
      \ be matched, whatever the input."
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/regex/unmatchable-dollar
  queryHelp: |
    # Unmatchable dollar in regular expression
    A dollar assertion `$` in a regular expression only matches at the end of the input, or (for multi-line regular expressions) at the end of a line. If it is followed by a pattern that must match a non-empty sequence of (non-newline) input characters, it cannot possibly match, rendering the entire regular expression unmatchable.


    ## Recommendation
    Examine the regular expression to find and correct any typos.


    ## Example
    In the following example, the regular expression `r"\.\(\w+$\)"` cannot match any string, since it contains a dollar assertion followed by an escape sequence that matches a closing parenthesis.

    The second regular expression, `r"\.\(\w+\)$"`, has the dollar at the end and will work as expected.


    ```python
    import re
    #Regular expression that includes a dollar, but not at the end.
    matcher = re.compile(r"\.\(\w+$\)")

    def find_it(filename):
        if matcher.match(filename):
            print("Found it!")

    #Regular expression anchored to end of input.
    fixed_matcher = re.compile(r"\.\(\w+\)$")
    ```

    ## References
    * Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).
    * Regular-Expressions.info: [Start of String and End of String Anchors](http://www.regular-expressions.info/anchors.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/TruncatedDivision.ql
  relativeBqrsPath: codeql/python-queries/Expressions/TruncatedDivision.bqrs
  metadata:
    name: Result of integer division may be truncated
    description: |-
      The arguments to a division statement may be integers, which
                    may cause the result to be truncated in Python 2.
    kind: problem
    tags: |-
      maintainability
             correctness
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/truncated-division
  queryHelp: |
    # Result of integer division may be truncated
    In Python 2, the result of dividing two integers is silently truncated into an integer. This may lead to unexpected behavior.


    ## Recommendation
    If the division should never be truncated, add `from __future__ import division` to the beginning of the file. If the division should always be truncated, replace the division operator `/` with the truncated division operator `//`.


    ## Example
    The first example shows a function for calculating the average of a sequence of numbers. When the function runs under Python 2, and the sequence contains only integers, an incorrect result may be returned because the result is truncated. The second example corrects this error by following the recommendation listed above.


    ```python
    # Incorrect:

    def average(l):
        return sum(l) / len(l)

    print average([1.0, 2.0])  # Prints "1.5".
    print average([1, 2])      # Prints "1", which is incorrect.

    ```

    ```python
    # Correct:
    from __future__ import division

    def average(l):
        return sum(l) / len(l)

    print average([1.0, 2.0])  # Prints "1.5".
    print average([1, 2])      # Prints "1.5".

    ```

    ## References
    * Python Language Reference: [Binary arithmetic operations](https://docs.python.org/2/reference/expressions.html#binary-arithmetic-operations).
    * PEP 238: [Changing the Division Operator](https://www.python.org/dev/peps/pep-0238/).
    * PEP 236: [Back to the __future__](https://www.python.org/dev/peps/pep-0236/).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/UnintentionalImplicitStringConcatenation.ql
  relativeBqrsPath: codeql/python-queries/Expressions/UnintentionalImplicitStringConcatenation.bqrs
  metadata:
    name: Implicit string concatenation in a list
    description: Omitting a comma between strings causes implicit concatenation which
      is confusing in a list.
    kind: problem
    tags: |-
      quality
             maintainability
             readability
             external/cwe/cwe-665
    problem.severity: warning
    sub-severity: high
    precision: high
    id: py/implicit-string-concatenation-in-list
  queryHelp: |
    # Implicit string concatenation in a list
    When two string literals abut each other the Python interpreter implicitly concatenates them into a single string. On occasion this can be useful, but is more commonly misleading or incorrect.


    ## Recommendation
    If the concatenation is deliberate, then use `+` to join the strings. This has no runtime overhead, and makes the intention clear.


    ## Example
    In the first function below, `unclear`, implicit string concatenation is used twice; once deliberately and once by accident. In the second function, `clarified`, the first concatenation is made explicit and the second is removed.


    ```python

    def unclear():
        # Returns [ "first part of long string and the second part", "/usr/local/usr/bin" ]
        return [

            "first part of long string"
            " and the second part",
            "/usr/local"
            "/usr/bin"
        ]

    def clarified():
        # Returns [ "first part of long string and the second part", "/usr/local", "/usr/bin" ]
        return [
            "first part of long string" +
            " and the second part",
            "/usr/local",
            "/usr/bin"
        ]

    ```

    ## References
    * Python language reference: [String literal concatenation](https://docs.python.org/3/reference/lexical_analysis.html#string-literal-concatenation).
    * Common Weakness Enumeration: [CWE-665](https://cwe.mitre.org/data/definitions/665.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/UnnecessaryLambda.ql
  relativeBqrsPath: codeql/python-queries/Expressions/UnnecessaryLambda.bqrs
  metadata:
    name: Unnecessary lambda
    description: A lambda is used that calls through to a function without modifying
      any parameters
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
    problem.severity: recommendation
    sub-severity: high
    precision: high
    id: py/unnecessary-lambda
  queryHelp: |
    # Unnecessary lambda
    A lambda that calls a function without modifying any of its parameters is unnecessary. Python functions are first class objects and can be passed around in the same way as the resulting lambda.


    ## Recommendation
    Remove the lambda, use the function directly.


    ## Example
    In this example a lambda is used unnecessarily in order to pass a method as an argument to ` call_with_x_squared`.


    ```python
    import math

    def call_with_x_squared(x, function):
        x = x*x
        return function(x)

    print call_with_x_squared(2, lambda x: math.factorial(x))
    ```
    This is not necessary as methods can be passed directly. They behave as callable objects.


    ```python
    import math

    def call_with_x_squared(x, function):
        x = x*x
        return function(x)

    print call_with_x_squared(2, math.factorial)
    ```

    ## References
    * Python: [lambdas](http://docs.python.org/2.7/reference/expressions.html#lambda).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/UnsupportedFormatCharacter.ql
  relativeBqrsPath: codeql/python-queries/Expressions/UnsupportedFormatCharacter.bqrs
  metadata:
    name: Unsupported format character
    description: An unsupported format character in a format string
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/percent-format/unsupported-character
  queryHelp: |
    # Unsupported format character
    A printf-style format string (i.e. a string that is used as the left hand side of the `%` operator, such as `fmt % arguments`) must consist of valid conversion specifiers, such as `%s`, `%d`, etc. Otherwise, a `ValueError` will be raised.


    ## Recommendation
    Ensure a valid conversion specifier is used.


    ## Example
    In the following example, `format_as_tuple_incorrect`, `%t` is not a valid conversion specifier.


    ```python

    def format_as_tuple_incorrect(args):
        return "%t" % args

    def format_as_tuple_correct(args):
        return "%r" % (args,)

    ```

    ## References
    * Python Library Reference: [printf-style String Formatting.](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/UseofApply.ql
  relativeBqrsPath: codeql/python-queries/Expressions/UseofApply.bqrs
  metadata:
    name: '''apply'' function used'
    description: The builtin function 'apply' is obsolete and should not be used.
    kind: problem
    tags: maintainability
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/use-of-apply
  queryHelp: |
    # 'apply' function used
    The 'apply' function is deprecated and makes code harder to read as most Python programmers will not be familiar with it (it has been deprecated since 2003).


    ## Recommendation
    Replace `apply(function, args)` with `function(*args)`.

    Replace `apply(function, args, keywords)` with `function(*args, **keywords)`.


    ## References
    * Python Standard Library: [apply](http://docs.python.org/2/library/functions.html#apply).
    * Python PEP-290: [Code Migration and Modernization](http://www.python.org/dev/peps/pep-0290/).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/UseofInput.ql
  relativeBqrsPath: codeql/python-queries/Expressions/UseofInput.bqrs
  metadata:
    name: '''input'' function used in Python 2'
    description: "The built-in function 'input' is used which, in Python 2, can allow\
      \ arbitrary code to be run."
    kind: problem
    tags: |-
      security
             correctness
             external/cwe/cwe-094
             external/cwe/cwe-095
    problem.severity: error
    security-severity: 9.8
    sub-severity: high
    precision: high
    id: py/use-of-input
  queryHelp: |
    # 'input' function used in Python 2
    In Python 2, a call to the `input()` function, `input(prompt)` is equivalent to `eval(raw_input(prompt))`. Evaluating user input without any checking can be a serious security flaw.


    ## Recommendation
    Get user input with `raw_input(prompt)` and then validate that input before evaluating. If the expected input is a number or string, then `ast.literal_eval()` can always be used safely.


    ## References
    * Python Standard Library: [input](http://docs.python.org/2/library/functions.html#input), [ast.literal_eval](http://docs.python.org/2/library/ast.html#ast.literal_eval).
    * Wikipedia: [Data validation](http://en.wikipedia.org/wiki/Data_validation).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/WrongNameForArgumentInCall.ql
  relativeBqrsPath: codeql/python-queries/Expressions/WrongNameForArgumentInCall.bqrs
  metadata:
    name: Wrong name for an argument in a call
    description: |-
      Using a named argument whose name does not correspond to a
                    parameter of the called function or method, will result in a
                    TypeError at runtime.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-628
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/call/wrong-named-argument
  queryHelp: |
    # Wrong name for an argument in a call
    Using a named argument whose name does not correspond to a parameter of the called function (or method), will result in a `TypeError` at runtime.


    ## Recommendation
    Check for typos in the name of the arguments and fix those. If the name is clearly different, then this suggests a logical error. The change required to correct the error will depend on whether the wrong argument has been specified or whether the wrong function (or method) has been specified.


    ## References
    * Python Glossary: [Arguments](https://docs.python.org/2/glossary.html#term-argument).
    * Python Glossary: [Parameters](https://docs.python.org/glossary.html#term-parameter).
    * Python Programming FAQ: [ What is the difference between arguments and parameters?](https://docs.python.org/2/faq/programming.html#faq-argument-vs-parameter).
    * Common Weakness Enumeration: [CWE-628](https://cwe.mitre.org/data/definitions/628.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/WrongNumberArgumentsForFormat.ql
  relativeBqrsPath: codeql/python-queries/Expressions/WrongNumberArgumentsForFormat.bqrs
  metadata:
    name: Wrong number of arguments for format
    description: |-
      A string formatting operation, such as '"%s: %s, %s" % (a,b)', where the number of conversion specifiers in the
                    format string differs from the number of values to be formatted will raise a TypeError.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-685
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/percent-format/wrong-arguments
  queryHelp: |
    # Wrong number of arguments for format
    A formatting expression, that is an expression of the format `fmt % arguments` must have the correct number of arguments on the right hand side of the expression. Otherwise, a `TypeError` will be raised.


    ## Recommendation
    Change the format to match the arguments and ensure that the right hand argument always has the correct number of elements.


    ## Example
    In the following example the right hand side of the formatting operation can be of length 2, which does not match the format string.


    ```python
    def unsafe_format():
        if unlikely_condition():
            args = (1,2)
        else:
            args = (1, 2, 3)
        return "%s %s %s" % args

    ```

    ## References
    * Python Library Reference: [String Formatting.](http://docs.python.org/library/stdtypes.html#string-formatting)
    * Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/WrongNumberArgumentsInCall.ql
  relativeBqrsPath: codeql/python-queries/Expressions/WrongNumberArgumentsInCall.bqrs
  metadata:
    name: Wrong number of arguments in a call
    description: Using too many or too few arguments in a call to a function will
      result in a TypeError at runtime.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-685
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/call/wrong-arguments
  queryHelp: |
    # Wrong number of arguments in a call
    A function call must supply an argument for each parameter that does not have a default value defined, so:

    * The minimum number of arguments is the number of parameters without default values.
    * The maximum number of arguments is the total number of parameters, unless the function takes a varargs (starred) parameter in which case there is no limit.

    ## Recommendation
    If there are too few arguments then check to see which arguments have been omitted and supply values for those.

    If there are too many arguments then check to see if any have been added by mistake and remove those.

    Also check where a comma has been inserted instead of an operator or a dot. For example, the code is `obj,attr` when it should be `obj.attr`.

    If it is not clear which are the missing or surplus arguments, then this suggests a logical error. The fix will then depend on the nature of the error.


    ## References
    * Python Glossary: [Arguments](https://docs.python.org/2/glossary.html#term-argument).
    * Python Glossary: [Parameters](https://docs.python.org/glossary.html#term-parameter).
    * Python Programming FAQ: [ What is the difference between arguments and parameters?](https://docs.python.org/2/faq/programming.html#faq-argument-vs-parameter).
    * Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/ConsistentReturns.ql
  relativeBqrsPath: codeql/python-queries/Functions/ConsistentReturns.bqrs
  metadata:
    name: Explicit returns mixed with implicit (fall through) returns
    description: Mixing implicit and explicit returns indicates a likely error as
      implicit returns always return `None`.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: recommendation
    sub-severity: high
    precision: high
    id: py/mixed-returns
  queryHelp: "# Explicit returns mixed with implicit (fall through) returns\nWhen\
    \ a function contains both explicit returns (`return value`) and implicit returns\
    \ (where code falls off the end of a function), this often indicates that a return\
    \ statement has been forgotten. It is best to return an explicit return value\
    \ even when returning `None` because this makes it easier for other developers\
    \ to read your code.\n\n\n## Recommendation\nAdd an explicit return at the end\
    \ of the function.\n\n\n## Example\nIn the `check_state1` function, the developer\
    \ probably did intend to use an implicit return value of `None` as this equates\
    \ to `False`. However, the function in `check_state2` is easier to read.\n\n\n\
    ```python\n    def check_state1(state, interactive=True):\n        if not state['good']\
    \ or not state['bad']:\n            if (good or bad or skip or reset) and interactive:\n\
    \                return                                          # implicitly\
    \ return None\n            if not state['good']:\n                raise util.Abort(_('cannot\
    \ bisect (no known good revisions)'))\n            else:\n                raise\
    \ util.Abort(_('cannot bisect (no known bad revisions)')) \n        return True\
    \  \t\t\t\t\t\t\t                              \n           \n    def check_state2(state,\
    \ interactive=True):\n        if not state['good'] or not state['bad']:\n    \
    \        if (good or bad or skip or reset) and interactive:\n                return\
    \ False                                    # return an explicit value\n      \
    \      if not state['good']:\n                raise util.Abort(_('cannot bisect\
    \ (no known good revisions)'))\n            else:\n                raise util.Abort(_('cannot\
    \ bisect (no known bad revisions)'))\n        return True\n\n```\n\n## References\n\
    * Python Language Reference: [Function definitions](http://docs.python.org/3/reference/compound_stmts.html#function).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/DeprecatedSliceMethod.ql
  relativeBqrsPath: codeql/python-queries/Functions/DeprecatedSliceMethod.bqrs
  metadata:
    name: Deprecated slice method
    description: Defining special methods for slicing has been deprecated since Python
      2.0.
    kind: problem
    tags: maintainability
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/deprecated-slice-method
  queryHelp: |
    # Deprecated slice method
    The `__getslice__`, `__setslice__` and `__delslice__` methods have been deprecated since Python 2.0. In general, no class should implement these methods.

    The only exceptions to this rule are classes that inherit from `list` and override `__getitem__`, `__setitem__` or `__delitem__`. Since `list` implements the slicing methods any class inheriting from `list` must implement the the slicing methods to ensure correct behavior of `__getitem__`, `__setitem__` and `__delitem__`. These exceptions to the rule will not be treated as violations.


    ## Recommendation
    Delete the slicing method. Any functionality should be moved to the equivalent `__xxxitem__` method:

    * `__getslice__` should be replaced with `__getitem__`
    * `__setslice__` should be replaced with `__setitem__`
    * `__delslice__` should be replaced with `__delitem__`

    ## References
    * Python Language Reference: [ Additional methods for emulation of sequence types](https://docs.python.org/2/reference/datamodel.html#additional-methods-for-emulation-of-sequence-types).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/ExplicitReturnInInit.ql
  relativeBqrsPath: codeql/python-queries/Functions/ExplicitReturnInInit.bqrs
  metadata:
    name: '`__init__` method returns a value'
    description: Explicitly returning a value from an `__init__` method will raise
      a TypeError.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/explicit-return-in-init
  queryHelp: |
    # `__init__` method returns a value
    The `__init__` method of a class is used to initialize new objects, not create them. As such, it should not return any value. Returning `None` is correct in the sense that no runtime error will occur, but it suggests that the returned value is meaningful, which it is not.


    ## Recommendation
    Convert the `return expr` statement to a plain `return` statement, or omit it altogether if it is at the end of the method.


    ## Example
    In this example, the `__init__` method attempts to return the newly created object. This is an error and the return method should be removed.


    ```python
    class ExplicitReturnInInit(object):
        def __init__(self, i):
            self.i = i
            return self
    ```

    ## References
    * Python: [The __init__ method](http://docs.python.org/2.7/reference/datamodel.html#object.__init__).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/IncorrectlyOverriddenMethod.ql
  relativeBqrsPath: codeql/python-queries/Functions/IncorrectlyOverriddenMethod.bqrs
  metadata:
    deprecated: ""
    name: Mismatch between signature and use of an overriding method
    description: "Method has a different signature from the overridden method and,\
      \ if it were called, would be likely to cause an error."
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/inheritance/incorrect-overriding-signature
  queryHelp: |
    # Mismatch between signature and use of an overriding method
    There is a call to the overridden method, and potentially the overriding method, with arguments that are not legal for the overriding method. This will cause an error if the overriding method is called and is a violation of the Liskov substitution principle.


    ## Recommendation
    Ensure that the overriding method accepts all the parameters that are legal for the overridden method.


    ## Example
    In this example there is a mismatch between the legal parameters for the base class method `(self, source, filename, symbol)` and the extension method `(self, source)`. The extension method can be used to override the base method as long as values are not specified for the `filename` and (optional) `symbol` parameters. If the extension method was passed the additional parameters accepted by the base method then an error would occur.


    ```python

    class BaseClass(object):

        def run(self, source, filename, symbol="single"):
            ... # Definition

        def load_and_run(self, filename):
            source = self.load(filename)
            self.run(source, filename) # Matches signature in this class, but not in the derived class.

    class DerivedClass(BaseClass):

        def run(self, source):
            ... # Definition

    ```
    The extension method should be updated to support the `filename` and `symbol` parameters supported by the overridden method.


    ## References
    * Wikipedia: [Liskov Substitution Principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle), [Method overriding](http://en.wikipedia.org/wiki/Method_overriding#Python).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/IncorrectlySpecifiedOverriddenMethod.ql
  relativeBqrsPath: codeql/python-queries/Functions/IncorrectlySpecifiedOverriddenMethod.bqrs
  metadata:
    name: Mismatch between signature and use of an overridden method
    description: |-
      Method has a signature that differs from both the signature of its overriding methods and
                    the arguments with which it is called, and if it were called, would be likely to cause an error.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: recommendation
    sub-severity: high
    precision: high
    id: py/inheritance/incorrect-overridden-signature
  queryHelp: |
    # Mismatch between signature and use of an overridden method
    There is a call to the overriding method, and potentially the overridden method, with arguments that are not legal for the overridden method. This will cause an error if the overridden method is called and is a violation of the Liskov substitution principle.


    ## Recommendation
    Ensure that the overridden method accepts all the parameters that are legal for overriding method(s).


    ## Example
    In this example there is a mismatch between the legal parameters for the base class method `(self, source, filename)` and the extension method `(self, source)`. Since there is a call that uses the signature of the extension method then it can be inferred that the base signature is erroneous and should be updated to match that of the extension method.


    ```python

    class BaseClass(object):

        def run(self, source, filename, symbol="single"):
            ... # Definition

        def load_and_run(self, filename):
            source = self.load(filename)
            self.run(source) # Matches signature in derived class, but not in this class.

    class DerivedClass(BaseClass):

        def run(self, source):
            ... # Definition

    ```
    The base method should be updated to either remove the `filename` parameters, or add a default value for it.


    ## References
    * Wikipedia: [Liskov Substitution Principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle), [Method overriding](http://en.wikipedia.org/wiki/Method_overriding#Python).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/IncorrectRaiseInSpecialMethod.ql
  relativeBqrsPath: codeql/python-queries/Functions/IncorrectRaiseInSpecialMethod.bqrs
  metadata:
    name: Non-standard exception raised in special method
    description: Raising a non-standard exception in a special method alters the expected
      interface of that method.
    kind: problem
    tags: |-
      quality
             reliability
             error-handling
    problem.severity: recommendation
    sub-severity: high
    precision: high
    id: py/unexpected-raise-in-special-method
  queryHelp: "# Non-standard exception raised in special method\nUser-defined classes\
    \ interact with the Python virtual machine via special methods (also called \"\
    magic methods\"). For example, for a class to support addition it must implement\
    \ the `__add__` and `__radd__` special methods. When the expression `a + b` is\
    \ evaluated, the Python virtual machine will call `type(a).__add__(a, b)`, and\
    \ if that is not implemented it will call `type(b).__radd__(b, a)`.\n\nSince the\
    \ virtual machine calls these special methods for common expressions, users of\
    \ the class will expect these operations to raise standard exceptions. For example,\
    \ users would expect that the expression `a.b` may raise an `AttributeError` if\
    \ the object `a` does not have an attribute `b`. If a `KeyError` were raised instead,\
    \ then this would be unexpected and may break code that expected an `AttributeError`,\
    \ but not a `KeyError`.\n\nTherefore, if a method is unable to perform the expected\
    \ operation then its response should conform to the standard protocol, described\
    \ below.\n\n* Attribute access, `a.b` (`__getattr__`): Raise `AttributeError`.\n\
    * Arithmetic operations, `a + b` (`__add__`): Do not raise an exception, return\
    \ `NotImplemented` instead.\n* Indexing, `a[b]` (`__getitem__`): Raise `KeyError`\
    \ or `IndexError`.\n* Hashing, `hash(a)` (`__hash__`): Should not raise an exception.\
    \ Use `__hash__ = None` to indicate that an object is unhashable rather than raising\
    \ an exception.\n* Equality methods, `a == b` (`__eq__`): Never raise an exception,\
    \ always return `True` or `False`.\n* Ordering comparison methods, `a < b` (`__lt__`):\
    \ Raise a `TypeError` if the objects cannot be ordered.\n* Most others: If the\
    \ operation is never supported, the method often does not need to be implemented\
    \ at all; otherwise a `TypeError` should be raised.\n\n## Recommendation\nIf the\
    \ method always raises as exception, then if it is intended to be an abstract\
    \ method, the `@abstractmethod` decorator should be used. Otherwise, ensure that\
    \ the method raises an exception of the correct type, or remove the method if\
    \ the operation does not need to be supported.\n\n\n## Example\nIn the following\
    \ example, the `__add__` method of `A` raises a `TypeError` if `other` is of the\
    \ wrong type. However, it should return `NotImplemented` instead of rising an\
    \ exception, to allow other classes to support adding to `A`. This is demonstrated\
    \ in the class `B`.\n\n\n```python\nclass A:\n    def __init__(self, a):\n   \
    \     self.a = a \n\n    def __add__(self, other):\n        # BAD: Should return\
    \ NotImplemented instead of raising\n        if not isinstance(other,A):\n   \
    \         raise TypeError(f\"Cannot add A to {other.__class__}\")\n        return\
    \ A(self.a + other.a)\n\nclass B:\n    def __init__(self, a):\n        self.a\
    \ = a \n\n    def __add__(self, other):\n        # GOOD: Returning NotImplemented\
    \ allows for the operation to fallback to other implementations to allow other\
    \ classes to support adding to B.\n        if not isinstance(other,B):\n     \
    \       return NotImplemented\n        return B(self.a + other.a)\n    \n\n  \
    \      \n\n```\nIn the following example, the `__getitem__` method of `C` raises\
    \ a `ValueError`, rather than a `KeyError` or `IndexError` as expected.\n\n\n\
    ```python\nclass C:\n    def __getitem__(self, idx):\n        if self.idx < 0:\n\
    \            # BAD: Should raise a KeyError or IndexError instead.\n         \
    \   raise ValueError(\"Invalid index\")\n        return self.lookup(idx)\n \n\n\
    ```\nIn the following example, the class `__hash__` method of `D` raises `NotImplementedError`.\
    \ This causes `D` to be incorrectly identified as hashable by `isinstance(obj,\
    \ collections.abc.Hashable)`; so the correct way to make a class unhashable is\
    \ to set `__hash__ = None`.\n\n\n```python\nclass D:\n    def __hash__(self):\n\
    \        # BAD: Use `__hash__ = None` instead.\n        raise NotImplementedError(f\"\
    {self.__class__} is unhashable.\")\n```\n\n## References\n* Python Language Reference:\
    \ [Special Method Names](http://docs.python.org/dev/reference/datamodel.html#special-method-names).\n\
    * Python Library Reference: [Exceptions](https://docs.python.org/3/library/exceptions.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/InitIsGenerator.ql
  relativeBqrsPath: codeql/python-queries/Functions/InitIsGenerator.bqrs
  metadata:
    name: '`__init__` method is a generator'
    description: '`__init__` method is a generator.'
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/init-method-is-generator
  queryHelp: |
    # `__init__` method is a generator
    The `__init__` method of a class is used to initialize new objects, not create them. As such, it should not return any value. By including a `yield` expression in the method turns it into a generator method. On calling it will return a generator resulting in a runtime error.


    ## Recommendation
    The presence of a `yield` expression in an `__init__` method suggests a logical error, so it is not possible to suggest a general fix.


    ## Example
    In this example the `__init__` method contains a yield expression. This is not logical in the context of an initializer.


    ```python
    class InitIsGenerator(object):
        def __init__(self, i):
            yield i
    ```

    ## References
    * Python: [The __init__ method](http://docs.python.org/3/reference/datamodel.html#object.__init__).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/IterReturnsNonIterator.ql
  relativeBqrsPath: codeql/python-queries/Functions/IterReturnsNonIterator.bqrs
  metadata:
    name: '`__iter__` method returns a non-iterator'
    description: "The `__iter__` method returns a non-iterator which, if used in a\
      \ 'for' loop, would raise a 'TypeError'."
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/iter-returns-non-iterator
  queryHelp: |
    # `__iter__` method returns a non-iterator
    The `__iter__` method of a class should always return an iterator.

    Iterators must implement both `__next__` and `__iter__` for Python 3, or both `next` and `__iter__` for Python 2. The `__iter__` method of the iterator must return the iterator object itself.

    Iteration in Python relies on this behavior and attempting to iterate over an instance of a class with an incorrect `__iter__` method can raise a `TypeError`.


    ## Recommendation
    Make sure the value returned by `__iter__` implements the full iterator protocol.


    ## Example
    In this example, we have implemented our own version of `range`, extending the normal functionality with the ability to skip some elements by using the `skip` method. However, the iterator `MyRangeIterator` does not fully implement the iterator protocol (namely it is missing `__iter__`).

    Iterating over the elements in the range seems to work on the surface, for example the code `x = sum(my_range)` gives the expected result. However, if we run `sum(iter(my_range))` we get a `TypeError: 'MyRangeIterator' object is not iterable`.

    If we try to skip some elements using our custom method, for example `y = sum(my_range.skip({6,9}))`, this also raises a `TypeError`.

    The fix is to implement the `__iter__` method in `MyRangeIterator`.


    ```python
    class MyRange(object):
        def __init__(self, low, high):
            self.low = low
            self.high = high

        def __iter__(self):
            return MyRangeIterator(self.low, self.high)

        def skip(self, to_skip):
            return MyRangeIterator(self.low, self.high, to_skip)

    class MyRangeIterator(object):
        def __init__(self, low, high, skip=None):
            self.current = low
            self.high = high
            self.skip = skip

        def __next__(self):
            if self.current >= self.high:
                raise StopIteration
            to_return = self.current
            self.current += 1
            if self.skip and to_return in self.skip:
                return self.__next__()
            return to_return

        # Problem is fixed by uncommenting these lines
        # def __iter__(self):
        #     return self

    my_range = MyRange(0,10)
    x = sum(my_range) # x = 45
    y = sum(my_range.skip({6,9})) # TypeError: 'MyRangeIterator' object is not iterable

    ```

    ## References
    * Python Language Reference: [object.__iter__](https://docs.python.org/3/reference/datamodel.html#object.__iter__).
    * Python Standard Library: [Iterator Types](https://docs.python.org/3/library/stdtypes.html#typeiter).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/IterReturnsNonSelf.ql
  relativeBqrsPath: codeql/python-queries/Functions/IterReturnsNonSelf.bqrs
  metadata:
    name: Iterator does not return self from `__iter__` method
    description: "Iterator does not return self from `__iter__` method, violating\
      \ the iterator protocol."
    kind: problem
    tags: |-
      reliability
             correctness
             quality
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/iter-returns-non-self
  queryHelp: |
    # Iterator does not return self from `__iter__` method
    Iterator classes (classes defining a `__next__` method) should have an `__iter__` method that returns the iterator itself. This ensures that the object is also an iterable; and behaves as expected when used anywhere an iterator or iterable is expected, such as in `for` loops.


    ## Recommendation
    Ensure that the `__iter__` method returns `self`, or is otherwise equivalent as an iterator to `self`.


    ## Example
    In the following example, the `MyRange` class's `__iter__` method does not return `self`. This would lead to unexpected results when used with a `for` loop or `in` statement.


    ```python
    class MyRange(object):
        def __init__(self, low, high):
            self.current = low
            self.high = high

        def __iter__(self):
            return (self.current, self.high) # BAD: does not return `self`.

        def __next__(self):
            if self.current > self.high:
                return None
            self.current += 1
            return self.current - 1
    ```

    ## References
    * Python Language Reference: [object.__iter__](http://docs.python.org/3/reference/datamodel.html#object.__iter__).
    * Python Standard Library: [Iterators](http://docs.python.org/3/library/stdtypes.html#typeiter).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/ModificationOfParameterWithDefault.ql
  relativeBqrsPath: codeql/python-queries/Functions/ModificationOfParameterWithDefault.bqrs
  metadata:
    name: Modification of parameter with default
    description: |-
      Modifying the default value of a parameter can lead to unexpected
                    results.
    kind: path-problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/modification-of-default-value
  queryHelp: |
    # Modification of parameter with default
    The default value of a parameter is computed once when the function is created, not for every invocation. The "pre-computed" value is then used for every subsequent call to the function. Consequently, if you modify the default value for a parameter this "modified" default value is used for the parameter in future calls to the function. This means that the function may not behave as expected in future calls and also makes the function more difficult to understand.


    ## Recommendation
    If a parameter has a default value, do not modify the default value. When you use a mutable object as a default value, you should use a placeholder value instead of modifying the default value. This is a particular problem when you work with lists and dictionaries but there are standard methods of avoiding modifying the default parameter (see References).


    ## Example
    In the following example, the `default` parameter is set with a default value of an empty list. Other commands in the function then append values to the list. The next time the function is called, the list will contain values, which may not have been intended.


    ```python

        def __init__(self, name, choices=[], default=[], shortDesc=None,
                     longDesc=None, hints=None, allowNone=1):   # 'default' parameter assigned a value
            self.choices = choices
            if choices and not default:
                default.append(choices[0][1])                   # value of 'default' parameter modified
            Argument.__init__(self, name, default, shortDesc, longDesc, hints, allowNone=allowNone)
    ```
    The recommended workaround is use a placeholder value. That is, define the function with a default of `default=None`, check if the parameter is `None` and then set the parameter to a list.


    ## References
    * Effbot: [Default Parameter Values in Python](https://web.archive.org/web/20201112004749/http://effbot.org/zone/default-values.htm).
    * Python Language Reference: [Function definitions](http://docs.python.org/3/reference/compound_stmts.html#function-definitions).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/NonCls.ql
  relativeBqrsPath: codeql/python-queries/Functions/NonCls.bqrs
  metadata:
    name: First parameter of a class method is not named 'cls'
    description: "By the PEP8 style guide, the first parameter of a class method should\
      \ be named `cls`."
    kind: problem
    tags: |-
      maintainability
             readability
             convention
             quality
    problem.severity: recommendation
    sub-severity: high
    precision: high
    id: py/not-named-cls
  queryHelp: |
    # First parameter of a class method is not named 'cls'
    The first parameter of a class method (including certain special methods such as `__new__`), or a method of a metaclass, should be named `cls`.


    ## Recommendation
    Ensure that the first parameter of class methods is named `cls`, as recommended by the style guidelines in PEP 8.


    ## Example
    In the following example, the first parameter of the class method `make` is named `self` instead of `cls`.


    ```python
    class Entry(object):
        @classmethod
        def make(self):
            return Entry()

    ```

    ## References
    * Python PEP 8: [Function and method arguments](http://www.python.org/dev/peps/pep-0008/#function-and-method-arguments).
    * Python Tutorial: [Classes](http://docs.python.org/2/tutorial/classes.html).
    * Python Docs: [classmethod](https://docs.python.org/3/library/functions.html#classmethod).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/NonSelf.ql
  relativeBqrsPath: codeql/python-queries/Functions/NonSelf.bqrs
  metadata:
    name: First parameter of a method is not named 'self'
    description: "By the PEP8 style guide, the first parameter of a normal method\
      \ should be named `self`."
    kind: problem
    tags: |-
      maintainability
             readability
             convention
             quality
    problem.severity: recommendation
    sub-severity: high
    precision: very-high
    id: py/not-named-self
  queryHelp: |
    # First parameter of a method is not named 'self'
    Normal methods should have at least one parameter and the first parameter should be called `self`.


    ## Recommendation
    Ensure that the first parameter of a normal method is named `self`, as recommended by the style guidelines in PEP 8.

    If a `self` parameter is unneeded, the method should be decorated with `staticmethod`, or moved out of the class as a regular function.


    ## Example
    In the following cases, the first argument of `Point.__init__` is named `val` instead; whereas in `Point2.__init__` it is correctly named `self`.


    ```python
    class Point:
        def __init__(val, x, y):  # BAD: first parameter is mis-named 'val'
            val._x = x
            val._y = y

    class Point2:
        def __init__(self, x, y):  # GOOD: first parameter is correctly named 'self'
            self._x = x
            self._y = y
    ```

    ## References
    * Python PEP 8: [Function and method arguments](http://www.python.org/dev/peps/pep-0008/#function-and-method-arguments).
    * Python Tutorial: [Classes](http://docs.python.org/2/tutorial/classes.html).
    * Python Docs: [staticmethod](https://docs.python.org/3/library/functions.html#staticmethod).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/OverlyComplexDelMethod.ql
  relativeBqrsPath: codeql/python-queries/Functions/OverlyComplexDelMethod.bqrs
  metadata:
    name: Overly complex `__del__` method
    description: "`__del__` methods may be called at arbitrary times, perhaps never\
      \ called at all, and should be simple."
    kind: problem
    tags: |-
      quality
             maintainability
             complexity
    problem.severity: recommendation
    sub-severity: low
    precision: high
    id: py/overly-complex-delete
  queryHelp: |
    # Overly complex `__del__` method
    The `__del__` method exists to release any resources held by an object when that object is deleted. The `__del__` is called only by the garbage collector which may call it after an indefinite delay or never.

    Consequently, `__del__` method should not be relied on to release resources, such as file descriptors. Rather, these resources should be released explicitly.

    The existence of a complex `__del__` method suggests that this is the main or only way to release resources associated with the object.


    ## Recommendation
    In order to ensure correct cleanup of the object add an explicit close(), or similar, method. Possibly make the object a context manager.

    The __del__ method should just call close()


    ## Example
    The first example below shows a class which relies on `__del__` to release resources. The second example shows an improved version of the class where `__del__` simply calls close.


    ```python

    #Relies on __del__ being called by the garbage collector.
    class CachedPreferencesFile

        ...

        def __del__(self):
            for key, value in self.preferences.items():
                self.write_pair(key, value)
            self.backing.close()


    #Better version
    class CachedPreferencesFile

        ...

        def close(self):
            for key, value in self.preferences.items():
                self.write_pair(key, value)
            self.backing.close()

        def __del__(self):
            self.close()

    ```

    ## References
    * Python Standard Library: [Context manager](http://docs.python.org/library/stdtypes.html#context-manager-types).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/ReturnConsistentTupleSizes.ql
  relativeBqrsPath: codeql/python-queries/Functions/ReturnConsistentTupleSizes.bqrs
  metadata:
    name: Returning tuples with varying lengths
    description: A function that potentially returns tuples of different lengths may
      indicate a problem.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: recommendation
    sub-severity: high
    precision: high
    id: py/mixed-tuple-returns
  queryHelp: |
    # Returning tuples with varying lengths
    A common pattern for functions returning multiple arguments is to return a single tuple containing said arguments. If the function has multiple return points, care must be taken to ensure that the tuples returned have the same length.


    ## Recommendation
    Ensure that the function returns tuples of similar lengths.


    ## Example
    In this example, the `sum_length_product1` function simultaneously calculates the sum, length, and product of the values in the given list. For empty lists, however, the returned tuple only contains the sum and length of the list. In `sum_length_product2` this error has been corrected.


    ```python
    def sum_length_product1(l):
        if l == []:
            return 0, 0                              # this tuple has the wrong length
        else:
            val = l[0]
            restsum, restlength, restproduct = sum_length_product1(l[1:])
            return restsum + val, restlength + 1, restproduct * val

    def sum_length_product2(l):
        if l == []:
            return 0, 0, 1                           # this tuple has the correct length
        else:
            val = l[0]
            restsum, restlength, restproduct = sum_length_product2(l[1:])
            return restsum + val, restlength + 1, restproduct * val

    ```

    ## References
    * Python Language Reference: [Function definitions](http://docs.python.org/2/reference/compound_stmts.html#function).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/SignatureOverriddenMethod.ql
  relativeBqrsPath: codeql/python-queries/Functions/SignatureOverriddenMethod.bqrs
  metadata:
    name: Signature mismatch in overriding method
    description: |-
      Overriding a method without ensuring that both methods accept the same
                    number and type of parameters has the potential to cause an error when there is a mismatch.
    kind: problem
    problem.severity: warning
    tags: |-
      quality
             reliability
             correctness
    sub-severity: high
    precision: very-high
    id: py/inheritance/signature-mismatch
  queryHelp: "# Signature mismatch in overriding method\nWhen the signature of a method\
    \ of a base class and a method of a subclass that overrides it don't match, a\
    \ call to the base class method may not be a valid call to the subclass method,\
    \ and thus raise an exception if an instance of the subclass is passed instead.\
    \ If following the Liskov Substitution Principle, in which an instance of a subclass\
    \ should be usable in every context as though it were an instance of the base\
    \ class, this behavior breaks the principle.\n\n\n## Recommendation\nEnsure that\
    \ the overriding method in the subclass accepts the same parameters as the base\
    \ method.\n\n\n## Example\nIn the following example, `Base.runsource` takes an\
    \ optional `filename` argument. However, the overriding method `Sub.runsource`\
    \ does not. This means the `run` function will fail if passed an instance of `Sub`.\n\
    \n\n```python\n\nclass Base:\n    def runsource(self, source, filename=\"<input>\"\
    ):\n        ...\n    \n    \nclass Sub(Base):\n    def runsource(self, source):\
    \ # BAD: Does not match the signature of overridden method.\n        ... \n\n\
    def run(obj: Base):\n    obj.runsource(\"source\", filename=\"foo.txt\")\n```\n\
    \n## References\n* Wikipedia: [Liskov Substitution Principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle),\
    \ [Method overriding](http://en.wikipedia.org/wiki/Method_overriding#Python).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/SignatureSpecialMethods.ql
  relativeBqrsPath: codeql/python-queries/Functions/SignatureSpecialMethods.bqrs
  metadata:
    name: Special method has incorrect signature
    description: Special method has incorrect signature
    kind: problem
    tags: |-
      reliability
             correctness
             quality
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/special-method-wrong-signature
  queryHelp: |
    # Special method has incorrect signature
    Special methods (sometimes also called magic methods) are how user defined classes interact with the Python virtual machine. For example, for a class to support addition it must implement the `__add__` and `__radd__` special methods. When the expression `a + b` is evaluated the Python virtual machine will call `type(a).__add__(a, b)` and if that is not implemented it will call `type(b).__radd__(b, a)`.

    Since these special methods are always called by the virtual machine with a fixed number of parameters, if the method is implemented with a different number of parameters it will fail at runtime with a `TypeError`.


    ## Recommendation
    Ensure that the method has the correct number of parameters


    ## Example
    In the example the `__str__` method has an extra parameter. This means that if `str(p)` is called when `p` is a `Point` then it will fail with a `TypeError`.


    ```python
    #-*- coding: utf-8 -*-

    class Point(object):

        def __init__(self, x, y):
            self.x
            self.y

        def __add__(self, other):
            if not isinstance(other, Point):
                return NotImplemented
            return Point(self.x + other.x, self.y + other.y)

        def __str__(self, style): #Spurious extra parameter
            if style == 'polar':
                u"%s @ %s\u00b0" % (abs(self), self.angle())
            else:
                return "[%s, %s]" % (self.x, self.y)

    ```

    ## References
    * Python Language Reference: [Special Method Names](http://docs.python.org/dev/reference/datamodel.html#special-method-names).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Functions/UseImplicitNoneReturnValue.ql
  relativeBqrsPath: codeql/python-queries/Functions/UseImplicitNoneReturnValue.bqrs
  metadata:
    name: Use of the return value of a procedure
    description: The return value of a procedure (a function that does not return
      a value) is used. This is confusing to the reader as the value (None) has no
      meaning.
    kind: problem
    tags: |-
      quality
             maintainability
             readability
    problem.severity: warning
    sub-severity: low
    precision: high
    id: py/procedure-return-value-used
  queryHelp: |
    # Use of the return value of a procedure
    All functions in Python return a value. If a function has no `return` statements or none of the `return` statements return a value then the function will return `None`. However, this value has no meaning and should be ignored.

    Using the return value of such a 'procedure' is confusing to the reader as it suggests that the value is significant.


    ## Recommendation
    Do not use the return value of a procedure; replace `x = proc()` with `proc()` and replace any use of the value with `None`.


    ## Example
    In this example, the `my_print` function is a procedure as it returns no value of any meaning. Using the return value is misleading in subsequent code.


    ```python

    import sys

    def my_print(*args):
        print (args)

    def main():
        err = my_print(sys.argv)
        if err:
            sys.exit(err)


    #FIXED VERSION
    def main():
        my_print(sys.argv)
        #The rest of the code can be removed as None as always false


    ```

    ## References
    * Python Library Reference: [None](http://docs.python.org/library/constants.html#None).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Imports/CyclicImport.ql
  relativeBqrsPath: codeql/python-queries/Imports/CyclicImport.bqrs
  metadata:
    name: Cyclic import
    description: "Module forms part of an import cycle, thereby indirectly importing\
      \ itself."
    kind: problem
    tags: |-
      reliability
             maintainability
             modularity
    problem.severity: recommendation
    sub-severity: low
    precision: high
    id: py/cyclic-import
  queryHelp: |
    # Cyclic import
    A cyclic import is an `import` which imports another module and that module imports (possibly indirectly) the module which contains the `import` statement.

    Cyclic imports indicate that two modules are circularly dependent. This means that the modules cannot be tested independently, and it makes it harder to understand the architecture of the system.


    ## Recommendation
    The cycle may be broken by removing any one import. If only one function or method requires the import, then consider moving that to the other module and deleting the import. If the two modules are more intimately connected, then move the inter-dependent parts into a third module and have both the original modules import that.


    ## References
    * Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).
    * Python: [Modules](http://docs.python.org/2/tutorial/modules.html).
    * Effbot: [Import Confusion](https://web.archive.org/web/20200917011425/https://effbot.org/zone/import-confusion.htm).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Imports/DeprecatedModule.ql
  relativeBqrsPath: codeql/python-queries/Imports/DeprecatedModule.bqrs
  metadata:
    name: Import of deprecated module
    description: Import of a deprecated module
    kind: problem
    tags: |-
      maintainability
             external/cwe/cwe-477
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/import-deprecated-module
  queryHelp: |
    # Import of deprecated module
    A module is deprecated when it cannot or will not be maintained indefinitely in the standard library. Deprecated modules may not receive security fixes or other important updates. See PEP 4 for a list of all deprecated modules.


    ## Recommendation
    Do not import the deprecated module. Replace uses of it with uses of a better maintained module.


    ## References
    * Python PEPs: [PEP 4 -- Deprecation of Standard Modules ](http://www.python.org/dev/peps/pep-0004/).
    * Common Weakness Enumeration: [CWE-477](https://cwe.mitre.org/data/definitions/477.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Imports/EncodingError.ql
  relativeBqrsPath: codeql/python-queries/Imports/EncodingError.bqrs
  metadata:
    name: Encoding error
    description: Encoding errors cause failures at runtime and prevent analysis of
      the code.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/encoding-error
  queryHelp: |
    # Encoding error
    Encoding errors prevent a module being evaluated and thus imported. An attempt to import a module with an invalid encoding will fail; a `SyntaxError` will be raised. Note that in Python 2, the default encoding is ASCII.

    The existence of an encoding error in a module may suggest other problems as well. Either the module is never imported in practice and could be deleted or a `try` statement around the import is mistakenly discarding the `SyntaxError`.


    ## Recommendation
    Fixing the encoding error is the obvious fix. However, it is worth investigating why a module containing an encoding error was able to persist and address that problem as well.

    If a different encoding should be used for the file, specify it explicitly by putting an encoding specification at the top of the file. For instance, to specify UTF-8 encoding, add the line `# coding=utf-8`.


    ## References
    * Python PEPs: [PEP 263  Defining Python Source Code Encodings.](https://www.python.org/dev/peps/pep-0263/)
    * Python Tutorial: [SyntaxErrors.](http://docs.python.org/tutorial/errors.html#syntax-errors)
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Imports/FromImportOfMutableAttribute.ql
  relativeBqrsPath: codeql/python-queries/Imports/FromImportOfMutableAttribute.bqrs
  metadata:
    name: Importing value of mutable attribute
    description: Importing the value of a mutable attribute directly means that changes
      in global state will not be observed locally.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: high
    precision: medium
    id: py/import-of-mutable-attribute
  queryHelp: "# Importing value of mutable attribute\nExplicitly importing an attribute\
    \ from a module into the current namespace means that the value of that attribute\
    \ will not be updated if the value in the original module changes.\n\nThis can\
    \ mean that changes in global state are not observed locally, which may lead to\
    \ inconsistencies and possible errors.\n\n\n## Recommendation\nInstead of using\
    \ `from module import attr`, simply import the module using `import module` and\
    \ replace all uses of `attr` with `module.attr`.\n\n\n## Example\nIn the first\
    \ of the two modules shown below, `from sys import stdout` is used to import the\
    \ `stdout` attribute, rather than using `import sys` to import the module. Then\
    \ `stdout` is used in the `main()` function.\n\n\n```python\nfrom sys import stdout\n\
    \ndef main():\n    stdout.write(\"Hello World!\")\n    \n\n```\nIn the second\
    \ module, below, a function, `redirect_to_file` is defined to collect the output\
    \ from `sys.stdout` and save it to a file. However, `redirect_to_file` will not\
    \ work correctly when passed the `main()` function. This is because the `main()`\
    \ function will not see the change to `sys.stdout`, as it uses its own version\
    \ of `stdout` that was defined when the module was loaded.\n\n\n```python\nimport\
    \ sys\n\ndef redirect_to_file(function, args, kwargs, filename):\n    with open(filename)\
    \ as out:\n        orig_stdout = sys.stdout\n        sys.stdout = out\n      \
    \  try:\n            function(*args, **kwargs)\n        finally:\n           \
    \ sys.stdout = orig_stdout\n\n\n```\nThe problem can be fixed by rewriting the\
    \ first module to import the `sys` module and write to `sys.stdout`, as shown\
    \ below.\n\n\n```python\nimport sys\n\ndef main():\n    sys.stdout.write(\"Hello\
    \ World!\")\n\n```\n\n## References\n* Python Language Reference: [The import\
    \ statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n*\
    \ Python Tutorial: [Modules](http://docs.python.org/2/tutorial/modules.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Imports/ImportandImportFrom.ql
  relativeBqrsPath: codeql/python-queries/Imports/ImportandImportFrom.bqrs
  metadata:
    name: Module is imported with 'import' and 'import from'
    description: A module is imported with the "import" and "import from" statements
    kind: problem
    tags: |-
      quality
             maintainability
             readability
    problem.severity: recommendation
    sub-severity: low
    precision: very-high
    id: py/import-and-import-from
  queryHelp: |
    # Module is imported with 'import' and 'import from'
    Importing a module twice using the `import xxx` and `from xxx import yyy` is confusing.


    ## Recommendation
    Remove the `from xxx import yyy` statement. Add `yyy = xxx.yyy` if required.


    ## Example

    ```python
    import os
    from os import walk

    ```

    ## References
    * Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Imports/ModuleImportsItself.ql
  relativeBqrsPath: codeql/python-queries/Imports/ModuleImportsItself.bqrs
  metadata:
    name: Module imports itself
    description: A module imports itself
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
    problem.severity: recommendation
    sub-severity: high
    precision: very-high
    id: py/import-own-module
  queryHelp: |
    # Module imports itself
    There is no need for a module to import itself. A module importing itself may lead to errors as the module may be in an incomplete state when imported by itself.


    ## Recommendation
    Remove the import statement. Convert all expressions of the form `mod.name` where "mod" is the name of the current module to `name`.


    ## Example
    In this example the module, `ModuleImportsItself` imports itself and has an expression referencing the module it is in as well.


    ```python
    import ModuleImportsItself

    def factorial(n):
        if n <= 0:
            return 1
        return n * ModuleImportsItself.factorial(n - 1)
    ```
    The import can be removed and the reference can be corrected.


    ```python

    def factorial(n):
        if n <= 0:
            return 1
        return n * factorial(n - 1)
    ```

    ## References
    * Python: [Modules](http://docs.python.org/2/tutorial/modules.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Imports/ModuleLevelCyclicImport.ql
  relativeBqrsPath: codeql/python-queries/Imports/ModuleLevelCyclicImport.bqrs
  metadata:
    name: Module-level cyclic import
    description: "Module uses member of cyclically imported module, which can lead\
      \ to failure at import time."
    kind: problem
    tags: |-
      reliability
             correctness
             types
    problem.severity: error
    sub-severity: low
    precision: high
    comprehension: 0.5
    id: py/unsafe-cyclic-import
  queryHelp: |
    # Module-level cyclic import
    A cyclic import is an `import` which imports another module and that module imports (possibly indirectly) the module which contains the `import` statement. If all imports in a cyclic import occur at module level, then a module will be imported when it is part way through its initialization. This may rest in surprising errors, as parts of the module being imported may not yet exist.

    In addition to the possible errors, cyclic imports indicate that two modules are circularly dependent. This means that the modules cannot be tested independently, and it makes it harder to understand the architecture of the system.


    ## Recommendation
    The cycle may be broken by removing any one import. If only one function or method requires the import, then consider moving that to the other module and deleting the import. If the two modules are more intimately connected, then move the inter-dependent parts into a third module and have both the original modules import that.


    ## References
    * Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).
    * Python: [Modules](http://docs.python.org/2/tutorial/modules.html).
    * Effbot: [Import Confusion](https://web.archive.org/web/20200917011425/https://effbot.org/zone/import-confusion.htm).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Imports/MultipleImports.ql
  relativeBqrsPath: codeql/python-queries/Imports/MultipleImports.bqrs
  metadata:
    name: Module is imported more than once
    description: Importing a module a second time has no effect and impairs readability
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
    problem.severity: recommendation
    sub-severity: high
    precision: very-high
    id: py/repeated-import
  queryHelp: |
    # Module is imported more than once
    Importing the same module more than once has no effect as each module is only loaded once. It also confuses readers of the code.


    ## Recommendation
    Remove the second import.


    ## Example

    ```python
    import module1
    import module2
    import module1 # Duplicate import

    ```

    ## References
    * Python: [import statement](http://docs.python.org/reference/simple_stmts.html#import).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Imports/SyntaxError.ql
  relativeBqrsPath: codeql/python-queries/Imports/SyntaxError.bqrs
  metadata:
    name: Syntax error
    description: Syntax errors cause failures at runtime and prevent analysis of the
      code.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: high
    precision: high
    id: py/syntax-error
  queryHelp: |
    # Syntax error
    Syntax errors prevent a module being evaluated and thus imported. An attempt to import a module with invalid syntax will fail; a `SyntaxError` will be raised.

    A common cause of syntax errors is the difference in syntax between Python 2 and Python 3. In particular, a syntax error may be alerted if a Python 3 file is assumed to be compatible with Python 2 (or vice versa). Explicitly specifying the expected Python version can help prevent this.

    The existence of a syntax error in a module may suggest other problems as well. Either the module is never imported in practice and could be deleted or a `try` statement around the import is mistakenly discarding the `SyntaxError`.


    ## Recommendation
    Fixing the syntax error is the obvious fix. However, it is worth investigating why a module containing a syntax error was able to persist and address that problem as well.

    If you suspect that the syntax error is caused by the analysis using the wrong version of Python, consider specifying the version explicitly. When you run code scanning using the CodeQL action, you can configure the Python version to use. For more information, see [Analyzing Python dependencies](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#analyzing-python-dependencies).


    ## References
    * Python Tutorial: [SyntaxErrors.](http://docs.python.org/tutorial/errors.html#syntax-errors)
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Imports/UnintentionalImport.ql
  relativeBqrsPath: codeql/python-queries/Imports/UnintentionalImport.bqrs
  metadata:
    name: '''import *'' may pollute namespace'
    description: |-
      Importing a module using 'import *' may unintentionally pollute the global
                    namespace if the module does not define `__all__`
    kind: problem
    tags: |-
      quality
             maintainability
             readability
    problem.severity: recommendation
    sub-severity: high
    precision: very-high
    id: py/polluting-import
  queryHelp: |
    # 'import *' may pollute namespace
    When you import a module using `from xxx import *` all public names defined in the module are imported and bound in the local namespace of the `import` statement. The public names are determined by checking the `__all__` variable for the module. If ` __all__` is not defined then all names within the module that do not start with an underscore character are imported. This pollutes the current namespace with names that are not part of the public API for the module.


    ## Recommendation
    There are two ways to address this problem:

    * where possible, modify the module being imported *from* and define `__all__ ` to restrict the names to be imported
    * otherwise, explicitly import the values that you need.

    ## Example
    The following simple example shows how `__all__` controls the public names for the module `finance`.


    ```python
    # Example module - finance.py

    __all__ = ['tax1', 'tax2']  #defines the names to import when '*' is used

    tax1 = 5
    tax2 = 10
    def cost(): return 'cost'

    # Imported into code using

    from finance import *

    print tax1
    print tax2
    ```
    If the `finance` module did not include a definition of `__all__`, then you could replace `from finance import *` with `from finance import tax1, tax2`.


    ## References
    * Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).
    * Python Tutorial: [Modules](http://docs.python.org/2/tutorial/modules.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Imports/UnusedImport.ql
  relativeBqrsPath: codeql/python-queries/Imports/UnusedImport.bqrs
  metadata:
    name: Unused import
    description: Import is not required as it is not used
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
    problem.severity: recommendation
    sub-severity: high
    precision: very-high
    id: py/unused-import
  queryHelp: |
    # Unused import
    A module is imported (using the `import` statement) but that module is never used. This creates a dependency that does not need to exist and makes the code more difficult to read.


    ## Recommendation
    Delete the import statement.


    ## References
    * Python: [import statement](http://docs.python.org/reference/simple_stmts.html#import).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Lexical/CommentedOutCode.ql
  relativeBqrsPath: codeql/python-queries/Lexical/CommentedOutCode.bqrs
  metadata:
    name: Commented-out code
    description: Commented-out code makes the remaining code more difficult to read.
    kind: problem
    tags: |-
      quality
             maintainability
             readability
    problem.severity: recommendation
    sub-severity: high
    precision: high
    id: py/commented-out-code
  queryHelp: |
    # Commented-out code
    Commented-out code is distracting and confusing for developers who read the surrounding code, and its significance is often unclear. It will not get compiled or tested when the code around it changes, so it's likely to break over time. For these reasons, commented-out code should be avoided.


    ## Recommendation
    Remove or reinstate the commented-out code. If you want to include a snippet of example code in a comment, consider enclosing it in quotes or marking it up as appropriate for the source language.


    ## Example
    In the following example, a `print` statement, originally used for debugging, is left in the code, but commented out. It should be removed altogether.


    ```python
    def area(r):
        #if DEBUG:
        #   print("Computing area of %r" % r)
        return r.length * r.width

    ```

    ## References
    * Mark Needham: [The danger of commenting out code](http://www.markhneedham.com/blog/2009/01/17/the-danger-of-commenting-out-code/).
    * Los Techies: [Commented Code == Technical Debt](http://lostechies.com/rodpaddock/2010/12/29/commented-code-technical-debt).
    * High Integrity C++ Coding Standard: [2.3.2 Do not comment out code](http://www.codingstandard.com/rule/2-3-2-do-not-comment-out-code/).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Lexical/OldOctalLiteral.ql
  relativeBqrsPath: codeql/python-queries/Lexical/OldOctalLiteral.bqrs
  metadata:
    name: Confusing octal literal
    description: Octal literal with a leading 0 is easily misread as a decimal value
    kind: problem
    tags: readability
    problem.severity: recommendation
    sub-severity: low
    precision: high
    id: py/old-style-octal-literal
  queryHelp: |
    # Confusing octal literal
    Octal literals starting with 0 are easily misread as a decimal, particularly by those programmers who do not have a C or Java background.

    The new literal syntax for non-decimal numbers is more distinct and is thus less likely to be misunderstood.


    ## Recommendation
    Use the 0oXXX form instead of the 0XXX form. Alternatively use binary or hexadecimal format if that would be clearer.


    ## Example

    ```python

    #Easily misread as x = 15
    x = 015

    #The extra 'o' alerts the reader that this is an octal literal
    y = 0o15

    #If this is a byte sized value then a hexadecimal might be clearer
    y = 0x0d

    #Or if it is a bit pattern then a binary value might be clearer
    y = 0b1101

    ```

    ## References
    * Python Language Reference: [Integer Literals](http://docs.python.org/2/reference/lexical_analysis.html#integer-and-long-integer-literals).
    * Python PEP 3127: [Integer Literal Support and Syntax](http://www.python.org/dev/peps/pep-3127/).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Numerics/Pythagorean.ql
  relativeBqrsPath: codeql/python-queries/Numerics/Pythagorean.bqrs
  metadata:
    name: Pythagorean calculation with sub-optimal numerics
    description: Calculating the length of the hypotenuse using the standard formula
      may lead to overflow.
    kind: problem
    tags: accuracy
    problem.severity: warning
    sub-severity: low
    precision: medium
    id: py/pythagorean
  queryHelp: |
    # Pythagorean calculation with sub-optimal numerics
    Calculating the length of the hypotenuse using the standard formula `c = sqrt(a**2 + b**2)` may lead to overflow if the two other sides are both very large. Even though `c` will not be much bigger than `max(a, b)`, either `a**2` or `b**2` (or both) will. Thus, the calculation could overflow, even though the result is well within representable range.


    ## Recommendation
    Rather than `sqrt(a**2 + b**2)`, use the built-in function `hypot(a,b)` from the `math` library.


    ## Example
    The following code shows two different ways of computing the hypotenuse. The first is a direct rewrite of the Pythagorean theorem, the second uses the built-in function.


    ```python
    # We know that a^2 + b^2 = c^2, and wish to use this to compute c
    from math import sqrt, hypot

    a = 3e154 # a^2 > 1e308
    b = 4e154 # b^2 > 1e308
    # with these, c = 5e154 which is less that 1e308

    def longSideDirect():
        return sqrt(a**2 + b**2) # this will overflow

    def longSideBuiltin():
        return hypot(a, b) # better to use built-in function
    ```

    ## References
    * Python Language Reference: [The hypot function](https://docs.python.org/library/math.html#math.hypot)
    * Wikipedia: [Hypot](https://en.wikipedia.org/wiki/Hypot).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Resources/FileNotAlwaysClosed.ql
  relativeBqrsPath: codeql/python-queries/Resources/FileNotAlwaysClosed.bqrs
  metadata:
    name: File is not always closed
    description: Opening a file without ensuring that it is always closed may lead
      to data loss or resource leaks.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             performance
             external/cwe/cwe-772
    problem.severity: warning
    sub-severity: high
    precision: high
    id: py/file-not-closed
  queryHelp: "# File is not always closed\nWhen a file is opened, it should always\
    \ be closed.\n\nA file opened for writing that is not closed when the application\
    \ exits may result in data loss, where not all of the data written may be saved\
    \ to the file. A file opened for reading or writing that is not closed may also\
    \ use up file descriptors, which is a resource leak that in long running applications\
    \ could lead to a failure to open additional files.\n\n\n## Recommendation\nEnsure\
    \ that opened files are always closed, including when an exception could be raised.\
    \ The best practice is often to use a `with` statement to automatically clean\
    \ up resources. Otherwise, ensure that `.close()` is called in a `try...except`\
    \ or `try...finally` block to handle any possible exceptions.\n\n\n## Example\n\
    In the following examples, in the case marked BAD, the file may not be closed\
    \ if an exception is raised. In the cases marked GOOD, the file is always closed.\n\
    \n\n```python\ndef bad():\n    f = open(\"filename\", \"w\")\n    f.write(\"could\
    \ raise exception\") # BAD: This call could raise an exception, leading to the\
    \ file not being closed.\n    f.close()\n\n\ndef good1():\n    with open(\"filename\"\
    , \"w\") as f:\n        f.write(\"always closed\") # GOOD: The `with` statement\
    \ ensures the file is always closed.\n\ndef good2():\n    f = open(\"filename\"\
    , \"w\")\n    try:\n       f.write(\"always closed\")\n    finally:\n        f.close()\
    \ # GOOD: The `finally` block always ensures the file is closed.\n   \n\n```\n\
    \n## References\n* Python Documentation: [Reading and writing files](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files).\n\
    * Python Language Reference: [The with statement](http://docs.python.org/reference/compound_stmts.html#the-with-statement),\
    \ [The try statement](http://docs.python.org/reference/compound_stmts.html#the-try-statement).\n\
    * Python PEP 343: [The \"with\" Statement](http://www.python.org/dev/peps/pep-0343).\n\
    * Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CVE-2018-1281/BindToAllInterfaces.ql
  relativeBqrsPath: codeql/python-queries/Security/CVE-2018-1281/BindToAllInterfaces.bqrs
  metadata:
    name: Binding a socket to all network interfaces
    description: |-
      Binding a socket to all interfaces opens it up to traffic from any IPv4 address
       and is therefore associated with security risks.
    kind: problem
    tags: |-
      security
             external/cwe/cwe-200
    problem.severity: error
    security-severity: 6.5
    sub-severity: low
    precision: high
    id: py/bind-socket-all-network-interfaces
  queryHelp: |
    # Binding a socket to all network interfaces
    Sockets can be used to communicate with other machines on a network. You can use the (IP address, port) pair to define the access restrictions for the socket you create. When using the built-in Python `socket` module (for instance, when building a message sender service or an FTP server data transmitter), one has to bind the port to some interface. When you bind the port to all interfaces using `0.0.0.0` as the IP address, you essentially allow it to accept connections from any IPv4 address provided that it can get to the socket via routing. Binding to all interfaces is therefore associated with security risks.


    ## Recommendation
    Bind your service incoming traffic only to a dedicated interface. If you need to bind more than one interface using the built-in `socket` module, create multiple sockets (instead of binding to one socket to all interfaces).


    ## Example
    In this example, two sockets are insecure because they are bound to all interfaces; one through the `0.0.0.0` notation and another one through an empty string `''`.


    ```python
    import socket

    # binds to all interfaces, insecure
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('0.0.0.0', 31137))

    # binds to all interfaces, insecure
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('', 4040))

    # binds only to a dedicated interface, secure
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('84.68.10.12', 8080))

    ```

    ## References
    * Python reference: [ Socket families](https://docs.python.org/3/library/socket.html#socket-families).
    * Python reference: [ Socket Programming HOWTO](https://docs.python.org/3.7/howto/sockets.html).
    * Common Vulnerabilities and Exposures: [ CVE-2018-1281 Detail](https://nvd.nist.gov/vuln/detail/CVE-2018-1281).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-020/CookieInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-020/CookieInjection.bqrs
  metadata:
    name: Construction of a cookie using user-supplied input
    description: Constructing cookies from user input may allow an attacker to perform
      a Cookie Poisoning attack.
    kind: path-problem
    problem.severity: warning
    precision: high
    security-severity: 5.0
    id: py/cookie-injection
    tags: |-
      security
             external/cwe/cwe-020
  queryHelp: |
    # Construction of a cookie using user-supplied input
    Constructing cookies from user input can allow an attacker to control a user's cookie. This may lead to a session fixation attack. Additionally, client code may not expect a cookie to contain attacker-controlled data, and fail to sanitize it for common vulnerabilities such as Cross Site Scripting (XSS). An attacker manipulating the raw cookie header may additionally be able to set cookie attributes such as `HttpOnly` to insecure values.


    ## Recommendation
    Do not use raw user input to construct cookies.


    ## Example
    In the following cases, a cookie is constructed for a Flask response using user input. The first uses `set_cookie`, and the second sets a cookie's raw value through the `set-cookie` header.


    ```python
    from flask import request, make_response


    @app.route("/1")
    def set_cookie():
        resp = make_response()
        resp.set_cookie(request.args["name"], # BAD: User input is used to set the cookie's name and value
                        value=request.args["name"])
        return resp


    @app.route("/2")
    def set_cookie_header():
        resp = make_response()
        resp.headers['Set-Cookie'] = f"{request.args['name']}={request.args['name']};" # BAD: User input is used to set the raw cookie header.
        return resp

    ```

    ## References
    * Wikipedia - [Session Fixation](https://en.wikipedia.org/wiki/Session_fixation).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-020/IncompleteHostnameRegExp.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-020/IncompleteHostnameRegExp.bqrs
  metadata:
    name: Incomplete regular expression for hostnames
    description: Matching a URL or hostname against a regular expression that contains
      an unescaped dot as part of the hostname might match more hostnames than expected.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: py/incomplete-hostname-regexp
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Incomplete regular expression for hostnames
    Sanitizing untrusted URLs is a common technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.

    If a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping the `.` meta-characters appropriately. Even if the check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when it accidentally succeeds.


    ## Recommendation
    Escape all meta-characters appropriately when constructing regular expressions for security checks, and pay special attention to the `.` meta-character.


    ## Example
    The following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.


    ```python
    from flask import Flask, request, redirect
    import re

    app = Flask(__name__)

    UNSAFE_REGEX = re.compile("(www|beta).example.com/")
    SAFE_REGEX = re.compile(r"(www|beta)\.example\.com/")

    @app.route('/some/path/bad')
    def unsafe(request):
        target = request.args.get('target', '')
        if UNSAFE_REGEX.match(target):
            return redirect(target)

    @app.route('/some/path/good')
    def safe(request):
        target = request.args.get('target', '')
        if SAFE_REGEX.match(target):
            return redirect(target)

    ```
    The `unsafe` check is easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.

    The `safe` check closes this vulnerability by escaping the `.` so that URLs of the form `wwwXexample.com` are rejected.


    ## References
    * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
    * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-020/IncompleteUrlSubstringSanitization.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-020/IncompleteUrlSubstringSanitization.bqrs
  metadata:
    name: Incomplete URL substring sanitization
    description: Security checks on the substrings of an unparsed URL are often vulnerable
      to bypassing.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: py/incomplete-url-substring-sanitization
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Incomplete URL substring sanitization
    Sanitizing untrusted URLs is a common technique for preventing attacks such as request forgeries and malicious redirections. Usually, this is done by checking that the host of a URL is in a set of allowed hosts.

    However, treating the URL as a string and checking if one of the allowed hosts is a substring of the URL is very prone to errors. Malicious URLs can bypass such security checks by embedding one of the allowed hosts in an unexpected location.

    Even if the substring check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when the check succeeds accidentally.


    ## Recommendation
    Parse a URL before performing a check on its host value, and ensure that the check handles arbitrary subdomain sequences correctly.


    ## Example
    The following example code checks that a URL redirection will reach the `example.com` domain.


    ```python
    from flask import Flask, request, redirect
    from urllib.parse import urlparse

    app = Flask(__name__)

    # Not safe, as "evil-example.net/example.com" would be accepted

    @app.route('/some/path/bad1')
    def unsafe1(request):
        target = request.args.get('target', '')
        if "example.com" in target:
            return redirect(target)

    # Not safe, as "benign-looking-prefix-example.com" would be accepted

    @app.route('/some/path/bad2')
    def unsafe2(request):
        target = request.args.get('target', '')
        if target.endswith("example.com"):
            return redirect(target)



    #Simplest and safest approach is to use an allowlist

    @app.route('/some/path/good1')
    def safe1(request):
        allowlist = [
            "example.com/home",
            "example.com/login",
        ]
        target = request.args.get('target', '')
        if target in allowlist:
            return redirect(target)

    #More complex example allowing sub-domains.

    @app.route('/some/path/good2')
    def safe2(request):
        target = request.args.get('target', '')
        host = urlparse(target).hostname
        #Note the '.' preceding example.com
        if host and host.endswith(".example.com"):
            return redirect(target)


    ```
    The first two examples show unsafe checks that are easily bypassed. In `unsafe1` the attacker can simply add `example.com` anywhere in the url. For example, `http://evil-example.net/example.com`.

    In `unsafe2` the attacker must use a hostname ending in `example.com`, but that is easy to do. For example, `http://benign-looking-prefix-example.com`.

    The second two examples show safe checks. In `safe1`, an allowlist is used. Although fairly inflexible, this is easy to get right and is most likely to be safe.

    In `safe2`, `urlparse` is used to parse the URL, then the hostname is checked to make sure it ends with `.example.com`.


    ## References
    * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
    * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-020/OverlyLargeRange.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-020/OverlyLargeRange.bqrs
  metadata:
    name: Overly permissive regular expression range
    description: |-
      Overly permissive regular expression ranges match a wider range of characters than intended.
                    This may allow an attacker to bypass a filter or sanitizer.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: high
    id: py/overly-large-range
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Overly permissive regular expression range
    It's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \ ] ^ _ ` ``.

    Another common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.


    ## Recommendation
    Avoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.


    ## Example
    The following example code is intended to check whether a string is a valid 6 digit hex color.

    ```python

    import re
    def is_valid_hex_color(color):
        return re.match(r'^#[0-9a-fA-f]{6}$', color) is not None

    ```
    However, the `A-f` range is overly large and matches every uppercase character. It would parse a "color" like `#XXYYZZ` as valid.

    The fix is to use an uppercase `A-F` range instead.

    ```python

    import re
    def is_valid_hex_color(color):
        return re.match(r'^#[0-9a-fA-F]{6}$', color) is not None

    ```

    ## References
    * GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)
    * wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)
    * Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)
    * Paul Boyd: [The regex \[,-.\]](https://pboyd.io/posts/comma-dash-dot/)
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-022/PathInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-022/PathInjection.bqrs
  metadata:
    name: Uncontrolled data used in path expression
    description: Accessing paths influenced by users can allow an attacker to access
      unexpected resources.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    sub-severity: high
    precision: high
    id: py/path-injection
    tags: |-
      correctness
             security
             external/cwe/cwe-022
             external/cwe/cwe-023
             external/cwe/cwe-036
             external/cwe/cwe-073
             external/cwe/cwe-099
  queryHelp: |
    # Uncontrolled data used in path expression
    Accessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.


    ## Recommendation
    Validate user input before using it to construct a file path, either using an off-the-shelf library function like `werkzeug.utils.secure_filename`, or by performing custom validation.

    Ideally, follow these rules:

    * Do not allow more than a single "." character.
    * Do not allow directory separators such as "/" or "\\" (depending on the file system).
    * Do not rely on simply replacing problematic sequences such as "../". For example, after applying this filter to ".../...//", the resulting string would still be "../".
    * Use an allowlist of known good patterns.

    ## Example
    In the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name that is an absolute path, such as `"/etc/passwd"`.

    In the second example, it appears that the user is restricted to opening a file within the `"user"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `"../../../etc/passwd"` will result in the code reading the file located at `"/server/static/images/../../../etc/passwd"`, which is the system's password file. This file would then be sent back to the user, giving them access to all the system's passwords. Note that a user could also use an absolute path here, since the result of `os.path.join("/server/static/images/", "/etc/passwd")` is `"/etc/passwd"`.

    In the third example, the path used to access the file system is normalized *before* being checked against a known prefix. This ensures that regardless of the user input, the resulting path is safe.


    ```python
    import os.path
    from flask import Flask, request, abort

    app = Flask(__name__)

    @app.route("/user_picture1")
    def user_picture1():
        filename = request.args.get('p')
        # BAD: This could read any file on the file system
        data = open(filename, 'rb').read()
        return data

    @app.route("/user_picture2")
    def user_picture2():
        base_path = '/server/static/images'
        filename = request.args.get('p')
        # BAD: This could still read any file on the file system
        data = open(os.path.join(base_path, filename), 'rb').read()
        return data

    @app.route("/user_picture3")
    def user_picture3():
        base_path = '/server/static/images'
        filename = request.args.get('p')
        #GOOD -- Verify with normalised version of path
        fullpath = os.path.normpath(os.path.join(base_path, filename))
        if not fullpath.startswith(base_path):
            raise Exception("not allowed")
        data = open(fullpath, 'rb').read()
        return data

    ```

    ## References
    * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * npm: [werkzeug.utils.secure_filename](http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename).
    * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).
    * Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).
    * Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).
    * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).
    * Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-022/TarSlip.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-022/TarSlip.bqrs
  metadata:
    name: Arbitrary file write during tarfile extraction
    description: |-
      Extracting files from a malicious tar archive without validating that the
                    destination file path is within the destination directory can cause files outside
                    the destination directory to be overwritten.
    kind: path-problem
    id: py/tarslip
    problem.severity: error
    security-severity: 7.5
    precision: medium
    tags: |-
      security
             external/cwe/cwe-022
  queryHelp: |
    # Arbitrary file write during tarfile extraction
    Extracting files from a malicious tar archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten, due to the possible presence of directory traversal elements (`..`) in archive paths.

    Tar archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to determine an output file to write the contents of the archive item to, then the file may be written to an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.

    For example, if a tar archive contains a file entry `..\sneaky-file`, and the tar archive is extracted to the directory `c:\output`, then naively combining the paths would result in an output file path of `c:\output\..\sneaky-file`, which would cause the file to be written to `c:\sneaky-file`.


    ## Recommendation
    Ensure that output paths constructed from tar archive entries are validated to prevent writing files to unexpected locations.

    The recommended way of writing an output file from a tar archive entry is to check that `".."` does not occur in the path.


    ## Example
    In this example an archive is extracted without validating file paths. If `archive.tar` contained relative paths (for instance, if it were created by something like `tar -cf archive.tar ../file.txt`) then executing this code could write to locations outside the destination directory.


    ```python
    import sys
    import tarfile

    with tarfile.open(sys.argv[1]) as tar:
        #BAD : This could write any file on the filesystem.
        for entry in tar:
            tar.extract(entry, "/tmp/unpack/")

    ```
    To fix this vulnerability, we need to check that the path does not contain any `".."` elements in it.


    ```python
    import sys
    import tarfile
    import os.path

    with tarfile.open(sys.argv[1]) as tar:
        for entry in tar:
            #GOOD: Check that entry is safe
            if os.path.isabs(entry.name) or ".." in entry.name:
                raise ValueError("Illegal tar archive entry")
            tar.extract(entry, "/tmp/unpack/")

    ```

    ## References
    * Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).
    * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * Python Library Reference: [TarFile.extract](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extract).
    * Python Library Reference: [TarFile.extractall](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extractall).
    * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-074/TemplateInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-074/TemplateInjection.bqrs
  metadata:
    name: Server Side Template Injection
    description: Using user-controlled data to create a template can lead to remote
      code execution or cross site scripting.
    kind: path-problem
    problem.severity: error
    precision: high
    security-severity: 9.3
    id: py/template-injection
    tags: |-
      security
             external/cwe/cwe-074
  queryHelp: "# Server Side Template Injection\nA template from a server templating\
    \ engine such as Jinja constructed from user input can allow the user to execute\
    \ arbitrary code using certain template features. It can also allow for cross-site\
    \ scripting.\n\n\n## Recommendation\nEnsure that an untrusted value is not used\
    \ to directly construct a template. Jinja also provides `SandboxedEnvironment`\
    \ that prohibits access to unsafe methods and attributes. This can be used if\
    \ constructing a template from user input is absolutely necessary.\n\n\n## Example\n\
    In the following case, `template` is used to generate a Jinja2 template string.\
    \ This can lead to remote code execution.\n\n\n```python\nfrom django.urls import\
    \ path\nfrom django.http import HttpResponse\nfrom jinja2 import Template, escape\n\
    \n\ndef a(request):\n    template = request.GET['template']\n\n    # BAD: Template\
    \ is constructed from user input. \n    t = Template(template)\n\n    name = request.GET['name']\n\
    \    html = t.render(name=escape(name))\n    return HttpResponse(html)\n\n\nurlpatterns\
    \ = [\n    path('a', a),\n]\n```\nThe following is an example of a string that\
    \ could be used to cause remote code execution when interpreted as a template:\n\
    \n\n```txt\n{% for s in ().__class__.__base__.__subclasses__() %}{% if \"warning\"\
    \ in s.__name__ %}{{s()._module.__builtins__['__import__']('os').system('cat /etc/passwd')\
    \ }}{% endif %}{% endfor %}\n\n```\nIn the following case, user input is not used\
    \ to construct the template. Instead, it is only used as the parameters to render\
    \ the template, which is safe.\n\n\n```python\nfrom django.urls import path\n\
    from django.http import HttpResponse\nfrom jinja2 import Template, escape\n\n\n\
    def a(request):\n    # GOOD: Template is a constant, not constructed from user\
    \ input\n    t = Template(\"Hello, {{name}}!\")\n\n    name = request.GET['name']\n\
    \    html = t.render(name=escape(name))\n    return HttpResponse(html)\n\n\nurlpatterns\
    \ = [\n    path('a', a),\n]\n```\nIn the following case, a `SandboxedEnvironment`\
    \ is used, preventing remote code execution.\n\n\n```python\nfrom django.urls\
    \ import path\nfrom django.http import HttpResponse\nfrom jinja2 import escape\n\
    from jinja2.sandbox import SandboxedEnvironment\n\n\ndef a(request):\n    env\
    \ = SandboxedEnvironment()\n    template = request.GET['template']\n\n    # GOOD:\
    \ A sandboxed environment is used to construct the template. \n    t = env.from_string(template)\n\
    \n    name = request.GET['name']\n    html = t.render(name=escape(name))\n   \
    \ return HttpResponse(html)\n\n\nurlpatterns = [\n    path('a', a),\n]\n```\n\n\
    ## References\n* Portswigger: [Server-Side Template Injection](https://portswigger.net/web-security/server-side-template-injection).\n\
    * Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-078/CommandInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-078/CommandInjection.bqrs
  metadata:
    name: Uncontrolled command line
    description: |-
      Using externally controlled strings in a command line may allow a malicious
                    user to change the meaning of the command.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    sub-severity: high
    precision: high
    id: py/command-line-injection
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Uncontrolled command line
    Code that passes user input directly to `exec`, `eval`, or some other library routine that executes a command, allows the user to execute malicious code.


    ## Recommendation
    If possible, use hard-coded string literals to specify the command to run or the library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.

    If the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.


    ## Example
    The following example shows two functions. The first is unsafe as it takes a shell script that can be changed by a user, and passes it straight to `subprocess.call()` without examining it first. The second is safe as it selects the command from a predefined allowlist.


    ```python

    urlpatterns = [
        # Route to command_execution
        url(r'^command-ex1$', command_execution_unsafe, name='command-execution-unsafe'),
        url(r'^command-ex2$', command_execution_safe, name='command-execution-safe')
    ]

    COMMANDS = {
        "list" :"ls",
        "stat" : "stat"
    }

    def command_execution_unsafe(request):
        if request.method == 'POST':
            action = request.POST.get('action', '')
            #BAD -- No sanitizing of input
            subprocess.call(["application", action])

    def command_execution_safe(request):
        if request.method == 'POST':
            action = request.POST.get('action', '')
            #GOOD -- Use an allowlist
            subprocess.call(["application", COMMANDS[action]])

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-078/UnsafeShellCommandConstruction.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-078/UnsafeShellCommandConstruction.bqrs
  metadata:
    name: Unsafe shell command constructed from library input
    description: |-
      Using externally controlled strings in a command line may allow a malicious
                    user to change the meaning of the command.
    kind: path-problem
    problem.severity: error
    security-severity: 6.3
    precision: medium
    id: py/shell-command-constructed-from-input
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
             external/cwe/cwe-073
  queryHelp: "# Unsafe shell command constructed from library input\nDynamically constructing\
    \ a shell command with inputs from library functions may inadvertently change\
    \ the meaning of the shell command. Clients using the exported function may use\
    \ inputs containing characters that the shell interprets in a special way, for\
    \ instance quotes and spaces. This can result in the shell command misbehaving,\
    \ or even allowing a malicious user to execute arbitrary commands on the system.\n\
    \n\n## Recommendation\nIf possible, provide the dynamic arguments to the shell\
    \ as an array to APIs such as `subprocess.run` to avoid interpretation by the\
    \ shell.\n\nAlternatively, if the shell command must be constructed dynamically,\
    \ then add code to ensure that special characters do not alter the shell command\
    \ unexpectedly.\n\n\n## Example\nThe following example shows a dynamically constructed\
    \ shell command that downloads a file from a remote URL.\n\n\n```python\nimport\
    \ os\n\ndef download(path): \n    os.system(\"wget \" + path) # NOT OK\n\n```\n\
    The shell command will, however, fail to work as intended if the input contains\
    \ spaces or other special characters interpreted in a special way by the shell.\n\
    \nEven worse, a client might pass in user-controlled data, not knowing that the\
    \ input is interpreted as a shell command. This could allow a malicious user to\
    \ provide the input `http://example.org; cat /etc/passwd` in order to execute\
    \ the command `cat /etc/passwd`.\n\nTo avoid such potentially catastrophic behaviors,\
    \ provide the input from library functions as an argument that does not get interpreted\
    \ by a shell:\n\n\n```python\nimport subprocess\n\ndef download(path): \n    subprocess.run([\"\
    wget\", path]) # OK\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n\
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n\
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n\
    * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-079/Jinja2WithoutEscaping.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-079/Jinja2WithoutEscaping.bqrs
  metadata:
    name: Jinja2 templating with autoescape=False
    description: |-
      Using jinja2 templates with 'autoescape=False' can
                    cause a cross-site scripting vulnerability.
    kind: problem
    problem.severity: error
    security-severity: 6.1
    precision: medium
    id: py/jinja2/autoescape-false
    tags: |-
      security
             external/cwe/cwe-079
  queryHelp: |
    # Jinja2 templating with autoescape=False
    Cross-site scripting (XSS) attacks can occur if untrusted input is not escaped. This applies to templates as well as code. The `jinja2` templates may be vulnerable to XSS if the environment has `autoescape` set to `False`. Unfortunately, `jinja2` sets `autoescape` to `False` by default. Explicitly setting `autoescape` to `True` when creating an `Environment` object will prevent this.


    ## Recommendation
    Avoid setting jinja2 autoescape to False. Jinja2 provides the function `select_autoescape` to make sure that the correct auto-escaping is chosen. For example, it can be used when creating an environment `Environment(autoescape=select_autoescape(['html', 'xml'])`


    ## Example
    The following example is a minimal Flask app which shows a safe and an unsafe way to render the given name back to the page. The first view is unsafe as `first_name` is not escaped, leaving the page vulnerable to cross-site scripting attacks. The second view is safe as `first_name` is escaped, so it is not vulnerable to cross-site scripting attacks.


    ```python
    from flask import Flask, request, make_response, escape
    from jinja2 import Environment, select_autoescape, FileSystemLoader

    app = Flask(__name__)
    loader = FileSystemLoader( searchpath="templates/" )

    unsafe_env = Environment(loader=loader)
    safe1_env = Environment(loader=loader, autoescape=True)
    safe2_env = Environment(loader=loader, autoescape=select_autoescape())

    def render_response_from_env(env):
        name = request.args.get('name', '')
        template = env.get_template('template.html')
        return make_response(template.render(name=name))

    @app.route('/unsafe')
    def unsafe():
        return render_response_from_env(unsafe_env)

    @app.route('/safe1')
    def safe1():
        return render_response_from_env(safe1_env)

    @app.route('/safe2')
    def safe2():
        return render_response_from_env(safe2_env)


    ```

    ## References
    * Jinja2: [API](http://jinja.pocoo.org/docs/2.10/api/).
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-079/ReflectedXss.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-079/ReflectedXss.bqrs
  metadata:
    name: Reflected server-side cross-site scripting
    description: |-
      Writing user input directly to a web page
                    allows for a cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    sub-severity: high
    precision: high
    id: py/reflective-xss
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Reflected server-side cross-site scripting
    Directly writing user input (for example, an HTTP request parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.


    ## Recommendation
    To guard against cross-site scripting, consider escaping the input before writing user input to the page. The standard library provides escaping functions: `html.escape()` for Python 3.2 upwards or `cgi.escape()` older versions of Python. Most frameworks also provide their own escaping functions, for example `flask.escape()`.


    ## Example
    The following example is a minimal flask app which shows a safe and unsafe way to render the given name back to the page. The first view is unsafe as `first_name` is not escaped, leaving the page vulnerable to cross-site scripting attacks. The second view is safe as `first_name` is escaped, so it is not vulnerable to cross-site scripting attacks.


    ```python
    from flask import Flask, request, make_response, escape

    app = Flask(__name__)

    @app.route('/unsafe')
    def unsafe():
        first_name = request.args.get('name', '')
        return make_response("Your name is " + first_name)

    @app.route('/safe')
    def safe():
        first_name = request.args.get('name', '')
        return make_response("Your name is " + escape(first_name))

    ```

    ## References
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
    * Python Library Reference: [html.escape()](https://docs.python.org/3/library/html.html#html.escape).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-089/SqlInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-089/SqlInjection.bqrs
  metadata:
    name: SQL query built from user-controlled sources
    description: |-
      Building a SQL query from user-controlled sources is vulnerable to insertion of
                    malicious SQL code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 8.8
    precision: high
    id: py/sql-injection
    tags: |-
      security
             external/cwe/cwe-089
  queryHelp: |
    # SQL query built from user-controlled sources
    If a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a user may be able to run malicious database queries.

    This also includes using the `TextClause` class in the `[SQLAlchemy](https://pypi.org/project/SQLAlchemy/)` PyPI package, which is used to represent a literal SQL fragment and is inserted directly into the final SQL when used in a query built using the ORM.


    ## Recommendation
    Most database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.


    ## Example
    In the following snippet, a user is fetched from the database using three different queries.

    In the first case, the query string is built by directly using string formatting from a user-supplied request parameter. The parameter may include quote characters, so this code is vulnerable to a SQL injection attack.

    In the second case, the user-supplied request attribute is passed to the database using query parameters. The database connector library will take care of escaping and inserting quotes as needed.

    In the third case, the placeholder in the SQL string has been manually quoted. Since most databaseconnector libraries will insert their own quotes, doing so yourself will make the code vulnerable to SQL injection attacks. In this example, if `username` was `; DROP ALL TABLES -- `, the final SQL query would be `SELECT * FROM users WHERE username = ''; DROP ALL TABLES -- ''`


    ```python
    from django.conf.urls import url
    from django.db import connection


    def show_user(request, username):
        with connection.cursor() as cursor:
            # BAD -- Using string formatting
            cursor.execute("SELECT * FROM users WHERE username = '%s'" % username)
            user = cursor.fetchone()

            # GOOD -- Using parameters
            cursor.execute("SELECT * FROM users WHERE username = %s", username)
            user = cursor.fetchone()

            # BAD -- Manually quoting placeholder (%s)
            cursor.execute("SELECT * FROM users WHERE username = '%s'", username)
            user = cursor.fetchone()

    urlpatterns = [url(r'^users/(?P<username>[^/]+)$', show_user)]

    ```

    ## References
    * Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).
    * OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).
    * [SQLAlchemy documentation for TextClause](https://docs.sqlalchemy.org/en/14/core/sqlelement.html#sqlalchemy.sql.expression.text.params.text).
    * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-090/LdapInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-090/LdapInjection.bqrs
  metadata:
    name: LDAP query built from user-controlled sources
    description: |-
      Building an LDAP query from user-controlled sources is vulnerable to insertion of
                    malicious LDAP code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: py/ldap-injection
    tags: |-
      security
             external/cwe/cwe-090
  queryHelp: |
    # LDAP query built from user-controlled sources
    If an LDAP query or DN is built using string concatenation or string formatting, and the components of the concatenation include user input without any proper sanitization, a user is likely to be able to run malicious LDAP queries.


    ## Recommendation
    If user input must be included in an LDAP query or DN, it should be escaped to avoid a malicious user providing special characters that change the meaning of the query. In Python2, user input should be escaped with `ldap.dn.escape_dn_chars` or `ldap.filter.escape_filter_chars`, while in Python3, user input should be escaped with `ldap3.utils.dn.escape_rdn` or `ldap3.utils.conv.escape_filter_chars` depending on the component tainted by the user. A good practice is to escape filter characters that could change the meaning of the query (https://tools.ietf.org/search/rfc4515\#section-3).


    ## Example
    In the following examples, the code accepts both `username` and `dc` from the user, which it then uses to build a LDAP query and DN.

    The first and the second example uses the unsanitized user input directly in the search filter and DN for the LDAP query. A malicious user could provide special characters to change the meaning of these components, and search for a completely different set of values.


    ```python
    from flask import request, Flask
    import ldap


    @app.route("/normal")
    def normal():
        unsafe_dc = request.args['dc']
        unsafe_filter = request.args['username']

        dn = "dc={}".format(unsafe_dc)
        search_filter = "(user={})".format(unsafe_filter)

        ldap_connection = ldap.initialize("ldap://127.0.0.1")
        user = ldap_connection.search_s(
            dn, ldap.SCOPE_SUBTREE, search_filter)

    ```

    ```python
    from flask import request, Flask
    import ldap3


    @app.route("/normal")
    def normal():
        unsafe_dc = request.args['dc']
        unsafe_filter = request.args['username']

        dn = "dc={}".format(unsafe_dc)
        search_filter = "(user={})".format(unsafe_filter)

        srv = ldap3.Server('ldap://127.0.0.1')
        conn = ldap3.Connection(srv, user=dn, auto_bind=True)
        conn.search(dn, search_filter)

    ```
    In the third and fourth example, the input provided by the user is sanitized before it is included in the search filter or DN. This ensures the meaning of the query cannot be changed by a malicious user.


    ```python
    from flask import request, Flask
    import ldap
    import ldap.filter
    import ldap.dn


    @app.route("/normal")
    def normal():
        unsafe_dc = request.args['dc']
        unsafe_filter = request.args['username']

        safe_dc = ldap.dn.escape_dn_chars(unsafe_dc)
        safe_filter = ldap.filter.escape_filter_chars(unsafe_filter)

        dn = "dc={}".format(safe_dc)
        search_filter = "(user={})".format(safe_filter)

        ldap_connection = ldap.initialize("ldap://127.0.0.1")
        user = ldap_connection.search_s(
            dn, ldap.SCOPE_SUBTREE, search_filter)

    ```

    ```python
    from flask import request, Flask
    import ldap3
    from ldap3.utils.dn import escape_rdn
    from ldap3.utils.conv import escape_filter_chars


    @app.route("/normal")
    def normal():
        unsafe_dc = request.args['dc']
        unsafe_filter = request.args['username']

        safe_dc = escape_rdn(unsafe_dc)
        safe_filter = escape_filter_chars(unsafe_filter)

        dn = "dc={}".format(safe_dc)
        search_filter = "(user={})".format(safe_filter)

        srv = ldap3.Server('ldap://127.0.0.1')
        conn = ldap3.Connection(srv, user=dn, auto_bind=True)
        conn.search(dn, search_filter)

    ```

    ## References
    * OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).
    * OWASP: [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection).
    * SonarSource: [RSPEC-2078](https://rules.sonarsource.com/python/RSPEC-2078).
    * Python2: [LDAP Documentation](https://www.python-ldap.org/en/python-ldap-3.3.0/reference/ldap.html).
    * Python3: [LDAP Documentation](https://ldap3.readthedocs.io/en/latest/).
    * Wikipedia: [LDAP injection](https://en.wikipedia.org/wiki/LDAP_injection).
    * BlackHat: [LDAP Injection and Blind LDAP Injection](https://www.blackhat.com/presentations/bh-europe-08/Alonso-Parada/Whitepaper/bh-eu-08-alonso-parada-WP.pdf).
    * LDAP: [Understanding and Defending Against LDAP Injection Attacks](https://ldap.com/2018/05/04/understanding-and-defending-against-ldap-injection-attacks/).
    * Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-094/CodeInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-094/CodeInjection.bqrs
  metadata:
    name: Code injection
    description: |-
      Interpreting unsanitized user input as code allows a malicious user to perform arbitrary
                    code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    sub-severity: high
    precision: high
    id: py/code-injection
    tags: |-
      security
             external/cwe/cwe-094
             external/cwe/cwe-095
             external/cwe/cwe-116
  queryHelp: |
    # Code injection
    Directly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is passed to code that interprets it as an expression to be evaluated, such as `eval` or `exec`.


    ## Recommendation
    Avoid including user input in any expression that may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.


    ## Example
    The following example shows two functions setting a name from a request. The first function uses `exec` to execute the `setname` function. This is dangerous as it can allow a malicious user to execute arbitrary code on the server. For example, the user could supply the value `"' + subprocess.call('rm -rf') + '"` to destroy the server's file system. The second function calls the `setname` function directly and is thus safe.


    ```python

    urlpatterns = [
        # Route to code_execution
        url(r'^code-ex1$', code_execution_bad, name='code-execution-bad'),
        url(r'^code-ex2$', code_execution_good, name='code-execution-good')
    ]

    def code_execution(request):
        if request.method == 'POST':
            first_name = base64.decodestring(request.POST.get('first_name', ''))
            #BAD -- Allow user to define code to be run.
            exec("setname('%s')" % first_name)

    def code_execution(request):
        if request.method == 'POST':
            first_name = base64.decodestring(request.POST.get('first_name', ''))
            #GOOD --Call code directly
            setname(first_name)

    ```

    ## References
    * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
    * Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-113/HeaderInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-113/HeaderInjection.bqrs
  metadata:
    name: HTTP Response Splitting
    description: |-
      Writing user input directly to an HTTP header
                    makes code vulnerable to attack by header splitting.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: py/http-response-splitting
    tags: |-
      security
             external/cwe/cwe-113
             external/cwe/cwe-079
  queryHelp: "# HTTP Response Splitting\nDirectly writing user input (for example,\
    \ an HTTP request parameter) to an HTTP header can lead to an HTTP response-splitting\
    \ vulnerability.\n\nIf user-controlled input is used in an HTTP header that allows\
    \ line break characters, an attacker can inject additional headers or control\
    \ the response body, leading to vulnerabilities such as XSS or cache poisoning.\n\
    \n\n## Recommendation\nEnsure that user input containing line break characters\
    \ is not written to an HTTP header.\n\n\n## Example\nIn the following example,\
    \ the case marked BAD writes user input to the header name. In the GOOD case,\
    \ input is first escaped to not contain any line break characters.\n\n\n```python\n\
    @app.route(\"/example_bad\")\ndef example_bad():\n    rfs_header = request.args[\"\
    rfs_header\"]\n    response = Response()\n    custom_header = \"X-MyHeader-\"\
    \ + rfs_header\n    # BAD: User input is used as part of the header name.\n  \
    \  response.headers[custom_header] = \"HeaderValue\" \n    return response\n\n\
    @app.route(\"/example_good\")\ndef example_bad():\n    rfs_header = request.args[\"\
    rfs_header\"]\n    response = Response()\n    custom_header = \"X-MyHeader-\"\
    \ + rfs_header.replace(\"\\n\", \"\").replace(\"\\r\",\"\").replace(\":\",\"\"\
    )\n    # GOOD: Line break characters are removed from the input.\n    response.headers[custom_header]\
    \ = \"HeaderValue\" \n    return response\n```\n\n## References\n* SecLists.org:\
    \ [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n* OWASP:\
    \ [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n\
    * Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n\
    * CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n\
    * Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-116/BadTagFilter.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-116/BadTagFilter.bqrs
  metadata:
    name: Bad HTML filtering regexp
    description: "Matching HTML tags using regular expressions is hard to do right,\
      \ and can easily lead to security issues."
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: py/bad-tag-filter
    tags: |-
      correctness
             security
             external/cwe/cwe-116
             external/cwe/cwe-020
             external/cwe/cwe-185
             external/cwe/cwe-186
  queryHelp: "# Bad HTML filtering regexp\nIt is possible to match some single HTML\
    \ tags using regular expressions (parsing general HTML using regular expressions\
    \ is impossible). However, if the regular expression is not written well it might\
    \ be possible to circumvent it, which can lead to cross-site scripting or other\
    \ security issues.\n\nSome of these mistakes are caused by browsers having very\
    \ forgiving HTML parsers, and will often render invalid HTML containing syntax\
    \ errors. Regular expressions that attempt to match HTML should also recognize\
    \ tags containing such syntax errors.\n\n\n## Recommendation\nUse a well-tested\
    \ sanitization or parser library if at all possible. These libraries are much\
    \ more likely to handle corner cases correctly than a custom implementation.\n\
    \n\n## Example\nThe following example attempts to filters out all `<script>` tags.\n\
    \n\n```python\nimport re\n\ndef filterScriptTags(content): \n    oldContent =\
    \ \"\"\n    while oldContent != content:\n        oldContent = content\n     \
    \   content = re.sub(r'<script.*?>.*?</script>', '', content, flags= re.DOTALL\
    \ | re.IGNORECASE)\n    return content\n```\nThe above sanitizer does not filter\
    \ out all `<script>` tags. Browsers will not only accept `</script>` as script\
    \ end tags, but also tags such as `</script foo=\"bar\">` even though it is a\
    \ parser error. This means that an attack string such as `<script>alert(1)</script\
    \ foo=\"bar\">` will not be filtered by the function, and `alert(1)` will be executed\
    \ by a browser if the string is rendered as HTML.\n\nOther corner cases include\
    \ that HTML comments can end with `--!>`, and that HTML tag names can contain\
    \ upper case characters.\n\n\n## References\n* Securitum: [The Curious Case of\
    \ Copy &amp; Paste](https://research.securitum.com/the-curious-case-of-copy-paste/).\n\
    * stackoverflow.com: [You can't parse \\[X\\]HTML with regex](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#answer-1732454).\n\
    * HTML Standard: [Comment end bang state](https://html.spec.whatwg.org/multipage/parsing.html#comment-end-bang-state).\n\
    * stackoverflow.com: [Why aren't browsers strict about HTML?](https://stackoverflow.com/questions/25559999/why-arent-browsers-strict-about-html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n\
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n\
    * Common Weakness Enumeration: [CWE-185](https://cwe.mitre.org/data/definitions/185.html).\n\
    * Common Weakness Enumeration: [CWE-186](https://cwe.mitre.org/data/definitions/186.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-117/LogInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-117/LogInjection.bqrs
  metadata:
    name: Log Injection
    description: |-
      Building log entries from user-controlled data is vulnerable to
                    insertion of forged log entries by a malicious user.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: medium
    id: py/log-injection
    tags: |-
      security
             external/cwe/cwe-117
  queryHelp: |
    # Log Injection
    If unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.

    Forgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user to create the appearance of multiple log entries. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.


    ## Recommendation
    User input should be suitably sanitized before it is logged.

    If the log entries are plain text then line breaks should be removed from user input, using for example `replace(old, new)` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.

    For log entries that will be displayed in HTML, user input should be HTML encoded before being logged, to prevent forgery and other forms of HTML injection.


    ## Example
    In the example, the name provided by the user is recorded using the log output function (`logging.info` or `app.logger.info`, etc.). In these four cases, the name provided by the user is not provided The processing is recorded. If a malicious user provides `Guest%0D%0AUser name: Admin` as a parameter, the log entry will be divided into two lines, the first line is `User name: Guest` code&gt;, the second line is `User name: Admin`.


    ```python
    #!/usr/bin/env python
    # -*- coding: UTF-8 -*-
    """
    @Desc   Log Injection
    """
    from flask import Flask
    from flask import request
    from django.utils.log import request_logger
    import logging

    logging.basicConfig(level=logging.DEBUG)

    app = Flask(__name__)

    @app.route('/bad1')
    def bad1():
        name = request.args.get('name')
        app.logger.info('User name: ' + name) # Bad
        return 'bad1'

    @app.route('/bad2')
    def bad2():
        name = request.args.get('name')
        logging.info('User name: ' + name) # Bad
        return 'bad2'

    @app.route('/bad3')
    def bad3():
        name = request.args.get('name')
        request_logger.warn('User name: ' + name) # Bad
        return 'bad3'

    @app.route('/bad4')
    def bad4():
        name = request.args.get('name')
        logtest = logging.getLogger('test')
        logtest.debug('User name: ' + name) # Bad
        return 'bad4'

    if __name__ == '__main__':
        app.debug = True
        handler = logging.FileHandler('log')
        app.logger.addHandler(handler)
        app.run()

    ```
    In a good example, the program uses the `replace` function to provide parameter processing to the user, and replace `\r\n` and `\n` with empty characters. To a certain extent, the occurrence of log injection vulnerabilities is reduced.


    ```python
    #!/usr/bin/env python
    # -*- coding: UTF-8 -*-
    """
    @Desc   Log Injection
    """
    from flask import Flask
    from flask import request
    import logging

    logging.basicConfig(level=logging.DEBUG)

    app = Flask(__name__)

    @app.route('/good1')
    def good1():
        name = request.args.get('name')
        name = name.replace('\r\n','').replace('\n','')
        logging.info('User name: ' + name) # Good
        return 'good1'

    if __name__ == '__main__':
        app.debug = True
        handler = logging.FileHandler('log')
        app.logger.addHandler(handler)
        app.run()

    ```

    ## References
    * OWASP: [Log Injection](https://owasp.org/www-community/attacks/Log_Injection).
    * Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-209/StackTraceExposure.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-209/StackTraceExposure.bqrs
  metadata:
    name: Information exposure through an exception
    description: |-
      Leaking information about an exception, such as messages and stack traces, to an
                    external user can expose implementation details that are useful to an attacker for
                    developing a subsequent exploit.
    kind: path-problem
    problem.severity: error
    security-severity: 5.4
    precision: high
    id: py/stack-trace-exposure
    tags: |-
      security
             external/cwe/cwe-209
             external/cwe/cwe-497
  queryHelp: |
    # Information exposure through an exception
    Software developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.

    Unfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.


    ## Recommendation
    Send the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.


    ## Example
    In the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user by returning it from the function. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server, and a generic error message is displayed to the user. That way, the developers can still access and use the error log, but remote users will not see the information.


    ```python
    from flask import Flask
    app = Flask(__name__)


    import traceback

    def do_computation():
        raise Exception("Secret info")

    # BAD
    @app.route('/bad')
    def server_bad():
        try:
            do_computation()
        except Exception as e:
            return traceback.format_exc()

    # GOOD
    @app.route('/good')
    def server_good():
        try:
            do_computation()
        except Exception as e:
            log(traceback.format_exc())
            return "An internal error has occurred!"

    ```

    ## References
    * OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).
    * Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).
    * Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-215/FlaskDebug.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-215/FlaskDebug.bqrs
  metadata:
    name: Flask app is run in debug mode
    description: Running a Flask app in debug mode may allow an attacker to run arbitrary
      code through the Werkzeug debugger.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/flask-debug
    tags: |-
      security
             external/cwe/cwe-215
             external/cwe/cwe-489
  queryHelp: |
    # Flask app is run in debug mode
    Running a Flask application with debug mode enabled may allow an attacker to gain access through the Werkzeug debugger.


    ## Recommendation
    Ensure that Flask applications that are run in a production environment have debugging disabled.


    ## Example
    Running the following code starts a Flask webserver that has debugging enabled. By visiting `/crash`, it is possible to gain access to the debugger, and run arbitrary code through the interactive debugger.


    ```python
    from flask import Flask

    app = Flask(__name__)

    @app.route('/crash')
    def main():
        raise Exception()

    app.run(debug=True)

    ```

    ## References
    * Flask Quickstart Documentation: [Debug Mode](http://flask.pocoo.org/docs/1.0/quickstart/#debug-mode).
    * Werkzeug Documentation: [Debugging Applications](http://werkzeug.pocoo.org/docs/0.14/debug/).
    * Common Weakness Enumeration: [CWE-215](https://cwe.mitre.org/data/definitions/215.html).
    * Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-285/PamAuthorization.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-285/PamAuthorization.bqrs
  metadata:
    name: PAM authorization bypass due to incorrect usage
    description: Not using `pam_acct_mgmt` after `pam_authenticate` to check the validity
      of a login can lead to authorization bypass.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.1
    precision: high
    id: py/pam-auth-bypass
    tags: |-
      security
             external/cwe/cwe-285
  queryHelp: |
    # PAM authorization bypass due to incorrect usage
    Using only a call to `pam_authenticate` to check the validity of a login can lead to authorization bypass vulnerabilities.

    A `pam_authenticate` only verifies the credentials of a user. It does not check if a user has an appropriate authorization to actually login. This means a user with an expired login or a password can still access the system.


    ## Recommendation
    A call to `pam_authenticate` should be followed by a call to `pam_acct_mgmt` to check if a user is allowed to login.


    ## Example
    In the following example, the code only checks the credentials of a user. Hence, in this case, a user with expired credentials can still login. This can be verified by creating a new user account, expiring it with ``` chage -E0 `username`  ``` and then trying to log in.


    ```python
    libpam                    = CDLL(find_library("pam"))

    pam_authenticate          = libpam.pam_authenticate
    pam_authenticate.restype  = c_int
    pam_authenticate.argtypes = [PamHandle, c_int]

    def authenticate(username, password, service='login'):
        def my_conv(n_messages, messages, p_response, app_data):
            """
            Simple conversation function that responds to any prompt where the echo is off with the supplied password
            """
            ...

        handle = PamHandle()
        conv   = PamConv(my_conv, 0)
        retval = pam_start(service, username, byref(conv), byref(handle))

        retval = pam_authenticate(handle, 0)
        return retval == 0

    ```
    This can be avoided by calling `pam_acct_mgmt` call to verify access as has been done in the snippet shown below.


    ```python
    libpam                    = CDLL(find_library("pam"))

    pam_authenticate          = libpam.pam_authenticate
    pam_authenticate.restype  = c_int
    pam_authenticate.argtypes = [PamHandle, c_int]

    pam_acct_mgmt          = libpam.pam_acct_mgmt
    pam_acct_mgmt.restype  = c_int
    pam_acct_mgmt.argtypes = [PamHandle, c_int]

    def authenticate(username, password, service='login'):
        def my_conv(n_messages, messages, p_response, app_data):
            """
            Simple conversation function that responds to any prompt where the echo is off with the supplied password
            """
            ...

        handle = PamHandle()
        conv   = PamConv(my_conv, 0)
        retval = pam_start(service, username, byref(conv), byref(handle))

        retval = pam_authenticate(handle, 0)
        if retval == 0:
            retval = pam_acct_mgmt(handle, 0)
        return retval == 0

    ```

    ## References
    * Man-Page: [pam_acct_mgmt](https://man7.org/linux/man-pages/man3/pam_acct_mgmt.3.html)
    * Common Weakness Enumeration: [CWE-285](https://cwe.mitre.org/data/definitions/285.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-295/MissingHostKeyValidation.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-295/MissingHostKeyValidation.bqrs
  metadata:
    name: Accepting unknown SSH host keys when using Paramiko
    description: Accepting unknown host keys can allow man-in-the-middle attacks.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/paramiko-missing-host-key-validation
    tags: |-
      security
             external/cwe/cwe-295
  queryHelp: |
    # Accepting unknown SSH host keys when using Paramiko
    In the Secure Shell (SSH) protocol, host keys are used to verify the identity of remote hosts. Accepting unknown host keys may leave the connection open to man-in-the-middle attacks.


    ## Recommendation
    Do not accept unknown host keys. In particular, do not set the default missing host key policy for the Paramiko library to either `AutoAddPolicy` or `WarningPolicy`. Both of these policies continue even when the host key is unknown. The default setting of `RejectPolicy` is secure because it throws an exception when it encounters an unknown host key.


    ## Example
    The following example shows two ways of opening an SSH connection to `example.com`. The first function sets the missing host key policy to `AutoAddPolicy`. If the host key verification fails, the client will continue to interact with the server, even though the connection may be compromised. The second function sets the host key policy to `RejectPolicy`, and will throw an exception if the host key verification fails.


    ```python
    from paramiko.client import SSHClient, AutoAddPolicy, RejectPolicy

    def unsafe_connect():
        client = SSHClient()
        client.set_missing_host_key_policy(AutoAddPolicy)
        client.connect("example.com")

        # ... interaction with server

        client.close()

    def safe_connect():
        client = SSHClient()
        client.set_missing_host_key_policy(RejectPolicy)
        client.connect("example.com")

        # ... interaction with server

        client.close()

    ```

    ## References
    * Paramiko documentation: [set_missing_host_key_policy](http://docs.paramiko.org/en/2.4/api/client.html?highlight=set_missing_host_key_policy#paramiko.client.SSHClient.set_missing_host_key_policy).
    * Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-295/RequestWithoutValidation.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-295/RequestWithoutValidation.bqrs
  metadata:
    name: Request without certificate validation
    description: Making a request without certificate validation can allow man-in-the-middle
      attacks.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: medium
    id: py/request-without-cert-validation
    tags: |-
      security
             external/cwe/cwe-295
  queryHelp: |
    # Request without certificate validation
    Encryption is key to the security of most, if not all, online communication. Using Transport Layer Security (TLS) can ensure that communication cannot be interrupted by an interloper. For this reason, it is unwise to disable the verification that TLS provides. Functions in the `requests` module provide verification by default, and it is only when explicitly turned off using `verify=False` that no verification occurs.


    ## Recommendation
    Never use `verify=False` when making a request.


    ## Example
    The example shows two unsafe calls to [semmle.com](https://semmle.com), followed by various safe alternatives.


    ```python
    import requests

    #Unsafe requests

    requests.get('https://semmle.com', verify=False) # UNSAFE
    requests.get('https://semmle.com', verify=0) # UNSAFE

    #Various safe options

    requests.get('https://semmle.com', verify=True) # Explicitly safe
    requests.get('https://semmle.com', verify="/path/to/cert/")
    requests.get('https://semmle.com') # The default is to verify.

    #Wrapper to ensure safety

    def make_safe_request(url, verify_cert):
        if not verify_cert:
            raise Exception("Trying to make unsafe request")
        return requests.get(url, verify_cert)

    ```

    ## References
    * Python requests documentation: [SSL Cert Verification](https://requests.readthedocs.io/en/latest/user/advanced/#ssl-cert-verification).
    * Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-312/CleartextLogging.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-312/CleartextLogging.bqrs
  metadata:
    name: Clear-text logging of sensitive information
    description: |-
      Logging sensitive information without encryption or hashing can
                    expose it to an attacker.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/clear-text-logging-sensitive-data
    tags: |-
      security
             external/cwe/cwe-312
             external/cwe/cwe-359
             external/cwe/cwe-532
  queryHelp: |
    # Clear-text logging of sensitive information
    If sensitive data is written to a log entry it could be exposed to an attacker who gains access to the logs.

    Potential attackers can obtain sensitive user data when the log output is displayed. Additionally that data may expose system information such as full path names, system information, and sometimes usernames and passwords.


    ## Recommendation
    Sensitive data should not be logged.


    ## Example
    In the example the entire process environment is logged using \`print\`. Regular users of the production deployed application should not have access to this much information about the environment configuration.


    ```python
    # BAD: Logging cleartext sensitive data
    import os
    print(f"[INFO] Environment: {os.environ}")
    ```
    In the second example the data that is logged is not sensitive.


    ```python
    not_sensitive_data = {'a': 1, 'b': 2}
    # GOOD: it is fine to log data that is not sensitive
    print(f"[INFO] Some object contains: {not_sensitive_data}")
    ```

    ## References
    * OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
    * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
    * Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-312/CleartextStorage.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-312/CleartextStorage.bqrs
  metadata:
    name: Clear-text storage of sensitive information
    description: |-
      Sensitive information stored without encryption or hashing can expose it to an
                    attacker.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/clear-text-storage-sensitive-data
    tags: |-
      security
             external/cwe/cwe-312
             external/cwe/cwe-315
             external/cwe/cwe-359
  queryHelp: |
    # Clear-text storage of sensitive information
    Sensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.


    ## Recommendation
    Ensure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.

    In general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.

    Be aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.


    ## Example
    The following example code stores user credentials (in this case, their password) in a cookie in plain text:


    ```python
    from flask import Flask, make_response, request

    app = Flask("Leak password")

    @app.route('/')
    def index():
        password = request.args.get("password")
        resp = make_response(render_template(...))
        resp.set_cookie("password", password)
        return resp

    ```
    Instead, the credentials should be encrypted, for instance by using the `cryptography` module, or not stored at all.


    ## References
    * M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.
    * M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
    * Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).
    * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-326/WeakCryptoKey.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-326/WeakCryptoKey.bqrs
  metadata:
    name: Use of weak cryptographic key
    description: Use of a cryptographic key that is too small may allow the encryption
      to be broken.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/weak-crypto-key
    tags: |-
      security
             external/cwe/cwe-326
  queryHelp: |
    # Use of weak cryptographic key
    Modern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.

    The three main asymmetric key algorithms currently in use are RivestShamirAdleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.


    ## Recommendation
    Increase the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.


    ## References
    * Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).
    * Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).
    * Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).
    * Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).
    * NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).
    * Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-327/BrokenCryptoAlgorithm.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-327/BrokenCryptoAlgorithm.bqrs
  metadata:
    name: Use of a broken or weak cryptographic algorithm
    description: Using broken or weak cryptographic algorithms can compromise security.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: py/weak-cryptographic-algorithm
    tags: |-
      security
             external/cwe/cwe-327
  queryHelp: |
    # Use of a broken or weak cryptographic algorithm
    Using broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.

    Many cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.

    This query alerts on any use of a weak cryptographic algorithm, that is not a hashing algorithm. Use of broken or weak cryptographic hash functions are handled by the `py/weak-sensitive-data-hashing` query.


    ## Recommendation
    Ensure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.


    ## Example
    The following code uses the `pycryptodome` library to encrypt some secret data. When you create a cipher using `pycryptodome` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.


    ```python
    from Crypto.Cipher import DES, AES

    cipher = DES.new(SECRET_KEY)

    def send_encrypted(channel, message):
        channel.send(cipher.encrypt(message)) # BAD: weak encryption


    cipher = AES.new(SECRET_KEY)

    def send_encrypted(channel, message):
        channel.send(cipher.encrypt(message)) # GOOD: strong encryption


    ```
    NOTICE: the original `[pycrypto](https://pypi.org/project/pycrypto/)` PyPI package that provided the `Crypto` module is not longer actively maintained, so you should use the `[pycryptodome](https://pypi.org/project/pycryptodome/)` PyPI package instead (which has a compatible API).


    ## References
    * NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).
    * NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).
    * OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-327/InsecureDefaultProtocol.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-327/InsecureDefaultProtocol.bqrs
  metadata:
    name: Default version of SSL/TLS may be insecure
    description: |-
      Leaving the SSL/TLS version unspecified may result in an insecure
                    default protocol being used.
    id: py/insecure-default-protocol
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    tags: |-
      security
             external/cwe/cwe-327
  queryHelp: |
    # Default version of SSL/TLS may be insecure
    The `ssl.wrap_socket` function defaults to an insecure version of SSL/TLS when no specific protocol version is specified. This may leave the connection vulnerable to attack.


    ## Recommendation
    Ensure that a modern, strong protocol is used. All versions of SSL, and TLS 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended. If no explicit `ssl_version` is specified, the default `PROTOCOL_TLS` is chosen. This protocol is insecure because it allows TLS 1.0 and TLS 1.1 and so should not be used.


    ## Example
    The following code shows two different ways of setting up a connection using SSL or TLS. They are both potentially insecure because the default version is used.


    ```python
    import ssl
    import socket

    # Using the deprecated ssl.wrap_socket method
    ssl.wrap_socket(socket.socket())

    # Using SSLContext
    context = ssl.SSLContext()

    ```
    Both of the cases above should be updated to use a secure protocol instead, for instance by specifying `ssl_version=PROTOCOL_TLSv1_2` as a keyword argument.

    The latter example can also be made secure by modifying the created context before it is used to create a connection. Therefore it will not be flagged by this query. However, if a connection is created before the context has been secured (for example, by setting the value of `minimum_version`), then the code should be flagged by the query `py/insecure-protocol`.

    Note that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:

    * `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions
    * `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.
    Even when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \`minimum_version\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.


    ```python
    import ssl

    # Using flags to restrict the protocol
    context = ssl.SSLContext()
    context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1

    # Declaring a minimum version to restrict the protocol
    context = ssl.create_default_context()
    context.minimum_version = ssl.TLSVersion.TLSv1_2

    ```

    ## References
    * Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).
    * Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).
    * Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).
    * Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).
    * Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-327/InsecureProtocol.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-327/InsecureProtocol.bqrs
  metadata:
    name: Use of insecure SSL/TLS version
    description: Using an insecure SSL/TLS version may leave the connection vulnerable
      to attacks.
    id: py/insecure-protocol
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    tags: |-
      security
             external/cwe/cwe-327
  queryHelp: |
    # Use of insecure SSL/TLS version
    Using a broken or weak cryptographic protocol may make a connection vulnerable to interference from an attacker.


    ## Recommendation
    Ensure that a modern, strong protocol is used. All versions of SSL, and TLS versions 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended.


    ## Example
    The following code shows a variety of ways of setting up a connection using SSL or TLS. They are all insecure because of the version specified.


    ```python
    import ssl
    import socket

    # Using the deprecated ssl.wrap_socket method
    ssl.wrap_socket(socket.socket(), ssl_version=ssl.PROTOCOL_SSLv2)

    # Using SSLContext
    context = ssl.SSLContext(ssl_version=ssl.PROTOCOL_SSLv3)

    # Using pyOpenSSL

    from pyOpenSSL import SSL

    context = SSL.Context(SSL.TLSv1_METHOD)



    ```
    All cases should be updated to use a secure protocol, such as `PROTOCOL_TLSv1_2`.

    Note that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:

    * `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions
    * `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.
    Even when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \`minimum_version\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.


    ```python
    import ssl

    # Using flags to restrict the protocol
    context = ssl.SSLContext()
    context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1

    # Declaring a minimum version to restrict the protocol
    context = ssl.create_default_context()
    context.minimum_version = ssl.TLSVersion.TLSv1_2

    ```

    ## References
    * Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).
    * Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).
    * Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).
    * Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).
    * Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).
    * pyOpenSSL documentation: [ An interface to the SSL-specific parts of OpenSSL](https://pyopenssl.org/en/stable/api/ssl.html).
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-327/WeakSensitiveDataHashing.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-327/WeakSensitiveDataHashing.bqrs
  metadata:
    name: Use of a broken or weak cryptographic hashing algorithm on sensitive data
    description: Using broken or weak cryptographic hashing algorithms can compromise
      security.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: py/weak-sensitive-data-hashing
    tags: |-
      security
             external/cwe/cwe-327
             external/cwe/cwe-328
             external/cwe/cwe-916
  queryHelp: |
    # Use of a broken or weak cryptographic hashing algorithm on sensitive data
    Using a broken or weak cryptographic hash function can leave data vulnerable, and should not be used in security related code.

    A strong cryptographic hash function should be resistant to:

    * pre-image attacks: if you know a hash value `h(x)`, you should not be able to easily find the input `x`.
    * collision attacks: if you know a hash value `h(x)`, you should not be able to easily find a different input `y` with the same hash value `h(x) = h(y)`.
    In cases with a limited input space, such as for passwords, the hash function also needs to be computationally expensive to be resistant to brute-force attacks. Passwords should also have an unique salt applied before hashing, but that is not considered by this query.

    As an example, both MD5 and SHA-1 are known to be vulnerable to collision attacks.

    Since it's OK to use a weak cryptographic hash function in a non-security context, this query only alerts when these are used to hash sensitive data (such as passwords, certificates, usernames).

    Use of broken or weak cryptographic algorithms that are not hashing algorithms, is handled by the `py/weak-cryptographic-algorithm` query.


    ## Recommendation
    Ensure that you use a strong, modern cryptographic hash function:

    * such as Argon2, scrypt, bcrypt, or PBKDF2 for passwords and other data with limited input space.
    * such as SHA-2, or SHA-3 in other cases.

    ## Example
    The following example shows two functions for checking whether the hash of a certificate matches a known value -- to prevent tampering. The first function uses MD5 that is known to be vulnerable to collision attacks. The second function uses SHA-256 that is a strong cryptographic hashing function.


    ```python
    import hashlib

    def certificate_matches_known_hash_bad(certificate, known_hash):
        hash = hashlib.md5(certificate).hexdigest() # BAD
        return hash == known_hash

    def certificate_matches_known_hash_good(certificate, known_hash):
        hash = hashlib.sha256(certificate).hexdigest() # GOOD
        return hash == known_hash

    ```

    ## Example
    The following example shows two functions for hashing passwords. The first function uses SHA-256 to hash passwords. Although SHA-256 is a strong cryptographic hash function, it is not suitable for password hashing since it is not computationally expensive.


    ```python
    import hashlib

    def get_password_hash(password: str, salt: str):
        return hashlib.sha256(password + salt).hexdigest() # BAD

    ```
    The second function uses Argon2 (through the `argon2-cffi` PyPI package), which is a strong password hashing algorithm (and includes a per-password salt by default).


    ```python
    from argon2 import PasswordHasher

    def get_initial_hash(password: str):
        ph = PasswordHasher()
        return ph.hash(password) # GOOD

    def check_password(password: str, known_hash):
        ph = PasswordHasher()
        return ph.verify(known_hash, password) # GOOD

    ```

    ## References
    * OWASP: [Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
    * Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).
    * Common Weakness Enumeration: [CWE-916](https://cwe.mitre.org/data/definitions/916.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-352/CSRFProtectionDisabled.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-352/CSRFProtectionDisabled.bqrs
  metadata:
    name: CSRF protection weakened or disabled
    description: |-
      Disabling or weakening CSRF protection may make the application
                    vulnerable to a Cross-Site Request Forgery (CSRF) attack.
    kind: problem
    problem.severity: warning
    security-severity: 8.8
    precision: high
    id: py/csrf-protection-disabled
    tags: |-
      security
             external/cwe/cwe-352
  queryHelp: |
    # CSRF protection weakened or disabled
    Cross-site request forgery (CSRF) is a type of vulnerability in which an attacker is able to force a user to carry out an action that the user did not intend.

    The attacker tricks an authenticated user into submitting a request to the web application. Typically this request will result in a state change on the server, such as changing the user's password. The request can be initiated when the user visits a site controlled by the attacker. If the web application relies only on cookies for authentication, or on other credentials that are automatically included in the request, then this request will appear as legitimate to the server.

    A common countermeasure for CSRF is to generate a unique token to be included in the HTML sent from the server to a user. This token can be used as a hidden field to be sent back with requests to the server, where the server can then check that the token is valid and associated with the relevant user session.


    ## Recommendation
    In many web frameworks, CSRF protection is enabled by default. In these cases, using the default configuration is sufficient to guard against most CSRF attacks.


    ## Example
    The following example shows a case where CSRF protection is disabled by overriding the default middleware stack and not including the one protecting against CSRF.


    ```python
    MIDDLEWARE = [
        'django.middleware.security.SecurityMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        # 'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.middleware.clickjacking.XFrameOptionsMiddleware',
    ]

    ```
    The protecting middleware was probably commented out during a testing phase, when server-side token generation was not set up. Simply commenting it back in will enable CSRF protection.


    ## References
    * Wikipedia: [Cross-site request forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)
    * OWASP: [Cross-site request forgery](https://owasp.org/www-community/attacks/csrf)
    * Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-377/InsecureTemporaryFile.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-377/InsecureTemporaryFile.bqrs
  metadata:
    name: Insecure temporary file
    description: Creating a temporary file using this method may be insecure.
    kind: problem
    id: py/insecure-temporary-file
    problem.severity: error
    security-severity: 7.0
    sub-severity: high
    precision: high
    tags: |-
      external/cwe/cwe-377
             security
  queryHelp: |
    # Insecure temporary file
    Functions that create temporary file names (such as `tempfile.mktemp` and `os.tempnam`) are fundamentally insecure, as they do not ensure exclusive access to a file with the temporary name they return. The file name returned by these functions is guaranteed to be unique on creation but the file must be opened in a separate operation. There is no guarantee that the creation and open operations will happen atomically. This provides an opportunity for an attacker to interfere with the file before it is opened.

    Note that `mktemp` has been deprecated since Python 2.3.


    ## Recommendation
    Replace the use of `mktemp` with some of the more secure functions in the `tempfile` module, such as `TemporaryFile`. If the file is intended to be accessed from other processes, consider using the `NamedTemporaryFile` function.


    ## Example
    The following piece of code opens a temporary file and writes a set of results to it. Because the file name is created using `mktemp`, another process may access this file before it is opened using `open`.


    ```python
    from tempfile import mktemp

    def write_results(results):
        filename = mktemp()
        with open(filename, "w+") as f:
            f.write(results)
        print("Results written to", filename)

    ```
    By changing the code to use `NamedTemporaryFile` instead, the file is opened immediately.


    ```python
    from tempfile import NamedTemporaryFile

    def write_results(results):
        with NamedTemporaryFile(mode="w+", delete=False) as f:
            f.write(results)
        print("Results written to", f.name)

    ```

    ## References
    * Python Standard Library: [tempfile.mktemp](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp).
    * Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-502/UnsafeDeserialization.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-502/UnsafeDeserialization.bqrs
  metadata:
    name: Deserialization of user-controlled data
    description: Deserializing user-controlled data may allow attackers to execute
      arbitrary code.
    kind: path-problem
    id: py/unsafe-deserialization
    problem.severity: error
    security-severity: 9.8
    sub-severity: high
    precision: high
    tags: |-
      external/cwe/cwe-502
             security
             serialization
  queryHelp: |
    # Deserialization of user-controlled data
    Deserializing untrusted data using any deserialization framework that allows the construction of arbitrary serializable objects is easily exploitable and in many cases allows an attacker to execute arbitrary code. Even before a deserialized object is returned to the caller of a deserialization method a lot of code may have been executed, including static initializers, constructors, and finalizers. Automatic deserialization of fields means that an attacker may craft a nested combination of objects on which the executed initialization code may have unforeseen effects, such as the execution of arbitrary code.

    There are many different serialization frameworks. This query currently supports Pickle, Marshal and Yaml.


    ## Recommendation
    Avoid deserialization of untrusted data if at all possible. If the architecture permits it then use other formats instead of serialized objects, for example JSON.

    If you need to use YAML, use the `yaml.safe_load` function.


    ## Example
    The following example calls `pickle.loads` directly on a value provided by an incoming HTTP request. Pickle then creates a new value from untrusted data, and is therefore inherently unsafe.


    ```python

    from django.conf.urls import url
    import pickle

    def unsafe(pickled):
        return pickle.loads(pickled)

    urlpatterns = [
        url(r'^(?P<object>.*)$', unsafe)
    ]
    ```
    Changing the code to use `json.loads` instead of `pickle.loads` removes the vulnerability.


    ```python

    from django.conf.urls import url
    import json

    def safe(pickled):
        return json.loads(pickled)

    urlpatterns = [
        url(r'^(?P<object>.*)$', safe)
    ]

    ```

    ## References
    * OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).
    * OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).
    * Talks by Chris Frohoff &amp; Gabriel Lawrence: [ AppSecCali 2015: Marshalling Pickles - how deserializing objects will ruin your day](http://frohoff.github.io/appseccali-marshalling-pickles/)
    * Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-601/UrlRedirect.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-601/UrlRedirect.bqrs
  metadata:
    name: URL redirection from remote source
    description: |-
      URL redirection based on unvalidated user input
                    may cause redirection to malicious web sites.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    sub-severity: low
    id: py/url-redirection
    tags: |-
      security
             external/cwe/cwe-601
    precision: high
  queryHelp: |
    # URL redirection from remote source
    Directly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.


    ## Recommendation
    To guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.

    If this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL does not include an explicit host name.


    ## Example
    The following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:


    ```python
    from flask import Flask, request, redirect

    app = Flask(__name__)

    @app.route('/')
    def hello():
        target = request.args.get('target', '')
        return redirect(target, code=302)

    ```
    If you know the set of valid redirect targets, you can maintain a list of them on the server and check that the user input is in that list:


    ```python
    from flask import Flask, request, redirect

    VALID_REDIRECT = "http://cwe.mitre.org/data/definitions/601.html"

    app = Flask(__name__)

    @app.route('/')
    def hello():
        target = request.args.get('target', '')
        if target == VALID_REDIRECT:
            return redirect(target, code=302)
        else:
            # ignore the target and redirect to the home page
            return redirect('/', code=302)

    ```
    Often this is not possible, so an alternative is to check that the target URL does not specify an explicit host name. For example, you can use the `urlparse` function from the Python standard library to parse the URL and check that the `netloc` attribute is empty.

    Note, however, that some cases are not handled as we desire out-of-the-box by `urlparse`, so we need to adjust two things, as shown in the example below:

    * Many browsers accept backslash characters (`\`) as equivalent to forward slash characters (`/`) in URLs, but the `urlparse` function does not.
    * Mistyped URLs such as `https:/example.com` or `https:///example.com` are parsed as having an empty `netloc` attribute, while browsers will still redirect to the correct site.

    ```python
    from flask import Flask, request, redirect
    from urllib.parse import urlparse

    app = Flask(__name__)

    @app.route('/')
    def hello():
        target = request.args.get('target', '')
        target = target.replace('\\', '')
        if not urlparse(target).netloc and not urlparse(target).scheme:
            # relative path, safe to redirect
            return redirect(target, code=302)
        # ignore the target and redirect to the home page
        return redirect('/', code=302)

    ```
    For Django application, you can use the function `url_has_allowed_host_and_scheme` to check that a URL is safe to redirect to, as shown in the following example:


    ```python
    from django.http import HttpResponseRedirect
    from django.shortcuts import redirect
    from django.utils.http import url_has_allowed_host_and_scheme
    from django.views import View

    class RedirectView(View):
        def get(self, request, *args, **kwargs):
            target = request.GET.get('target', '')
            if url_has_allowed_host_and_scheme(target, allowed_hosts=None):
                return HttpResponseRedirect(target)
            else:
                # ignore the target and redirect to the home page
                return redirect('/')
    ```
    Note that `url_has_allowed_host_and_scheme` handles backslashes correctly, so no additional processing is required.


    ## References
    * OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Python standard library: [ urllib.parse](https://docs.python.org/3/library/urllib.parse.html).
    * Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-611/Xxe.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-611/Xxe.bqrs
  metadata:
    name: XML external entity expansion
    description: |-
      Parsing user input as an XML document with external
                    entity expansion is vulnerable to XXE attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: high
    id: py/xxe
    tags: |-
      security
             external/cwe/cwe-611
             external/cwe/cwe-827
  queryHelp: |
    # XML external entity expansion
    Parsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.


    ## Recommendation
    The easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of the XML libraries in the standard library of Python 3, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.

    We recommend using the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package, which has been created to prevent XML attacks (both XXE and XML bombs).


    ## Example
    The following example uses the `lxml` XML parser to parse a string `xml_src`. That string is from an untrusted source, so this code is vulnerable to an XXE attack, since the [ default parser](https://lxml.de/apidoc/lxml.etree.html#lxml.etree.XMLParser) from `lxml.etree` allows local external entities to be resolved.


    ```python
    from flask import Flask, request
    import lxml.etree

    app = Flask(__name__)

    @app.post("/upload")
    def upload():
        xml_src = request.get_data()
        doc = lxml.etree.fromstring(xml_src)
        return lxml.etree.tostring(doc)

    ```
    To guard against XXE attacks with the `lxml` library, you should create a parser with `resolve_entities` set to `false`. This means that no entity expansion is undertaken, although standard predefined entities such as `&gt;`, for writing `>` inside the text of an XML element, are still allowed.


    ```python
    from flask import Flask, request
    import lxml.etree

    app = Flask(__name__)

    @app.post("/upload")
    def upload():
        xml_src = request.get_data()
        parser = lxml.etree.XMLParser(resolve_entities=False)
        doc = lxml.etree.fromstring(xml_src, parser=parser)
        return lxml.etree.tostring(doc)

    ```

    ## References
    * OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).
    * Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).
    * Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).
    * Python 3 standard library: [XML Vulnerabilities](https://docs.python.org/3/library/xml.html#xml-vulnerabilities).
    * Python 2 standard library: [XML Vulnerabilities](https://docs.python.org/2/library/xml.html#xml-vulnerabilities).
    * PortSwigger: [XML external entity (XXE) injection](https://portswigger.net/web-security/xxe).
    * Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).
    * Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-614/InsecureCookie.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-614/InsecureCookie.bqrs
  metadata:
    name: Failure to use secure cookies
    description: |-
      Insecure cookies may be sent in cleartext, which makes them vulnerable to
                    interception.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: high
    id: py/insecure-cookie
    tags: |-
      security
             external/cwe/cwe-614
             external/cwe/cwe-1004
             external/cwe/cwe-1275
  queryHelp: "# Failure to use secure cookies\nCookies without the `Secure` flag set\
    \ may be transmitted using HTTP instead of HTTPS, which leaves them vulnerable\
    \ to reading by a third party.\n\nCookies without the `HttpOnly` flag set are\
    \ accessible to JavaScript running in the same origin. In case of a Cross-Site\
    \ Scripting (XSS) vulnerability, the cookie can be stolen by a malicious script.\n\
    \nCookies with the `SameSite` attribute set to `'None'` will be sent with cross-origin\
    \ requests, which can be controlled by third-party JavaScript code and allow for\
    \ Cross-Site Request Forgery (CSRF) attacks.\n\n\n## Recommendation\nAlways set\
    \ `secure` to `True` or add \"; Secure;\" to the cookie's raw value.\n\nAlways\
    \ set `httponly` to `True` or add \"; HttpOnly;\" to the cookie's raw value.\n\
    \nAlways set `samesite` to `Lax` or `Strict`, or add \"; SameSite=Lax;\", or \"\
    ; Samesite=Strict;\" to the cookie's raw header value.\n\n\n## Example\nIn the\
    \ following examples, the cases marked GOOD show secure cookie attributes being\
    \ set; whereas in the cases marked BAD they are not set.\n\n\n```python\nfrom\
    \ flask import Flask, request, make_response, Response\n\n\n@app.route(\"/good1\"\
    )\ndef good1():\n    resp = make_response()\n    resp.set_cookie(\"name\", value=\"\
    value\", secure=True, httponly=True, samesite='Strict') # GOOD: Attributes are\
    \ securely set\n    return resp\n\n\n@app.route(\"/good2\")\ndef good2():\n  \
    \  resp = make_response()\n    resp.headers['Set-Cookie'] = \"name=value; Secure;\
    \ HttpOnly; SameSite=Strict\" # GOOD: Attributes are securely set \n    return\
    \ resp\n\n@app.route(\"/bad1\")\n    resp = make_response()\n    resp.set_cookie(\"\
    name\", value=\"value\", samesite='None') # BAD: the SameSite attribute is set\
    \ to 'None' and the 'Secure' and 'HttpOnly' attributes are set to False by default.\n\
    \    return resp\n```\n\n## References\n* Detectify: [Cookie lack Secure flag](https://support.detectify.com/support/solutions/articles/48001048982-cookie-lack-secure-flag).\n\
    * PortSwigger: [TLS cookie without secure flag set](https://portswigger.net/kb/issues/00500200_tls-cookie-without-secure-flag-set).\n\
    * Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n\
    * Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).\n\
    * Common Weakness Enumeration: [CWE-1275](https://cwe.mitre.org/data/definitions/1275.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-643/XpathInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-643/XpathInjection.bqrs
  metadata:
    name: XPath query built from user-controlled sources
    description: |-
      Building a XPath query from user-controlled sources is vulnerable to insertion of
                    malicious Xpath code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: py/xpath-injection
    tags: |-
      security
             external/cwe/cwe-643
  queryHelp: |
    # XPath query built from user-controlled sources
    If an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.


    ## Recommendation
    If user input must be included in an XPath expression, either sanitize the data or use variable references to safely embed it without altering the structure of the expression.


    ## Example
    In the example below, the xpath query is controlled by the user and hence leads to a vulnerability.


    ```python
    from lxml import etree
    from io import StringIO

    from django.urls import path
    from django.http import HttpResponse
    from django.template import Template, Context, Engine, engines


    def a(request):
        value = request.GET['xpath']
        f = StringIO('<foo><bar></bar></foo>')
        tree = etree.parse(f)
        r = tree.xpath("/tag[@id='%s']" % value)


    urlpatterns = [
        path('a', a)
    ]

    ```
    This can be fixed by using a parameterized query as shown below.


    ```python
    from lxml import etree
    from io import StringIO

    from django.urls import path
    from django.http import HttpResponse
    from django.template import Template, Context, Engine, engines


    def a(request):
        value = request.GET['xpath']
        f = StringIO('<foo><bar></bar></foo>')
        tree = etree.parse(f)
        r = tree.xpath("/tag[@id=$tagid]", tagid=value)


    urlpatterns = [
        path('a', a)
    ]

    ```

    ## References
    * OWASP XPath injection : [](https://owasp.org/www-community/attacks/XPATH_Injection)/&gt;&gt;
    * Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-730/PolynomialReDoS.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-730/PolynomialReDoS.bqrs
  metadata:
    name: Polynomial regular expression used on uncontrolled data
    description: |-
      A regular expression that can require polynomial time
                    to match may be vulnerable to denial-of-service attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: py/polynomial-redos
    tags: |-
      security
             external/cwe/cwe-1333
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: "# Polynomial regular expression used on uncontrolled data\nSome regular\
    \ expressions take a long time to match certain input strings to the point where\
    \ the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>*\
    \ or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance,\
    \ or even allow a malicious user to perform a Denial of Service (\"DoS\") attack\
    \ by crafting an expensive input string for the regular expression to match.\n\
    \nThe regular expression engine provided by Python uses a backtracking non-deterministic\
    \ finite automata to implement regular expression matching. While this approach\
    \ is space-efficient and allows supporting advanced features like capture groups,\
    \ it is not time-efficient in general. The worst-case time complexity of such\
    \ an automaton can be polynomial or even exponential, meaning that for strings\
    \ of a certain shape, increasing the input length by ten characters may make the\
    \ automaton about 1000 times slower.\n\nTypically, a regular expression is affected\
    \ by this problem if it contains a repetition of the form `r*` or `r+` where the\
    \ sub-expression `r` is ambiguous in the sense that it can match some string in\
    \ multiple ways. More information about the precise circumstances can be found\
    \ in the references.\n\n\n## Recommendation\nModify the regular expression to\
    \ remove the ambiguity, or ensure that the strings matched with the regular expression\
    \ are short enough that the time-complexity does not matter.\n\n\n## Example\n\
    Consider this use of a regular expression, which removes all leading and trailing\
    \ whitespace in a string:\n\n```python\n\nre.sub(r\"^\\s+|\\s+$\", \"\", text)\
    \ # BAD\n```\nThe sub-expression `\"\\s+$\"` will match the whitespace characters\
    \ in `text` from left to right, but it can start matching anywhere within a whitespace\
    \ sequence. This is problematic for strings that do **not** end with a whitespace\
    \ character. Such a string will force the regular expression engine to process\
    \ each whitespace sequence once per whitespace character in the sequence.\n\n\
    This ultimately means that the time cost of trimming a string is quadratic in\
    \ the length of the string. So a string like `\"a b\"` will take milliseconds\
    \ to process, but a similar string with a million spaces instead of just one will\
    \ take several minutes.\n\nAvoid this problem by rewriting the regular expression\
    \ to not contain the ambiguity about when to start matching whitespace sequences.\
    \ For instance, by using a negative look-behind (`^\\s+|(?<!\\s)\\s+$`), or just\
    \ by using the built-in strip method (`text.strip()`).\n\nNote that the sub-expression\
    \ `\"^\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression\
    \ can start matching, and as the regular expression engine matches from left to\
    \ right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider\
    \ the regular expression that matches lines with numbers, possibly written using\
    \ scientific notation:\n\n```python\n\n^0\\.\\d+E?\\d+$ # BAD\n```\nThe problem\
    \ with this regular expression is in the sub-expression `\\d+E?\\d+` because the\
    \ second `\\d+` can start matching digits anywhere after the first match of the\
    \ first `\\d+` if there is no `E` in the input string.\n\nThis is problematic\
    \ for strings that do **not** end with a digit. Such a string will force the regular\
    \ expression engine to process each digit sequence once per digit in the sequence,\
    \ again leading to a quadratic time complexity.\n\nTo make the processing faster,\
    \ the regular expression should be rewritten such that the two `\\d+` sub-expressions\
    \ do not have overlapping matches: `^0\\.\\d+(E\\d+)?$`.\n\n\n## Example\nSometimes\
    \ it is unclear how a regular expression can be rewritten to avoid the problem.\
    \ In such cases, it often suffices to limit the length of the input string. For\
    \ instance, the following regular expression is used to match numbers, and on\
    \ some non-number inputs it can have quadratic time complexity:\n\n```python\n\
    \nmatch = re.search(r'^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$', str)\
    \ \n```\nIt is not immediately obvious how to rewrite this regular expression\
    \ to avoid the problem. However, you can mitigate performance issues by limiting\
    \ the length to 1000 characters, which will always finish in a reasonable amount\
    \ of time.\n\n```python\n\nif len(str) > 1000:\n    raise ValueError(\"Input too\
    \ long\")\n\nmatch = re.search(r'^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\\
    d+)?$', str) \n```\n\n## References\n* OWASP: [Regular expression Denial of Service\
    \ - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n\
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time\
    \ complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage,\
    \ Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service\
    \ Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n\
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n\
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-730/ReDoS.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-730/ReDoS.bqrs
  metadata:
    name: Inefficient regular expression
    description: |-
      A regular expression that requires exponential time to match certain inputs
                    can be a performance bottleneck, and may be vulnerable to denial-of-service
                    attacks.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/redos
    tags: |-
      security
             external/cwe/cwe-1333
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Inefficient regular expression
    Some regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service ("DoS") attack by crafting an expensive input string for the regular expression to match.

    The regular expression engine provided by Python uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.

    Typically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.


    ## Recommendation
    Modify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.


    ## Example
    Consider this regular expression:

    ```python

    ^_(__|.)+_$
    ```
    Its sub-expression `"(__|.)+?"` can match the string `"__"` either by the first alternative `"__"` to the left of the `"|"` operator, or by two repetitions of the second alternative `"."` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.

    This problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:

    ```python

    ^_(__|[^_])+_$
    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).
    * James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).
    * Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-730/RegexInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-730/RegexInjection.bqrs
  metadata:
    name: Regular expression injection
    description: |-
      User input should not be used in regular expressions without first being escaped,
                    otherwise a malicious user may be able to inject an expression that could require
                    exponential time on certain inputs.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/regex-injection
    tags: |-
      security
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Regular expression injection
    Constructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.


    ## Recommendation
    Before embedding user input into a regular expression, use a sanitization function such as `re.escape` to escape meta-characters that have a special meaning regarding regular expressions' syntax.


    ## Example
    The following examples are based on a simple Flask web server environment.

    The following example shows a HTTP request parameter that is used to construct a regular expression without sanitizing it first:


    ```python
    from flask import request, Flask
    import re


    @app.route("/direct")
    def direct():
        unsafe_pattern = request.args["pattern"]
        re.search(unsafe_pattern, "")


    @app.route("/compile")
    def compile():
        unsafe_pattern = request.args["pattern"]
        compiled_pattern = re.compile(unsafe_pattern)
        compiled_pattern.search("")

    ```
    Instead, the request parameter should be sanitized first, for example using the function `re.escape`. This ensures that the user cannot insert characters which have a special meaning in regular expressions.


    ```python
    from flask import request, Flask
    import re


    @app.route("/direct")
    def direct():
        unsafe_pattern = request.args['pattern']
        safe_pattern = re.escape(unsafe_pattern)
        re.search(safe_pattern, "")


    @app.route("/compile")
    def compile():
        unsafe_pattern = request.args['pattern']
        safe_pattern = re.escape(unsafe_pattern)
        compiled_pattern = re.compile(safe_pattern)
        compiled_pattern.search("")

    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * Python docs: [re](https://docs.python.org/3/library/re.html).
    * SonarSource: [RSPEC-2631](https://rules.sonarsource.com/python/type/Vulnerability/RSPEC-2631).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-732/WeakFilePermissions.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-732/WeakFilePermissions.bqrs
  metadata:
    name: Overly permissive file permissions
    description: Allowing files to be readable or writable by users other than the
      owner may allow sensitive information to be accessed.
    kind: problem
    id: py/overly-permissive-file
    problem.severity: warning
    security-severity: 7.8
    sub-severity: high
    precision: medium
    tags: |-
      external/cwe/cwe-732
             security
  queryHelp: |
    # Overly permissive file permissions
    When creating a file, POSIX systems allow permissions to be specified for owner, group and others separately. Permissions should be kept as strict as possible, preventing access to the files contents by other users.


    ## Recommendation
    Restrict the file permissions of files to prevent any but the owner being able to read or write to that file


    ## References
    * Wikipedia: [File system permissions](https://en.wikipedia.org/wiki/File_system_permissions).
    * Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-776/XmlBomb.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-776/XmlBomb.bqrs
  metadata:
    name: XML internal entity expansion
    description: |-
      Parsing user input as an XML document with arbitrary internal
                    entity expansion is vulnerable to denial-of-service attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: py/xml-bomb
    tags: |-
      security
             external/cwe/cwe-776
             external/cwe/cwe-400
  queryHelp: |
    # XML internal entity expansion
    Parsing untrusted XML files with a weakly configured XML parser may be vulnerable to denial-of-service (DoS) attacks exploiting uncontrolled internal entity expansion.

    In XML, so-called *internal entities* are a mechanism for introducing an abbreviation for a piece of text or part of a document. When a parser that has been configured to expand entities encounters a reference to an internal entity, it replaces the entity by the data it represents. The replacement text may itself contain other entity references, which are expanded recursively. This means that entity expansion can increase document size dramatically.

    If untrusted XML is parsed with entity expansion enabled, a malicious attacker could submit a document that contains very deeply nested entity definitions, causing the parser to take a very long time or use large amounts of memory. This is sometimes called an *XML bomb* attack.


    ## Recommendation
    The safest way to prevent XML bomb attacks is to disable entity expansion when parsing untrusted data. Whether this can be done depends on the library being used. Note that some libraries, such as `lxml`, have measures enabled by default to prevent such DoS XML attacks, so unless you have explicitly set `huge_tree` to `True`, no further action is needed.

    We recommend using the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package, which has been created to prevent XML attacks (both XXE and XML bombs).


    ## Example
    The following example uses the `xml.etree` XML parser provided by the Python standard library to parse a string `xml_src`. That string is from an untrusted source, so this code is vulnerable to a DoS attack, since the `xml.etree` XML parser expands internal entities by default:


    ```python
    from flask import Flask, request
    import xml.etree.ElementTree as ET

    app = Flask(__name__)

    @app.post("/upload")
    def upload():
        xml_src = request.get_data()
        doc = ET.fromstring(xml_src)
        return ET.tostring(doc)

    ```
    It is not possible to guard against internal entity expansion with `xml.etree`, so to guard against these attacks, the following example uses the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package instead, which is not exposed to such internal entity expansion attacks.


    ```python
    from flask import Flask, request
    import defusedxml.ElementTree as ET

    app = Flask(__name__)

    @app.post("/upload")
    def upload():
        xml_src = request.get_data()
        doc = ET.fromstring(xml_src)
        return ET.tostring(doc)

    ```

    ## References
    * Wikipedia: [Billion Laughs](https://en.wikipedia.org/wiki/Billion_laughs).
    * Bryan Sullivan: [Security Briefs - XML Denial of Service Attacks and Defenses](https://msdn.microsoft.com/en-us/magazine/ee335713.aspx).
    * Python 3 standard library: [XML Vulnerabilities](https://docs.python.org/3/library/xml.html#xml-vulnerabilities).
    * Python 2 standard library: [XML Vulnerabilities](https://docs.python.org/2/library/xml.html#xml-vulnerabilities).
    * Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-918/FullServerSideRequestForgery.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-918/FullServerSideRequestForgery.bqrs
  metadata:
    name: Full server-side request forgery
    description: Making a network request to a URL that is fully user-controlled allows
      for request forgery attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: high
    id: py/full-ssrf
    tags: |-
      security
             external/cwe/cwe-918
  queryHelp: |
    # Full server-side request forgery
    Directly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the request may be changed, directed at a different server, or via a different protocol. This can allow the attacker to obtain sensitive information or perform actions with escalated privilege.

    We make a distinctions between how much of the URL an attacker can control:

    * **Full SSRF**: where the full URL can be controlled.
    * **Partial SSRF**: where only part of the URL can be controlled, such as the path component of a URL to a hardcoded domain.


    Partial control of a URL is often much harder to exploit. Therefore we have created a separate query for each of these.

    This query covers full SSRF, to find partial SSRF use the `py/partial-ssrf` query.


    ## Recommendation
    To guard against SSRF attacks you should avoid putting user-provided input directly into a request URL. On the application level, maintain a list of authorized URLs on the server and choose from that list based on the input provided. If that is not possible, one should verify the IP address for all user-controlled requests to ensure they are not private. This requires saving the verified IP address of each domain, then utilizing a custom HTTP adapter to ensure that future requests to that domain use the verified IP address. On the network level, you can segment the vulnerable application into its own LAN or block access to specific devices.


    ## Example
    The following example shows code vulnerable to a full SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `evil.com#` as the `target` value, the requested URL will be `https://evil.com#.example.com/data/`. It also shows how to remedy the problem by using the user input select a known fixed string.


    ```python
    import requests
    from flask import Flask, request

    app = Flask(__name__)

    @app.route("/full_ssrf")
    def full_ssrf():
        target = request.args["target"]

        # BAD: user has full control of URL
        resp = requests.get("https://" + target + ".example.com/data/")

        # GOOD: `subdomain` is controlled by the server.
        subdomain = "europe" if target == "EU" else "world"
        resp = requests.get("https://" + subdomain + ".example.com/data/")

    ```

    ## Example
    The following example shows code vulnerable to a partial SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `../transfer-funds-to/123?amount=456` as the `user_id` value, the requested URL will be `https://api.example.com/transfer-funds-to/123?amount=456`. It also shows how to remedy the problem by validating the input.


    ```python
    import requests
    from flask import Flask, request

    app = Flask(__name__)

    @app.route("/partial_ssrf")
    def partial_ssrf():
        user_id = request.args["user_id"]

        # BAD: user can fully control the path component of the URL
        resp = requests.get("https://api.example.com/user_info/" + user_id)

        if user_id.isalnum():
            # GOOD: user_id is restricted to be alpha-numeric, and cannot alter path component of URL
            resp = requests.get("https://api.example.com/user_info/" + user_id)

    ```

    ## References
    * [OWASP SSRF article](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)
    * [PortSwigger SSRF article](https://portswigger.net/web-security/ssrf)
    * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-918/PartialServerSideRequestForgery.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-918/PartialServerSideRequestForgery.bqrs
  metadata:
    name: Partial server-side request forgery
    description: Making a network request to a URL that is partially user-controlled
      allows for request forgery attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: medium
    id: py/partial-ssrf
    tags: |-
      security
             external/cwe/cwe-918
  queryHelp: |
    # Partial server-side request forgery
    Directly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the request may be changed, directed at a different server, or via a different protocol. This can allow the attacker to obtain sensitive information or perform actions with escalated privilege.

    We make a distinctions between how much of the URL an attacker can control:

    * **Full SSRF**: where the full URL can be controlled.
    * **Partial SSRF**: where only part of the URL can be controlled, such as the path component of a URL to a hardcoded domain.


    Partial control of a URL is often much harder to exploit. Therefore we have created a separate query for each of these.

    This query covers partial SSRF, to find full SSRF use the `py/full-ssrf` query.


    ## Recommendation
    To guard against SSRF attacks you should avoid putting user-provided input directly into a request URL. On the application level, maintain a list of authorized URLs on the server and choose from that list based on the input provided. If that is not possible, one should verify the IP address for all user-controlled requests to ensure they are not private. This requires saving the verified IP address of each domain, then utilizing a custom HTTP adapter to ensure that future requests to that domain use the verified IP address. On the network level, you can segment the vulnerable application into its own LAN or block access to specific devices.


    ## Example
    The following example shows code vulnerable to a full SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `evil.com#` as the `target` value, the requested URL will be `https://evil.com#.example.com/data/`. It also shows how to remedy the problem by using the user input select a known fixed string.


    ```python
    import requests
    from flask import Flask, request

    app = Flask(__name__)

    @app.route("/full_ssrf")
    def full_ssrf():
        target = request.args["target"]

        # BAD: user has full control of URL
        resp = requests.get("https://" + target + ".example.com/data/")

        # GOOD: `subdomain` is controlled by the server.
        subdomain = "europe" if target == "EU" else "world"
        resp = requests.get("https://" + subdomain + ".example.com/data/")

    ```

    ## Example
    The following example shows code vulnerable to a partial SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `../transfer-funds-to/123?amount=456` as the `user_id` value, the requested URL will be `https://api.example.com/transfer-funds-to/123?amount=456`. It also shows how to remedy the problem by validating the input.


    ```python
    import requests
    from flask import Flask, request

    app = Flask(__name__)

    @app.route("/partial_ssrf")
    def partial_ssrf():
        user_id = request.args["user_id"]

        # BAD: user can fully control the path component of the URL
        resp = requests.get("https://api.example.com/user_info/" + user_id)

        if user_id.isalnum():
            # GOOD: user_id is restricted to be alpha-numeric, and cannot alter path component of URL
            resp = requests.get("https://api.example.com/user_info/" + user_id)

    ```

    ## References
    * [OWASP SSRF article](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)
    * [PortSwigger SSRF article](https://portswigger.net/web-security/ssrf)
    * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-943/NoSqlInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-943/NoSqlInjection.bqrs
  metadata:
    name: NoSQL Injection
    description: |-
      Building a NoSQL query from user-controlled sources is vulnerable to insertion of
                    malicious NoSQL code by the user.
    kind: path-problem
    precision: high
    problem.severity: error
    security-severity: 8.8
    id: py/nosql-injection
    tags: |-
      security
             external/cwe/cwe-943
  queryHelp: |
    # NoSQL Injection
    Passing user-controlled sources into NoSQL queries can result in a NoSQL injection flaw. This tainted NoSQL query containing a user-controlled source can then execute a malicious query in a NoSQL database such as MongoDB. In order for the user-controlled source to taint the NoSQL query, the user-controller source must be converted into a Python object using something like `json.loads` or `xmltodict.parse`.

    Because a user-controlled source is passed into the query, the malicious user can have complete control over the query itself. When the tainted query is executed, the malicious user can commit malicious actions such as bypassing role restrictions or accessing and modifying restricted data in the NoSQL database.


    ## Recommendation
    NoSQL injections can be prevented by escaping user-input's special characters that are passed into the NoSQL query from the user-supplied source. Alternatively, using a sanitize library such as MongoSanitizer will ensure that user-supplied sources can not act as a malicious query.


    ## Example
    In the example below, the user-supplied source is passed to a MongoDB function that queries the MongoDB database.


    ```python
    from flask import Flask, request
    from flask_pymongo import PyMongo
    import json

    mongo = PyMongo(app)


    @app.route("/")
    def home_page():
        unsanitized_search = request.args['search']
        json_search = json.loads(unsanitized_search)

        result = mongo.db.user.find({'name': json_search})

    ```
    This can be fixed by using a sanitizer library like MongoSanitizer as shown in this annotated code version below.


    ```python
    from flask import Flask, request
    from flask_pymongo import PyMongo
    from mongosanitizer.sanitizer import sanitize
    import json

    mongo = PyMongo(app)


    @app.route("/")
    def home_page():
        unsafe_search = request.args['search']
        json_search = json.loads(unsafe_search)
        safe_search = sanitize(unsanitized_search)

        result = client.db.collection.find_one({'data': safe_search})

    ```

    ## References
    * Mongoengine: [Documentation](http://mongoengine.org/).
    * Flask-Mongoengine: [Documentation](http://docs.mongoengine.org/projects/flask-mongoengine/en/latest/).
    * PyMongo: [Documentation](https://pypi.org/project/pymongo/).
    * Flask-PyMongo: [Documentation](https://flask-pymongo.readthedocs.io/en/latest/).
    * OWASP: [NoSQL Injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).
    * Security Stack Exchange Discussion: [Question 83231](https://security.stackexchange.com/questions/83231/mongodb-nosql-injection-in-python-code).
    * Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/AssertOnTuple.ql
  relativeBqrsPath: codeql/python-queries/Statements/AssertOnTuple.bqrs
  metadata:
    name: Asserting a tuple
    description: Using an assert statement to test a tuple provides no validity checking.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-670
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/asserts-tuple
  queryHelp: |
    # Asserting a tuple
    When you define an `assert` statement to test a tuple the test will either always succeed (if the tuple is non-empty) or always fail (if the tuple is empty).

    This error usually occurs when the programmer writes ` assert (condition, message) ` instead of the correct form` assert condition, message `


    ## Recommendation
    Review the code and determine the purpose of the `assert` statement:

    * If the "tuple" has been created in error, then remove the parentheses and correct the statement
    * If validation of a tuple is intended, then you should define an `assert` statement for each element of the tuple.

    ## Example
    The statement `assert (xxx, yyy)` attempts to test a "tuple" `(xxx, yyy)`. The original intention may be any of the alternatives listed below:


    ```python
    assert xxx and yyy   # Alternative 1a. Check both expressions are true

    assert xxx, yyy      # Alternative 1b. Check 'xxx' is true, 'yyy' is the failure message.

    tuple = (xxx, yyy)   # Alternative 2. Check both elements of the tuple match expectations.
    assert tuple[0]==xxx
    assert tuple[1]==yyy

    ```
    If you want to define a validity check on the values of a tuple then these must be tested individually.


    ## References
    * Python Language Reference: [The assert statement](http://docs.python.org/2.7/reference/simple_stmts.html#the-assert-statement).
    * Tutorials Point: [Assertions in Python](http://www.tutorialspoint.com/python/assertions_in_python.htm).
    * Common Weakness Enumeration: [CWE-670](https://cwe.mitre.org/data/definitions/670.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/BreakOrReturnInFinally.ql
  relativeBqrsPath: codeql/python-queries/Statements/BreakOrReturnInFinally.bqrs
  metadata:
    name: '''break'' or ''return'' statement in finally'
    description: |-
      Using a Break or Return statement in a finally block causes the
                    Try-finally block to exit, discarding the exception.
    kind: problem
    tags: |-
      quality
             reliability
             error-handling
             correctness
             external/cwe/cwe-584
    problem.severity: warning
    sub-severity: low
    precision: medium
    id: py/exit-from-finally
  queryHelp: |
    # 'break' or 'return' statement in finally
    When a `break` or `return` statement is used in a `finally` block this causes the `try-finally` block to exit immediately discarding the exception. This is unlikely to be the intention of the developer and makes the code more difficult to read.


    ## Recommendation
    Either move the `break` or `return` statement to immediately after the `finally` block or use an explicit `except` block to handle the exception.

    These modifications are behavior changing so you must take care to ensure that the resulting behavior is correct.


    ## References
    * Python Language Reference: [ The try statement](http://docs.python.org/2.7/reference/compound_stmts.html#the-try-statement), [ The break statement](http://docs.python.org/2/reference/simple_stmts.html#break), [ The return statement](http://docs.python.org/2/reference/simple_stmts.html#return).
    * Common Weakness Enumeration: [CWE-584](https://cwe.mitre.org/data/definitions/584.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/ConstantInConditional.ql
  relativeBqrsPath: codeql/python-queries/Statements/ConstantInConditional.bqrs
  metadata:
    name: Constant in conditional expression or statement
    description: The conditional is always true or always false
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
             external/cwe/cwe-561
             external/cwe/cwe-570
             external/cwe/cwe-571
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/constant-conditional-expression
  queryHelp: |
    # Constant in conditional expression or statement
    Using a constant value as a test in a conditional statement renders the statement pointless as only one branch will be run regardless of any other factors.


    ## Recommendation
    If the conditional statement is required for debugging or similar then use a variable instead. Otherwise, remove the conditional statement and any associated dead code.


    ## Example
    In the first example the `if` statement will always be executed and therefore can be removed. The contents of the statement should be kept though.

    In the second example the statement `l = 100` is never executed because `1 > 100` is always false. However, it is likely that the intention was `l > 100` (the number '1' being misread as the letter 'l') and that the test should be corrected, rather than deleted.


    ```python
    if True:
        print "True is true!"

    def limit(l):
        if l < -100:
            l = -100
        if 1 > 100:
            l = 100
        return l

    ```

    ## References
    * Python: [The If Statement](http://docs.python.org/reference/compound_stmts.html#the-if-statement).
    * Python: [The While Statement](http://docs.python.org/reference/compound_stmts.html#the-while-statement).
    * Python: [Literals (constant values)](http://docs.python.org/reference/expressions.html#literals).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
    * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).
    * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/IterableStringOrSequence.ql
  relativeBqrsPath: codeql/python-queries/Statements/IterableStringOrSequence.bqrs
  metadata:
    name: Iterable can be either a string or a sequence
    description: Iteration over either a string or a sequence in the same loop can
      cause errors that are hard to find.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/iteration-string-and-sequence
  queryHelp: |
    # Iterable can be either a string or a sequence
    The `for` statement is designed to allow you to iterate over the elements of a sequence or other iterable object. Strings in Python are iterable, and often used as such. However, they are also often considered, not as sequences of characters, but as atomic entities.

    One source of defects in Python is mistakenly iterating over a non-iterable object such as an integer. This sort of defect is easily detected as a `TypeError` will be raised. However, if a string is mistakenly used as the iterable in a `for` statement, which also receives other sequences (such as lists) then the code will iterate over the string one character at a time. This is probably not what the programmer intended and results in errors that are hard to find.


    ## Recommendation
    Since this defect usually indicates a logical error, it is not possible to give a general method for addressing the defect. However, adding a guard that checks that the iterator is not a string could be worthwhile.


    ## Example
    In this example, the loop may iterate over `"Hello"` producing one character per line, as well as over `[ "Hello", "World" ]` It is likely that the programmer forgot to wrap the `"Hello"` in brackets.


    ```python

    #Mistakenly mixed list and string
    def greeting():
        if is_global():
            greet = [ "Hello", "World" ]
        else:
            greet = "Hello"
        for word in greet:
            print(word)

    #Only use list
    def fixed_greeting():
        if is_global():
            greet = [ "Hello", "World" ]
        else:
            greet = [ "Hello" ]
        for word in greet:
            print(word)

    ```

    ## References
    * Python Language Reference: [The for statement](http://docs.python.org/reference/compound_stmts.html#the-for-statement), [object.__iter__](http://docs.python.org/2.7/reference/datamodel.html#object.__iter__).
    * Python Standard Library: [Iterator types](http://docs.python.org/dev/library/stdtypes.html#iterator-types).
    * Scipy lecture notes: [Iterators, generator expressions and generators](http://scipy-lectures.github.io/advanced/advanced_python/#iterators).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/MismatchInMultipleAssignment.ql
  relativeBqrsPath: codeql/python-queries/Statements/MismatchInMultipleAssignment.bqrs
  metadata:
    name: Mismatch in multiple assignment
    description: |-
      Assigning multiple variables without ensuring that you define a
                    value for each variable causes an exception at runtime.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/mismatched-multiple-assignment
  queryHelp: |
    # Mismatch in multiple assignment
    An assignment statement evaluates a sequence expression and assigns each item of the sequence to one of the variables on the left. If there is a mismatch between the number of variables on the left and the values in the sequence on the right of the statement, then an exception is raised at runtime.


    ## Recommendation
    Ensure that the number of variables on either side of the assignment match.


    ## Example
    The following examples show a simple definition of the Fibonacci series. In the first example, one of the values in the assignment has been duplicated, causing an exception at runtime.


    ```python
    # Fibonacci series 1:
    # the sum of two elements defines the next

    a, b = 0, 1, 1  # Assignment fails: accidentally put three values on right
    while b < 10:
         print b
         a, b = b, a+b

    # Fibonacci series 2:
    # the sum of two elements defines the next
    a, b = 0, 1   # Assignment succeeds: two variables on left and two values on right
    while b < 10:
         print b
         a, b = b, a+b

    ```

    ## References
    * Python Language Reference: [ Assignment statements](http://docs.python.org/2/reference/simple_stmts.html#grammar-token-assignment_stmt).
    * Python Tutorial: [ First steps towards programming](http://docs.python.org/2/tutorial/introduction.html#first-steps-towards-programming).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/ModificationOfLocals.ql
  relativeBqrsPath: codeql/python-queries/Statements/ModificationOfLocals.bqrs
  metadata:
    name: Modification of dictionary returned by locals()
    description: Modifications of the dictionary returned by locals() are not propagated
      to the local variables of a function.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/modification-of-locals
  queryHelp: |
    # Modification of dictionary returned by locals()
    The dictionary returned by `locals()` is not a view of the function's locals, but a copy. Therefore, modification of the dictionary returned from `locals()` will not modify the local variables of the function.


    ## Recommendation
    If the intention is to modify a local variable, then do so directly.


    ## Example
    In this example, rather than assigning to the variable `z` directly, the dictionary returned by `locals()` is modified.


    ```python

    def modifies_locals_sum(x, y):
        locals()['z'] = x + y
        #z will not be defined as modifications to locals() do not alter the local variables.
        return z

    def fixed_sum(x, y):
        z = x + y
        return z


    ```

    ## References
    * Python Language Reference: [The for statement](http://docs.python.org/2/reference/compound_stmts.html#the-for-statement).
    * Python Tutorial: [for statements](http://docs.python.org/2/tutorial/controlflow.html#for-statements).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/NestedLoopsSameVariable.ql
  relativeBqrsPath: codeql/python-queries/Statements/NestedLoopsSameVariable.bqrs
  metadata:
    name: Nested loops with same variable
    description: |-
      Nested loops in which the target variable is the same for each loop make
                    the behavior of the loops difficult to understand.
    kind: problem
    tags: |-
      quality
             maintainability
             readability
    problem.severity: recommendation
    sub-severity: high
    precision: very-high
    id: py/nested-loops-with-same-variable
  queryHelp: |
    # Nested loops with same variable
    In Python variables have function-wide scope which means that if two variables have the same name in the same scope, they are in fact one variable. Consequently, nested loops in which the target variables have the same name in fact share a single variable. Such loops are difficult to understand as the inner loop will modify the target variable of the outer loop; this may be a typographical error.


    ## Recommendation
    Carefully examine the code and check for possible errors, particularly considering what would happen if the inner or outer variable were renamed.


    ## Example

    ```python

    for var in range(3):
        for var in range(3):
            pass
        print (var) # Prints 2 2 2 not 0 1 2 as might be expected


    ```

    ## References
    * Python Language Reference: [The for statement](http://docs.python.org/2/reference/compound_stmts.html#the-for-statement).
    * Python Tutorial: [for statements](http://docs.python.org/2/tutorial/controlflow.html#for-statements).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/NestedLoopsSameVariableWithReuse.ql
  relativeBqrsPath: codeql/python-queries/Statements/NestedLoopsSameVariableWithReuse.bqrs
  metadata:
    name: Nested loops with same variable reused after inner loop body
    description: |-
      Redefining a variable in an inner loop and then using
                    the variable in an outer loop causes unexpected behavior.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/nested-loops-with-same-variable-reused
  queryHelp: |
    # Nested loops with same variable reused after inner loop body
    In Python variables have function-wide scope which means that if two variables have the same name in the same scope, they are in fact one variable. Consequently, nested loops in which the target variables have the same name in fact share a single variable. Such loops are difficult to understand as the inner loop will modify the target variable of the outer loop. This may lead to unexpected behavior if the loop variable is used after the inner loop has terminated.


    ## Recommendation
    Rename the inner loop variable.


    ## Example
    This example shows a function that processes a sequence of lists of numbers. It prints out the largest element from each of the lists. In the first version, the variable `x` gets overwritten by the inner loop, resulting in the wrong output. In the second function, the error has been fixed by renaming the inner loop variable to stop it overwriting the outer loop variable.


    ```python
    def largest_elements(l):
        for x in l:
            maxnum = 0
            for x in x:
                maxnum = max(x, maxnum)
            # The outer loop variable x has now been overwritten by the inner loop.
            print "The largest element in the list", x, "is", maxnum


    def largest_elements_correct(l):
        for x in l:
            maxnum = 0
            for y in x:
                maxnum = max(y, maxnum)
            print "The largest element in the list", x, "is", maxnum


    ```

    ## References
    * Python Language Reference: [The for statement](http://docs.python.org/2/reference/compound_stmts.html#the-for-statement).
    * Python Tutorial: [for statements](http://docs.python.org/2/tutorial/controlflow.html#for-statements).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/NonIteratorInForLoop.ql
  relativeBqrsPath: codeql/python-queries/Statements/NonIteratorInForLoop.bqrs
  metadata:
    name: Non-iterable used in for loop
    description: Using a non-iterable as the object in a 'for' loop causes a TypeError.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/non-iterable-in-for-loop
  queryHelp: |
    # Non-iterable used in for loop
    The `for` statement is designed to allow you to iterate over the elements of a sequence or other iterable object. If a non-iterable object is used in a `for` statement (`for var in object:`) then a TypeError will be raised.


    ## Recommendation
    Since this defect usually indicates a logical error, it is not possible to give a general method for addressing the defect.


    ## Example
    In this example, the loop may attempt to iterate over `None`, which is not an iterable. It is likely that the programmer forgot to test for `None` before the loop.


    ```python


    def illegal_for_loop(seq = None):
        for x in seq:
            print (x)


    ```

    ## References
    * Python Language Reference: [The for statement](http://docs.python.org/reference/compound_stmts.html#the-for-statement), [object.__iter__](http://docs.python.org/2.7/reference/datamodel.html#object.__iter__).
    * Python Standard Library: [Iterator types](http://docs.python.org/dev/library/stdtypes.html#iterator-types).
    * Scipy lecture notes: [Iterators, generator expressions and generators](http://scipy-lectures.github.io/advanced/advanced_python/#iterators).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/RedundantAssignment.ql
  relativeBqrsPath: codeql/python-queries/Statements/RedundantAssignment.bqrs
  metadata:
    name: Redundant assignment
    description: Assigning a variable to itself is useless and very likely indicates
      an error in the code.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-563
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/redundant-assignment
  queryHelp: |
    # Redundant assignment
    Assigning a variable to itself is redundant and often an indication of a mistake in the code.


    ## Recommendation
    Check the assignment carefully for mistakes. If the assignment is truly redundant and not simply incorrect then remove it.


    ## Example
    In this example the programmer clearly intends to assign to `self.eggs` but made a mistake.


    ```python
    class Spam:

        def __init__(self, eggs):
            eggs = eggs


    ```

    ## References
    * Python Language Reference: [ The assignment statement](http://docs.python.org/reference/simple_stmts.html#assignment-statements).
    * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/ReturnOrYieldOutsideFunction.ql
  relativeBqrsPath: codeql/python-queries/Statements/ReturnOrYieldOutsideFunction.bqrs
  metadata:
    name: Use of 'return' or 'yield' outside a function
    description: Using 'return' or 'yield' outside a function causes a 'SyntaxError'
      at runtime.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: medium
    id: py/return-or-yield-outside-function
  queryHelp: |
    # Use of 'return' or 'yield' outside a function
    In Python, `return` and `yield` statements and the `yield from` expression can only be used within a function. Using them outside a function or a class method results in a `SyntaxError` at runtime.


    ## Recommendation
    Using these elements outside a function or a class method usually indicates an error in the logic. Consequently, it is not possible to suggest a general fix.


    ## Example
    In this example, a `return` statement is used outside a class method in a class and a `yield` statement is used outside a function in a scope of a module which would result in a `SyntaxError` when running this code. In this example, the invalid class could be corrected by placing the `return` statement in a class method, or by refactoring the class into a function. The invalid `yield` statement could become part of a new generator function containing the `for` loop.


    ```python
    # invalid class with return outside a function
    class InvalidClass1(object):
        if [1, 2, 3]:
            return "Exists"

    # invalid statement with yield outside a function
    for i in [1, 2, 3]:
        yield i

    ```

    ## References
    * Python reference: [ The return statement](https://docs.python.org/3.7/reference/simple_stmts.html#the-return-statement).
    * Python reference: [ The yield statement](https://docs.python.org/3.7/reference/simple_stmts.html#yield).
    * Python PEP-380: [ The yield from expression](https://docs.python.org/3/whatsnew/3.3.html#pep-380).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/ShouldUseWithStatement.ql
  relativeBqrsPath: codeql/python-queries/Statements/ShouldUseWithStatement.bqrs
  metadata:
    name: Should use a 'with' statement
    description: |-
      Using a 'try-finally' block to ensure only that a resource is closed makes code more
                    difficult to read.
    kind: problem
    tags: |-
      quality
             maintainability
             readability
    problem.severity: recommendation
    sub-severity: high
    precision: very-high
    id: py/should-use-with
  queryHelp: |
    # Should use a 'with' statement
    The `with` statement was introduced by PEP343 to allow standard uses of `try-finally` statements to be factored out. Using this simplification makes code easier to read.


    ## Recommendation
    Review the code and determine whether or not the `try-finally` is used only to ensure that a resource is closed. If the only purpose is to ensure that a resource is closed, then replace the `try-finally` statement with a `with` statement.


    ## Example
    The following code shows examples of different ways of ensuring that a file is always closed, even when an error is generated. In the second example, the `try-finally` block is replaced by a simpler `with` statement.


    ```python

    f = open("filename")
    try:                         # Method of ensuring file closure
        f.write(...)
    finally:
        f.close()


    with open("filename") as f:  # Simpler method of ensuring file closure
        f.write(...)
    ```

    ## References
    * Python Language Reference: [The with statement](http://docs.python.org/reference/compound_stmts.html#the-with-statement).
    * Python Standard Library: [Context manager ](http://docs.python.org/library/stdtypes.html#context-manager-types).
    * Python PEP 343: [The "with" Statement](http://www.python.org/dev/peps/pep-0343).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/SideEffectInAssert.ql
  relativeBqrsPath: codeql/python-queries/Statements/SideEffectInAssert.bqrs
  metadata:
    name: An assert statement has a side-effect
    description: |-
      Side-effects in assert statements result in differences between normal
                    and optimized behavior.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/side-effect-in-assert
  queryHelp: |
    # An assert statement has a side-effect
    All code defined in assert statements is ignored when optimization is requested, that is, the program is run with the `-O` flag. If an assert statement has any side-effects then the behavior of the program changes when optimization is requested.


    ## Recommendation
    Move all expressions with side-effects out of assert statements.


    ## Example
    In the example, the exit code from `subprocess.call()` is checked against 0, but the entire expression is called from within an `assert` statement. If the code is ever run, then the not only the assertion itself, but also the external call, will be discarded. It is better to save the result of `subprocess.call()` to a temporary variable, and to assert that variable to be 0.


    ```python
    assert subprocess.call(['run-backup']) == 0

    ```

    ## References
    * Python Language Reference: [The assert statement](http://docs.python.org/2/reference/simple_stmts.html#assert).
    * TutorialsPoint, Python Programming: [Assertions in Python](http://www.tutorialspoint.com/python/assertions_in_python.htm).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/StatementNoEffect.ql
  relativeBqrsPath: codeql/python-queries/Statements/StatementNoEffect.bqrs
  metadata:
    name: Statement has no effect
    description: A statement has no effect
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
             external/cwe/cwe-561
    problem.severity: recommendation
    sub-severity: high
    precision: high
    id: py/ineffectual-statement
  queryHelp: |
    # Statement has no effect
    An expression statement without side effects is just clutter. It confuses the reader and may have a slight impact on performance.


    ## Recommendation
    First determine what the intention of the code was, if there is no intention of a side effect, then just delete the statement. However, it is probable that there is a mistake in the code and some effect was intended.

    This query will not flag a statement consisting solely of a string as having no side effect, as these are often used as comments. If you want to use strings as comments, the most common convention is to use triple quoted strings rather than single quoted ones. Although consistency is more important than conforming to any particular style.


    ## Example
    In this example neither line of the `increment_and_show()` function has any effect.

    The first line, `++x`, has no effect as it applies the unary plus operator twice. Probably the programmer intended `x += 1`

    The second line, `x.show`, has no observable effect, but it is likely that `x.show()` was intended.


    ```python

    def increment_and_show(x):
        ++x
        x.show

    ```
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/TopLevelPrint.ql
  relativeBqrsPath: codeql/python-queries/Statements/TopLevelPrint.bqrs
  metadata:
    name: Use of a print statement at module level
    description: Using a print statement at module scope (except when guarded by `if
      __name__ == '__main__'`) will cause surprising output when the module is imported.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: recommendation
    sub-severity: high
    precision: high
    id: py/print-during-import
  queryHelp: |
    # Use of a print statement at module level
    Using `print` statements in level scope may result in surprising output at import time. This in turn means that other code cannot safely import the module in question if the program may only write real output to standard out.


    ## Recommendation
    Replace the `print` statements with calls to some form of logging function or use the `warnings` module.


    ## Example
    In the example, importing the module may cause a message to be printed, which may interfere with the operation of the program.


    ```python

    try:
        import fast_system as system
    except ImportError:
        print ("Cannot import fast system, falling back on slow system")
        import slow_system as system

    #Fixed version
    import logging

    try:
        import fast_system as system
    except ImportError:
        logging.info("Cannot import fast system, falling back on slow system")
        import slow_system as system

    ```

    ## References
    * Python Language Reference: [The print statement](http://docs.python.org/2/reference/simple_stmts.html#the-print-statement).
    * Python Standard Library: [The print function](http://docs.python.org/3/library/functions.html#print).
    * Python tutorial: [Modules](http://docs.python.org/2/tutorial/modules.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/UnnecessaryDelete.ql
  relativeBqrsPath: codeql/python-queries/Statements/UnnecessaryDelete.bqrs
  metadata:
    name: Unnecessary delete statement in function
    description: |-
      Using a 'delete' statement to delete a local variable is
                    unnecessary, because the variable is deleted automatically when
                    the function exits.
    kind: problem
    tags: |-
      maintainability
             useless-code
    problem.severity: warning
    sub-severity: low
    precision: high
    id: py/unnecessary-delete
  queryHelp: |
    # Unnecessary delete statement in function
    Passing a local variable to a `del` statement results in that variable being removed from the local namespace. When exiting a function all local variables are deleted, so it is unnecessary to explicitly delete variables in such cases.


    ## Recommendation
    Remove the `del` statement.


    ## Example
    In the function below, the variable `x` is assigned a value that is used for a calculation, and is then explicitly deleted before the function exits. In this case, the delete statement can be removed without changing the behavior of the function.


    ```python
    def unnecessary_delete():
        x = get_some_object()
        do_calculation(x)
        del x                       # This del statement is unnecessary

    ```

    ## References
    * Python: [The 'del' statement](https://docs.python.org/2/reference/simple_stmts.html#the-del-statement).
    * Python/C API Reference Manual: [Reference counts](https://docs.python.org/2.0/api/refcounts.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/UnnecessaryElseClause.ql
  relativeBqrsPath: codeql/python-queries/Statements/UnnecessaryElseClause.bqrs
  metadata:
    name: Unnecessary 'else' clause in loop
    description: An 'else' clause in a 'for' or 'while' statement that does not contain
      a 'break' is redundant.
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/redundant-else
  queryHelp: |
    # Unnecessary 'else' clause in loop
    The `else` clause of a loop (either a `for` or a `while` statement) executes immediately after the loop terminates normally. If there is a `break` statement in the loop body, then the `else` clause is skipped. If there is no `break` statement, then the `else` clause will always be executed after the loop, unless it exits with a `return` or `raise`. Therefore, if there is no `break` statement in the loop body then the `else` clause can be replaced with unindented code.

    Generally the use of `else` clauses should be avoided where possible, as they are likely to be misunderstood.


    ## Recommendation
    Replace the `else` clause with unindented code.


    ## Example
    In this example, the `pointless_else` function contains a redundant `else` clause. The `else` clause can be simplified, as shown in the `no_else` function, which has the same semantics, but has no `else` clause. The third example function, `with_break`, shows a version where the `else` clause is necessary, as the `break` statement skips the `else` clause.


    ```python
    def pointless_else(container):
        for item in container:
            if of_interest(item):
                return item
        else:
            raise NotFoundException()

    def no_else(container):
        for item in container:
            if of_interest(item):
                return item
        raise NotFoundException()

    def with_break(container):
        for item in container:
            if of_interest(item):
                found = item
                break
        else:
            raise NotFoundException()
        return found

    ```

    ## References
    * Python Language Reference: [The while statement](http://docs.python.org/2/reference/compound_stmts.html#the-while-statement).
    * Python Tutorial: [Break and continue statements, and else clauses on loops](http://docs.python.org/2/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/UnnecessaryPass.ql
  relativeBqrsPath: codeql/python-queries/Statements/UnnecessaryPass.bqrs
  metadata:
    name: Unnecessary pass
    description: Unnecessary 'pass' statement
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/unnecessary-pass
  queryHelp: |
    # Unnecessary pass
    A `pass` statement is only necessary when it is the only statement in a block (the list of statements forming part of a compound statement). This is because the purpose of the ` pass` statement is to allow empty blocks where they would otherwise be syntactically invalid. If the block already contains other statements then the `pass` statement is unnecessary.


    ## Recommendation
    Remove the `pass` statement.


    ## References
    * Python: [pass](http://docs.python.org/2/tutorial/controlflow.html#pass-statements).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/UnreachableCode.ql
  relativeBqrsPath: codeql/python-queries/Statements/UnreachableCode.bqrs
  metadata:
    name: Unreachable code
    description: Code is unreachable
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
             external/cwe/cwe-561
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/unreachable-statement
  queryHelp: |
    # Unreachable code
    Unreachable code makes the code more difficult to understand and may slow down loading of modules.


    ## Recommendation
    Deleting the unreachable code will make the code clearer and preserve the meaning of the code. However, it is possible that the original intention was that the code should execute and that it is unreachable signifies some other error.


    ## Example
    In this example the assignment to `remainder` is never reached because there is a ` return` statement on the previous line.


    ```python
    import math

    def my_div(x, y):
        return math.floor(x / y)
        remainder = x - math.floor(x / y) * y

    ```

    ## References
    * Wikipedia: [Unreachable Code](http://en.wikipedia.org/wiki/Unreachable_code).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/UnusedExceptionObject.ql
  relativeBqrsPath: codeql/python-queries/Statements/UnusedExceptionObject.bqrs
  metadata:
    name: Unused exception object
    description: "An exception object is created, but is not used."
    kind: problem
    tags: |-
      quality
             reliability
             error-handling
    problem.severity: error
    sub-severity: low
    precision: very-high
    id: py/unused-exception-object
  queryHelp: |
    # Unused exception object
    Creating a new exception object is no different from creating any other object. The exception needs to be raised to have an effect.


    ## Recommendation
    Insert a `raise` before the exception.


    ## Example
    In this example, the first function `do_action_forgotten_raise()` silently ignores any erroneous input. Whereas, the second function `do_action` correctly raises an exception if the 'action' is not understood.


    ```python

    def do_action_forgotten_raise(action):
        if action == "go":
            start()
        elif action == "stop":
            stop()
        else:
            ValueError(action)

    def do_action(action):
        if action == "go":
            start()
        elif action == "stop":
            stop()
        else:
            raise ValueError(action)

    ```
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Statements/UseOfExit.ql
  relativeBqrsPath: codeql/python-queries/Statements/UseOfExit.bqrs
  metadata:
    name: Use of exit() or quit()
    description: exit() or quit() may fail if the interpreter is run with the -S option.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/use-of-exit-or-quit
  queryHelp: |
    # Use of exit() or quit()
    The `exit` and `quit` "functions" are actually `site.Quitter` objects and are loaded, at interpreter start up, from `site.py`. However, if the interpreter is started with the `-S` flag, or a custom `site.py` is used then `exit` and `quit` may not be present.


    ## Recommendation
    Replace uses of `exit()` and `quit()` with `sys.exit()` which is built into the interpreter and is guaranteed to be present.


    ## Example
    In this example, `exit()` is used and will fail if the interpreter is passed the `-S` option.


    ```python

    def main():
        try:
            process()
        except Exception as ex:
            print(ex)
            exit(1)

    ```
    In this example, `sys.exit()` is used and will behave the same regardless of the interpreter options.


    ```python
    import sys

    def main():
        try:
            process()
        except Exception as ex:
            print(ex)
            sys.exit(1)

    ```

    ## References
    * Python Documentation: [Command line and environment](https://docs.python.org/using/cmdline.html#cmdoption-S).
    * Python Documentation: [Site-specific configuration hook](https://docs.python.org/library/site.html#module-site).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Summary/LinesOfCode.ql
  relativeBqrsPath: codeql/python-queries/Summary/LinesOfCode.bqrs
  metadata:
    name: Total lines of Python code in the database
    description: |-
      The total number of lines of Python code across all files, including
         external libraries and auto-generated files. This is a useful metric of the size of a
         database. This query counts the lines of code, excluding whitespace or comments.
    kind: metric
    tags: |-
      summary
             telemetry
    id: py/summary/lines-of-code
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Summary/LinesOfUserCode.ql
  relativeBqrsPath: codeql/python-queries/Summary/LinesOfUserCode.bqrs
  metadata:
    name: Total lines of user written Python code in the database
    description: |-
      The total number of lines of Python code from the source code directory,
         excluding auto-generated files. This query counts the lines of code, excluding
         whitespace or comments. Note: If external libraries are included in the codebase
         either in a checked-in virtual environment or as vendored code, that will currently
         be counted as user written code.
    kind: metric
    tags: |-
      summary
             lines-of-code
             debug
    id: py/summary/lines-of-user-code
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Testing/ImpreciseAssert.ql
  relativeBqrsPath: codeql/python-queries/Testing/ImpreciseAssert.bqrs
  metadata:
    name: Imprecise assert
    description: Using 'assertTrue' or 'assertFalse' rather than a more specific assertion
      can give uninformative failure messages.
    kind: problem
    tags: |-
      quality
             maintainability
             readability
    problem.severity: recommendation
    sub-severity: high
    precision: very-high
    id: py/imprecise-assert
  queryHelp: "# Imprecise assert\nThe class `unittest.TestCase` provides a range of\
    \ assertion methods. As well as the general forms `assertTrue()` and `assertFalse()`\
    \ more specific forms such as `assertGreaterEquals()` and `assertNotIn()` are\
    \ provided. By using the more specific forms it is possible to get more precise\
    \ and informative failure messages in the event of a test failing. This can speed\
    \ up the debugging process.\n\n\n## Recommendation\nReplace all calls to `assertTrue()`\
    \ and `assertFalse()` that do not provide a custom failure message with a more\
    \ specific variant. Alternatively, provide a tailored failure message using the\
    \ `assertTrue(condition, message)` form.\n\n\n## Example\nIn this example, `assertTrue()`\
    \ and `assertFalse()` are used.\n\n\n```python\nfrom unittest import TestCase\n\
    \nclass MyTest(TestCase):\n    \n    \n    def testInts(self):\n        self.assertTrue(1\
    \ == 1)\n        self.assertFalse(1 > 2)\n        self.assertTrue(1 in []) #This\
    \ will fail\n\n```\nThis will make it more difficult to determine what has gone\
    \ wrong when `self.assertTrue(1 in [])` fails. The failure message \"AssertionError:\
    \ False is not true\" is not very helpful.\n\nA more useful error message can\
    \ be generated by changing the asserts to the more specific forms as in the following\
    \ example.\n\n\n```python\nfrom unittest import TestCase\n\nclass MyTest(TestCase):\n\
    \    \n    \n    def testInts(self):\n        self.assertEqual(1, 1)\n       \
    \ self.assertLessEqual(1, 2)\n        self.assertIn(1, []) #This will fail\n\n\
    ```\nIn this case, the failure message \"AssertionError: 1 not found in \\[\\\
    ]\" is much more informative.\n\n\n## References\n* Python library reference:\
    \ [TestCase.assertEqual](https://docs.python.org/library/unittest.html#unittest.TestCase.assertEqual).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Variables/GlobalAtModuleLevel.ql
  relativeBqrsPath: codeql/python-queries/Variables/GlobalAtModuleLevel.bqrs
  metadata:
    name: Use of 'global' at module level
    description: Use of the 'global' statement at module level
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/redundant-global-declaration
  queryHelp: |
    # Use of 'global' at module level
    The `global` statement is used to specify that assignments to that name are assignments to the variable in the global (module) scope, rather than in the local scope. At the module level, this statement is redundant because the local scope and global scope are the same.


    ## Recommendation
    Remove the `global` statement.


    ## References
    * Python Language Reference: [The global statement](http://docs.python.org/reference/simple_stmts.html#the-global-statement).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Variables/LeakingListComprehension.ql
  relativeBqrsPath: codeql/python-queries/Variables/LeakingListComprehension.bqrs
  metadata:
    name: List comprehension variable used in enclosing scope
    description: Using the iteration variable of a list comprehension in the enclosing
      scope will result in different behavior between Python 2 and 3 and is confusing.
    kind: problem
    tags: |-
      portability
             correctness
    problem.severity: warning
    sub-severity: high
    precision: very-high
    id: py/leaking-list-comprehension
  queryHelp: |
    # List comprehension variable used in enclosing scope
    In Python 2 list comprehensions are evaluated in the enclosing scope, which means that the iteration variable of a list comprehension is visible outside of the list comprehension. In Python 3 the iteration variable is no longer visible in the enclosing scope.

    Code that uses the value of a list comprehension iteration variable after the list comprehension has finished will behave differently under Python 2 and Python 3.


    ## Recommendation
    Explicitly set the variable in the outer scope to the value that it would have held when run under Python 2. Then rename the list comprehension variable for additional clarity.


    ## Example
    In this example, `x` is initially assigned the value of 3. In Python 3, `x` will be unchanged as the list comprehension is evaluated in its own scope. In Python 2, evaluation of the list comprehension occurs in the scope of `two_or_three`, setting `x` to 2.


    ```python

    def two_or_three():
        x = 3
        [0 for x in range(3)]
        return x # Will return 2 in Python 2 and 3 in Python 3.

    print(two_or_three())
    ```
    The following example is the same code as above, but the list comprehension variable is renamed to ensure it does not overwrite `x`.


    ```python

    def just_three():
        x = 3
        [0 for y in range(3)]
        return x # Will return always return 3.

    print(just_three())
    ```

    ## References
    * Python Tutorial: [List Comprehensions](https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions).
    * The History of Python: [From List Comprehensions to Generator Expressions](http://python-history.blogspot.co.uk/2010/06/from-list-comprehensions-to-generator.html).
    * Python Language Reference: [List displays](https://docs.python.org/2/reference/expressions.html#list-displays).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Variables/LoopVariableCapture/LoopVariableCapture.ql
  relativeBqrsPath: codeql/python-queries/Variables/LoopVariableCapture/LoopVariableCapture.bqrs
  metadata:
    name: Loop variable capture
    description: "Capturing a loop variable is not the same as capturing its value,\
      \ and can lead to unexpected behavior or bugs."
    kind: path-problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/loop-variable-capture
  queryHelp: "# Loop variable capture\nIn Python, a nested function or lambda expression\
    \ that captures a variable from its surrounding scope is a *late-binding* closure,\
    \ meaning that the value of the variable is determined when the closure is called,\
    \ not when it is created.\n\nCare must be taken when the captured variable is\
    \ a loop variable. If the closure is called after the loop ends, it will use the\
    \ value of the variable on the last iteration of the loop, rather than the value\
    \ at the iteration at which it was created.\n\n\n## Recommendation\nEnsure that\
    \ closures that capture loop variables aren't used outside of a single iteration\
    \ of the loop. To capture the value of a loop variable at the time the closure\
    \ is created, use a default parameter, or `functools.partial`.\n\n\n## Example\n\
    In the following (BAD) example, a `tasks` list is created, but each task captures\
    \ the loop variable `i`, and reads the same value when run.\n\n\n```python\n#\
    \ BAD: The loop variable `i` is captured.\ntasks = []\nfor i in range(5):\n  \
    \  tasks.append(lambda: print(i))\n\n# This will print `4,4,4,4,4`, rather than\
    \ `0,1,2,3,4` as likely intended.\nfor t in tasks:\n    t() \n```\nIn the following\
    \ (GOOD) example, each closure has an `i` default parameter, shadowing the outer\
    \ `i` variable, the default value of which is determined as the value of the loop\
    \ variable `i` at the time the closure is created.\n\n\n```python\n# GOOD: A default\
    \ parameter is used, so the variable `i` is not being captured.\ntasks = []\n\
    for i in range(5):\n    tasks.append(lambda i=i: print(i))\n\n# This will print\
    \ `0,1,2,3,4``.\nfor t in tasks:\n    t() \n```\nIn the following (GOOD) example,\
    \ `functools.partial` is used to partially evaluate the lambda expression with\
    \ the value of `i`.\n\n\n```python\nimport functools\n# GOOD: `functools.partial`\
    \ takes care of capturing the _value_ of `i`.\ntasks = []\nfor i in range(5):\n\
    \    tasks.append(functools.partial(lambda i: print(i), i))\n\n# This will print\
    \ `0,1,2,3,4``.\nfor t in tasks:\n    t() \n```\n\n## References\n* The Hitchhiker's\
    \ Guide to Python: [Late Binding Closures](http://docs.python-guide.org/en/latest/writing/gotchas/#late-binding-closures).\n\
    * Python Language Reference: [Naming and binding](https://docs.python.org/reference/executionmodel.html#naming-and-binding).\n\
    * Stack Overflow: [Creating functions (or lambdas) in a loop (or comprehension)](https://stackoverflow.com/questions/3431676/creating-functions-or-lambdas-in-a-loop-or-comprehension).\n\
    * Python Language Reference: [functools.partial](https://docs.python.org/3/library/functools.html#functools.partial).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Variables/MultiplyDefined.ql
  relativeBqrsPath: codeql/python-queries/Variables/MultiplyDefined.bqrs
  metadata:
    name: Variable defined multiple times
    description: Assignment to a variable occurs multiple times without any intermediate
      use of that variable
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
             external/cwe/cwe-563
    problem.severity: warning
    sub-severity: low
    precision: very-high
    id: py/multiple-definition
  queryHelp: |
    # Variable defined multiple times
    Multiple assignments to a single variable without an intervening usage makes the first assignment redundant. Its value is lost.


    ## Recommendation
    Ensure that the second assignment is in fact correct. Then delete the first assignment (taking care not to delete right hand side if it has side effects).


    ## Example
    In this example, `x` is assigned the value of 42 but then the value is changed to 12 before `x` is used. This makes the first assignment useless.


    ```python
    x = 42
    x = 12
    print x
    ```

    ## References
    * Python: [Assignment statements](http://docs.python.org/reference/simple_stmts.html#assignment-statements).
    * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Variables/SuspiciousUnusedLoopIterationVariable.ql
  relativeBqrsPath: codeql/python-queries/Variables/SuspiciousUnusedLoopIterationVariable.bqrs
  metadata:
    name: Suspicious unused loop iteration variable
    description: "A loop iteration variable is unused, which suggests an error."
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/unused-loop-variable
  queryHelp: |
    # Suspicious unused loop iteration variable
    A for loop iteration variable is not used in the body of the loop, and the loop does not count the number of items in the sequence. This is suspicious as there is rarely any reason to iterate over a sequence and not use the contents. Not using the loop variable can often indicate a logical error or typo.


    ## Recommendation
    Carefully check that the loop variable should not be used. If the variable is genuinely not being used and the code is correct, then rename the variable to `_` or `unused` to indicate to readers of the code that it is intentionally unused.


    ## Example
    In this example, the `for` loop iteration variable `x` is never used. It appears that the original `test` function was used to test `TypeA` and was subsequently modified to test `TypeB` as well.


    ```python

    #
    def test():
        for t in [TypeA, TypeB]:
            x = TypeA()
            run_test(x)

    ```
    It is likely that the change from `x = TypeA()` to `x = t()` was forgotten. The fixed version is shown below.


    ```python

    #
    def test():
        for t in [TypeA, TypeB]:
            x = t
            run_test(x)

    ```

    ## References
    * Python Language Reference: [The for statement](https://docs.python.org/reference/compound_stmts.html#the-for-statement).
    * Python Tutorial: [For statements](https://docs.python.org/tutorial/controlflow.html#for-statements).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Variables/UndefinedExport.ql
  relativeBqrsPath: codeql/python-queries/Variables/UndefinedExport.bqrs
  metadata:
    name: Explicit export is not defined
    description: |-
      Including an undefined attribute in `__all__` causes an exception when
                    the module is imported using '*'
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: high
    id: py/undefined-export
  queryHelp: |
    # Explicit export is not defined
    When a module is imported using `import *`, all attributes listed in `__all__` are imported. If `__all__` includes attributes that are not defined in the module then an exception is triggered. This usually indicates a typographic error in the attributes in `__all__` or in the name of the object.


    ## Recommendation
    Correct any typographic errors, either in the name of the object or in the string in `__all__`. If there are no typographic errors, either delete the name from `__all__` or add the object to the module.


    ## Example
    In the example, the function name `spam` has been misspelled in the `__all__` list. This will result in `spamm` being highlighted as an undefined export. Correcting the spelling will fix the defect.


    ```python
    __all__ = ['spamm', 'troll', 'paywall']

    def spam(): return 'Spam'
    def troll(): return 'Troll'
    def paywall(): return 'Pay wall'

    ```

    ## References
    * Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).
    * Python Tutorial: [Importing \* from a Package](http://docs.python.org/2/tutorial/modules.html#importing-from-a-package).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Variables/UndefinedPlaceHolder.ql
  relativeBqrsPath: codeql/python-queries/Variables/UndefinedPlaceHolder.bqrs
  metadata:
    name: Use of an undefined placeholder variable
    description: Using a variable before it is initialized causes an exception.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: medium
    id: py/undefined-placeholder-variable
  queryHelp: |
    # Use of an undefined placeholder variable
    This place-holder variable may not be defined. If this code is executed and the variable is undefined then a `NameError` will occur.


    ## Recommendation
    Check that the name of the place-holder variable is not a typographic error. If the name is correct, either define a value for the variable, or import the module that defines the function or method that sets the value.

    If another module initializes this variable before it is used, then the `NameError` may not occur. However, you can make the code more robust and clearer by setting the variable to a default value in its own module.


    ## References
    * Python Standard Library: [NameError](https://docs.python.org/library/exceptions.html#exceptions.NameError).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Variables/UninitializedLocal.ql
  relativeBqrsPath: codeql/python-queries/Variables/UninitializedLocal.bqrs
  metadata:
    name: Potentially uninitialized local variable
    description: Using a local variable before it is initialized causes an UnboundLocalError.
    kind: problem
    tags: |-
      quality
             reliability
             correctness
    problem.severity: error
    sub-severity: low
    precision: medium
    id: py/uninitialized-local-variable
  queryHelp: "# Potentially uninitialized local variable\nThis local variable may\
    \ be used before it is defined. If a variable is assigned to in a function and\
    \ not explicitly declared `global` or `nonlocal` then it is assumed to be a local\
    \ variable. If it is used before it is defined then an `UnboundLocalError` will\
    \ be raised.\n\n\n## Recommendation\nReview the code and consider the intended\
    \ scope of the variable. Determine whether the variable should be global or local\
    \ in scope. If a global variable is required then add a `global` statement, or\
    \ in Python 3 you can use a `nonlocal` statement if the variable occurs in an\
    \ enclosing function. Otherwise, ensure that the variable is defined before it\
    \ is used.\n\n\n## Example\nThe following code includes different functions that\
    \ use variables. `test1()` fails with an `UnboundLocalError` because the local\
    \ variable `var` is used before it is initialized.\n\n\n```python\ndef test():\n\
    \    var = 1 \n    def print_var():\n        print var      # Use variable from\
    \ outer scope\n    print_var()\n    print var \n\n\ndef test1():\n    var = 2\
    \ \n    def print_var():\n        print var       # Attempt to use variable from\
    \ local scope. \n        var = 3         # Since this is not initialized yet,\
    \ this results\n    print_var()         # in an UnboundLocalError\n    print var\
    \ \n\n\ndef test2():\n    var = 2 \n    def print_var():\n        var = 3    \
    \     # Initialize local version of the variable\n        print var       # Use\
    \ variable from local scope.\n    print_var()         # Note that this local variable\
    \ \"shadows\" the variable from\n    print var           # outer scope which makes\
    \ code more difficult to interpret.\n\n\ndef test3():\n    var = 4\n    def print_var():\n\
    \        nonlocal var    # Use non-local variable from outer scope.\n        print\
    \ var\n    print_var()\n    print var\n```\n\n## References\n* Python Standard\
    \ Library: [Built-in Exceptions: UnboundLocalError](http://docs.python.org/library/exceptions.html#exceptions.UnboundLocalError).\n\
    * Python Frequently Asked Questions: [Why am I getting an UnboundLocalError when\
    \ the variable has a value?](http://docs.python.org/2/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value).\n\
    * Python Course: [Global and Local Variables](http://www.python-course.eu/global_vs_local_variables.php).\n\
    * Python Language Reference: [The global statement](http://docs.python.org/2.7/reference/simple_stmts.html#index-54),\
    \ [The nonlocal statement](http://docs.python.org/3.3/reference/simple_stmts.html#index-43).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Variables/UnusedLocalVariable.ql
  relativeBqrsPath: codeql/python-queries/Variables/UnusedLocalVariable.bqrs
  metadata:
    name: Unused local variable
    description: Local variable is defined but not used
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
             external/cwe/cwe-563
    problem.severity: recommendation
    sub-severity: high
    precision: very-high
    id: py/unused-local-variable
  queryHelp: |
    # Unused local variable
    A local variable is defined (by an assignment) but never used.

    It is sometimes necessary to have a variable which is not used. These unused variables should have distinctive names, to make it clear to readers of the code that they are deliberately not used. The most common conventions for indicating this are to name the variable `_` or to start the name of the variable with `unused` or `_unused`.

    The query accepts the following names for variables that are intended to be unused:

    * Any name consisting entirely of underscores.
    * Any name containing `unused`.
    * The names `dummy` or `empty`.
    * Any "special" name of the form `__xxx__`.
    Variables that are defined in a group, for example `x, y = func()` are handled collectively. If they are all unused, then this is reported. Otherwise they are all treated as used.


    ## Recommendation
    If the variable is included for documentation purposes or is otherwise intentionally unused, then change its name to indicate that it is unused, otherwise delete the assignment (taking care not to delete right hand side if it has side effects).


    ## Example
    In this example, the `random_no` variable is never read but its assignment has a side effect. Because of this it is important to remove only the left hand side of the assignment in line 10.


    ```python
    import random

    def write_random_to_file():
        no = random.randint(1, 10)
        with open("random.txt", "w") as file:
            file.write(str(no))
        return no

    def write_random():
        random_no = write_random_to_file()
        print "A random number was written to random.txt"
    ```

    ## References
    * Python: [Assignment statements](http://docs.python.org/2/reference/simple_stmts.html#assignment-statements).
    * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Variables/UnusedModuleVariable.ql
  relativeBqrsPath: codeql/python-queries/Variables/UnusedModuleVariable.bqrs
  metadata:
    name: Unused global variable
    description: Global variable is defined but not used
    kind: problem
    tags: |-
      quality
             maintainability
             useless-code
             external/cwe/cwe-563
    problem.severity: recommendation
    sub-severity: low
    precision: high
    id: py/unused-global-variable
  queryHelp: |
    # Unused global variable
    A global (module-level) variable is defined (by an assignment) but never used and is not explicitly made public by inclusion in the `__all__` list.

    It is sometimes necessary to have a variable which is not used. These unused variables should have distinctive names, to make it clear to readers of the code that they are deliberately not used. The most common conventions for indicating this are to name the variable `_` or to start the name of the variable with `unused` or `_unused`.

    The query accepts the following names for variables that are intended to be unused:

    * Any name consisting entirely of underscores.
    * Any name containing `unused`.
    * The names `dummy` or `empty`.
    * Any "special" name of the form `__xxx__`.
    Variables that are defined in a group, for example `x, y = func()` are handled collectively. If they are all unused, then this is reported. Otherwise they are all treated as used.


    ## Recommendation
    If the variable is included for documentation purposes or is otherwise intentionally unused, then change its name to indicate that it is unused, otherwise delete the assignment (taking care not to delete right hand side if it has side effects).


    ## Example
    In this example, the `random_no` variable is never read but its assignment has a side effect. Because of this it is important to only remove the left hand side of the assignment in line 9.


    ```python
    import random

    def write_random_to_file():
        no = random.randint(1, 10)
        with open("random.txt", "w") as file:
            file.write(str(no))
        return no

    random_no = write_random_to_file()
    ```

    ## References
    * Python: [Assignment statements](http://docs.python.org/reference/simple_stmts.html#assignment-statements), [The import statement](http://docs.python.org/reference/simple_stmts.html#the-import-statement).
    * Python Tutorial: [Importing \* from a package](http://docs.python.org/2/tutorial/modules.html#importing-from-a-package).
    * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).
extensionPacks: []
packs:
  codeql/threat-models#2:
    name: codeql/threat-models
    version: 1.0.33
    isLibrary: true
    isExtensionPack: false
    localPath: file:///C:/Users/bezlp/.codeql/packages/codeql/python-queries/1.6.7/.codeql/libraries/codeql/threat-models/1.0.33/
    localPackDefinitionFile: file:///C:/Users/bezlp/.codeql/packages/codeql/python-queries/1.6.7/.codeql/libraries/codeql/threat-models/1.0.33/qlpack.yml
    headSha: aa3000df1310b332ba1c84afec3bacb0aeb4dbbd
    runDataExtensions: []
  codeql/python-all#1:
    name: codeql/python-all
    version: 4.0.17
    isLibrary: true
    isExtensionPack: false
    localPath: file:///C:/Users/bezlp/.codeql/packages/codeql/python-queries/1.6.7/.codeql/libraries/codeql/python-all/4.0.17/
    localPackDefinitionFile: file:///C:/Users/bezlp/.codeql/packages/codeql/python-queries/1.6.7/.codeql/libraries/codeql/python-all/4.0.17/qlpack.yml
    headSha: aa3000df1310b332ba1c84afec3bacb0aeb4dbbd
    runDataExtensions: []
  codeql/python-queries#0:
    name: codeql/python-queries
    version: 1.6.7
    isLibrary: false
    isExtensionPack: false
    localPath: file:///C:/Users/bezlp/.codeql/packages/codeql/python-queries/1.6.7/
    localPackDefinitionFile: file:///C:/Users/bezlp/.codeql/packages/codeql/python-queries/1.6.7/qlpack.yml
    headSha: aa3000df1310b332ba1c84afec3bacb0aeb4dbbd
    runDataExtensions:
     -
      pack: codeql/python-all#1
      relativePath: ext/default-threat-models-fixup.model.yml
      index: 0
      firstRowId: 0
      rowCount: 1
      locations:
        lineNumbers: A=8
        columnNumbers: A=9
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/Asyncpg.model.yml
      index: 0
      firstRowId: 1
      rowCount: 5
      locations:
        lineNumbers: A=7+1+2+1+2
        columnNumbers: A=9*5
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/Asyncpg.model.yml
      index: 1
      firstRowId: 6
      rowCount: 6
      locations:
        lineNumbers: A=20+4+1*2+2+1
        columnNumbers: A=9*6
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/Stdlib.model.yml
      index: 0
      firstRowId: 12
      rowCount: 12
      locations:
        lineNumbers: A=6+1*4+2+1+2+1*2+4+2
        columnNumbers: A=9*12
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/Stdlib.model.yml
      index: 1
      firstRowId: 24
      rowCount: 1
      locations:
        lineNumbers: A=29
        columnNumbers: A=9
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/Stdlib.model.yml
      index: 2
      firstRowId: 25
      rowCount: 66
      locations:
        lineNumbers: A=37+1+2+4+2*2+4+2*3+1+2+1+2+1+2+4+2+4+2*2+3+2*2+3+1+2*4+4+1+4+1+4+1*5+2*4+4+1+2*11+3+2+3+4+1+2*2+1+2
        columnNumbers: A=9*66
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/builtins.model.yml
      index: 0
      firstRowId: 91
      rowCount: 244
      locations:
        lineNumbers: A=7+3*243
        columnNumbers: A=5*244
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/data/internal/subclass-capture/ALL.model.yml
      index: 0
      firstRowId: 335
      rowCount: 58275
      locations:
        lineNumbers: A=7+3*58274
        columnNumbers: A=5*58275
     -
      pack: codeql/threat-models#2
      relativePath: ext/supported-threat-models.model.yml
      index: 0
      firstRowId: 58610
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/threat-models#2
      relativePath: ext/threat-model-grouping.model.yml
      index: 0
      firstRowId: 58611
      rowCount: 15
      locations:
        lineNumbers: A=8+3+1+3+1*5+3+1+5+1*3
        columnNumbers: A=9*15
  codeql/util#3:
    name: codeql/util
    version: 2.0.20
    isLibrary: true
    isExtensionPack: false
    localPath: file:///C:/Users/bezlp/.codeql/packages/codeql/python-queries/1.6.7/.codeql/libraries/codeql/util/2.0.20/
    localPackDefinitionFile: file:///C:/Users/bezlp/.codeql/packages/codeql/python-queries/1.6.7/.codeql/libraries/codeql/util/2.0.20/qlpack.yml
    headSha: aa3000df1310b332ba1c84afec3bacb0aeb4dbbd
    runDataExtensions: []
